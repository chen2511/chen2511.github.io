<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>《机器学习》 第十章 降维与度量学习</title>
      <link href="/2022/07/01/AI/%E3%80%8A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%91%A8%E5%BF%97%E5%8D%8E/%E7%AC%AC%E5%8D%81%E7%AB%A0%20%E9%99%8D%E7%BB%B4%E4%B8%8E%E5%BA%A6%E9%87%8F%E5%AD%A6%E4%B9%A0%208455eda11a1040dba5aa5df4f0197b46/"/>
      <url>/2022/07/01/AI/%E3%80%8A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%91%A8%E5%BF%97%E5%8D%8E/%E7%AC%AC%E5%8D%81%E7%AB%A0%20%E9%99%8D%E7%BB%B4%E4%B8%8E%E5%BA%A6%E9%87%8F%E5%AD%A6%E4%B9%A0%208455eda11a1040dba5aa5df4f0197b46/</url>
      
        <content type="html"><![CDATA[<h1 id="第十章-降维与度量学习"><a href="#第十章-降维与度量学习" class="headerlink" title="第十章 降维与度量学习"></a>第十章 降维与度量学习</h1><h1 id="10-1-k近邻学习（KNN）"><a href="#10-1-k近邻学习（KNN）" class="headerlink" title="10.1 k近邻学习（KNN）"></a>10.1 k近邻学习（KNN）</h1><p>核心思想：对于测试样本，基于距离度量来找出训练集中与其最近的几个样本，然后根据邻居信息来预测，一般使用投票法（分类）或者平均法（回归），也可加权（根据距离）。</p><blockquote><p>懒惰学习的杰出代表，仅仅只是保存训练样本，没有显式地训练。</p></blockquote><p><img src="/2022/07/01/AI/%E3%80%8A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%91%A8%E5%BF%97%E5%8D%8E/%E7%AC%AC%E5%8D%81%E7%AB%A0%20%E9%99%8D%E7%BB%B4%E4%B8%8E%E5%BA%A6%E9%87%8F%E5%AD%A6%E4%B9%A0%208455eda11a1040dba5aa5df4f0197b46/Untitled.png" alt="Untitled"></p><blockquote><p>理论上，虽然KNN简单，但是性能上的泛化错误率不会超过贝叶斯最优分类器的两倍。</p></blockquote><h1 id="10-2-低维嵌入【略】"><a href="#10-2-低维嵌入【略】" class="headerlink" title="10.2 低维嵌入【略】"></a>10.2 低维嵌入【略】</h1><h1 id="10-3-主成分分析（PCA）"><a href="#10-3-主成分分析（PCA）" class="headerlink" title="10.3 主成分分析（PCA）"></a>10.3 主成分分析（PCA）</h1><p>主成分分析主要用于降维，还可用于去噪。对于降维，可以理解为这么一个问题：如何用超平面对所有样本进行恰当的表达？具有以下性质：</p><ul><li>最近重构性：样本点到超平面的距离都足够近</li><li>最大可分性：样本点到超平面上的投影都尽量分开</li></ul><p>考虑这两个性质，都可以推导出相同的结果。</p><h2 id="最近重构性【略】"><a href="#最近重构性【略】" class="headerlink" title="最近重构性【略】"></a>最近重构性【略】</h2><h2 id="最大可分性"><a href="#最大可分性" class="headerlink" title="最大可分性"></a>最大可分性</h2><p>样本点x到新空间中投影为$W^Tx$，如果要使样本点尽量分开，则样本点的方差应该最大化。</p><p><img src="/2022/07/01/AI/%E3%80%8A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%91%A8%E5%BF%97%E5%8D%8E/%E7%AC%AC%E5%8D%81%E7%AB%A0%20%E9%99%8D%E7%BB%B4%E4%B8%8E%E5%BA%A6%E9%87%8F%E5%AD%A6%E4%B9%A0%208455eda11a1040dba5aa5df4f0197b46/Untitled%201.png" alt="Untitled"></p><p>协方差矩阵为：</p><script type="math/tex; mode=display">\begin{align} \sum_iW^Tx_ix_i^TW\end{align}</script><p>优化目标可改写为：</p><script type="math/tex; mode=display">\begin{align} \max_W &\quad tr(W^TXX^TW) \\s.t. &\quad  W^TW=I\end{align}</script><p>使用拉格朗日乘子法：</p><script type="math/tex; mode=display">\begin{align} XX^Tw_i=\lambda_iw_i\end{align}</script><p>也就是求解左边的特征值。</p><p>具体来说：求解特征值，然后按照特征值的大小进行排序，选取前d个特征值即可。</p><p><img src="/2022/07/01/AI/%E3%80%8A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%91%A8%E5%BF%97%E5%8D%8E/%E7%AC%AC%E5%8D%81%E7%AB%A0%20%E9%99%8D%E7%BB%B4%E4%B8%8E%E5%BA%A6%E9%87%8F%E5%AD%A6%E4%B9%A0%208455eda11a1040dba5aa5df4f0197b46/Untitled%202.png" alt="Untitled"></p><h1 id="10-4-核化线性降维【略】"><a href="#10-4-核化线性降维【略】" class="headerlink" title="10.4 核化线性降维【略】"></a>10.4 核化线性降维【略】</h1>]]></content>
      
      
      <categories>
          
          <category> AI </category>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 《机器学习》周志华 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《机器学习》 第九章 聚类</title>
      <link href="/2022/07/01/AI/%E3%80%8A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%91%A8%E5%BF%97%E5%8D%8E/%E7%AC%AC%E4%B9%9D%E7%AB%A0%20%E8%81%9A%E7%B1%BB%20513b4a2cd967414cb2ee17ce9bdaf8fc/"/>
      <url>/2022/07/01/AI/%E3%80%8A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%91%A8%E5%BF%97%E5%8D%8E/%E7%AC%AC%E4%B9%9D%E7%AB%A0%20%E8%81%9A%E7%B1%BB%20513b4a2cd967414cb2ee17ce9bdaf8fc/</url>
      
        <content type="html"><![CDATA[<h1 id="第九章-聚类"><a href="#第九章-聚类" class="headerlink" title="第九章 聚类"></a>第九章 聚类</h1><h1 id="9-1-聚类任务"><a href="#9-1-聚类任务" class="headerlink" title="9.1 聚类任务"></a>9.1 聚类任务</h1><p>前面讲的都是有监督的任务，对于无标签的数据，我们想要知道数据内在规律。</p><p>聚可以将无标签的数据划分成若干个通常是不想交的子集（簇），每个簇可能有一些潜在的概念，如本地瓜、浅色瓜、深色瓜等等，这些概念通常是使用者来命名的。</p><h1 id="9-2-性能度量"><a href="#9-2-性能度量" class="headerlink" title="9.2 性能度量"></a>9.2 性能度量</h1><p>性能度量既可以评估聚类的好坏，还可以知道聚类过程。</p><p>我们希望的是：同一类样本尽可能近，不同类样本尽可能远。也就是<code>簇内相似度</code>高，<code>簇间相似度</code>低。</p><p>两类度量模型：外部指标（利用参考模型）和内部指标（不使用参考模型）。</p><h2 id="外部指标"><a href="#外部指标" class="headerlink" title="外部指标"></a>外部指标</h2><p><code>声明</code>：</p><p><img src="/2022/07/01/AI/%E3%80%8A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%91%A8%E5%BF%97%E5%8D%8E/%E7%AC%AC%E4%B9%9D%E7%AB%A0%20%E8%81%9A%E7%B1%BB%20513b4a2cd967414cb2ee17ce9bdaf8fc/Untitled.png" alt="Untitled"></p><ul><li>Jaccard系数：（JC）</li></ul><script type="math/tex; mode=display">\begin{align} JC=\frac a {a+b+c}\end{align}</script><ul><li>FM指数</li></ul><script type="math/tex; mode=display">\begin{align} JC= \sqrt{\frac a {a+b}\frac a {a+c}}\end{align}</script><ul><li>Rand指数</li></ul><script type="math/tex; mode=display">\begin{align} JC=\frac {2(a+d)} {m(m-1)}\end{align}</script><p>均在0-1之间，越大越好。</p><h2 id="内部指标"><a href="#内部指标" class="headerlink" title="内部指标"></a>内部指标</h2><p><code>声明</code>：</p><p><img src="/2022/07/01/AI/%E3%80%8A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%91%A8%E5%BF%97%E5%8D%8E/%E7%AC%AC%E4%B9%9D%E7%AB%A0%20%E8%81%9A%E7%B1%BB%20513b4a2cd967414cb2ee17ce9bdaf8fc/Untitled%201.png" alt="Untitled"></p><ul><li>DB指数（DBI）（越小越好）</li></ul><script type="math/tex; mode=display">\begin{align} DBI=\frac 1 k \sum_{i=1}^k{\max_{j\neq i} \left ( \frac {avg(C_i)+avg(C_j)}{d_{cen}(C_i,C_j)} \right) }\end{align}</script><ul><li>Dunn指数（DI）（越大越好）</li></ul><script type="math/tex; mode=display">\begin{align} DI = \min_{1\leq i\leq k}{\left \{\min_{j\neq i} (\frac{d_{min}(C_i,C_j)}{\max_{1\leq l\leq k}diam(C_l)}) \right \} }\end{align}</script><h1 id="9-3-距离计算"><a href="#9-3-距离计算" class="headerlink" title="9.3 距离计算"></a>9.3 距离计算</h1><p>距离度量需要满足一些性质：</p><ul><li>非负性</li><li>同一性（同一个样本距离为0）</li><li>对称性（函数交换位置，距离相等）</li><li>直递性</li></ul><script type="math/tex; mode=display">\begin{align} dist(x_i,x_j)\leq dist(x_i,x_k)+dist(x_k,x_j)\end{align}</script><h2 id="闵可夫斯基距离"><a href="#闵可夫斯基距离" class="headerlink" title="闵可夫斯基距离"></a>闵可夫斯基距离</h2><script type="math/tex; mode=display">\begin{align} dist_{mk}(x_i,x_j)=\left ( \sum_{u=1}^n|x_{iu}-x_{ju}|^p\right)^{\frac 1 p}\end{align}</script><p>类似p范数</p><h2 id="曼哈顿距离"><a href="#曼哈顿距离" class="headerlink" title="曼哈顿距离"></a>曼哈顿距离</h2><p>p=1</p><script type="math/tex; mode=display">\begin{align} dist_{mk}(x_i,x_j)=\sum_{u=1}^n|x_{iu}-x_{ju}|\end{align}</script><h2 id="欧氏距离"><a href="#欧氏距离" class="headerlink" title="欧氏距离"></a>欧氏距离</h2><p>p=2</p><script type="math/tex; mode=display">\begin{align} dist_{mk}(x_i,x_j)=\sqrt {\sum_{u=1}^n|x_{iu}-x_{ju}|^2}\end{align}</script><p>这些距离可用于有序属性，对于无序属性，可以使用VDM方法。</p><p><img src="/2022/07/01/AI/%E3%80%8A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%91%A8%E5%BF%97%E5%8D%8E/%E7%AC%AC%E4%B9%9D%E7%AB%A0%20%E8%81%9A%E7%B1%BB%20513b4a2cd967414cb2ee17ce9bdaf8fc/Untitled%202.png" alt="Untitled"></p><h1 id="9-4-原型聚类"><a href="#9-4-原型聚类" class="headerlink" title="9.4 原型聚类"></a>9.4 原型聚类</h1><p>对于原型聚类的几种方法，大体思想都是假设能够通过一组原型来刻画，也就是一组向量，一个向量表示一个簇心。</p><h2 id="k均值聚类"><a href="#k均值聚类" class="headerlink" title="k均值聚类"></a>k均值聚类</h2><p>算法思想：有k个中心，每类样本到中心的平方误差最小化。（思想简单，但是计算不易）</p><script type="math/tex; mode=display">\begin{align} E=\sum_{i=1}^k\sum_{x\in C_i}||x-\mu_i||_2^2\end{align}</script><p>这是一个NP难问题，于是采用贪心策略，迭代优化。</p><blockquote><p>基本思想：对均值向量初始化，依次对当前簇划分的均值向量迭代更新，若更新后的聚类结果保持不变，则分会结果。</p></blockquote><p><img src="/2022/07/01/AI/%E3%80%8A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%91%A8%E5%BF%97%E5%8D%8E/%E7%AC%AC%E4%B9%9D%E7%AB%A0%20%E8%81%9A%E7%B1%BB%20513b4a2cd967414cb2ee17ce9bdaf8fc/Untitled%203.png" alt="Untitled"></p><p><img src="/2022/07/01/AI/%E3%80%8A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%91%A8%E5%BF%97%E5%8D%8E/%E7%AC%AC%E4%B9%9D%E7%AB%A0%20%E8%81%9A%E7%B1%BB%20513b4a2cd967414cb2ee17ce9bdaf8fc/Untitled%204.png" alt="Untitled"></p><p><img src="/2022/07/01/AI/%E3%80%8A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%91%A8%E5%BF%97%E5%8D%8E/%E7%AC%AC%E4%B9%9D%E7%AB%A0%20%E8%81%9A%E7%B1%BB%20513b4a2cd967414cb2ee17ce9bdaf8fc/Untitled%205.png" alt="Untitled"></p><h2 id="学习向量量化-LVQ【较略】"><a href="#学习向量量化-LVQ【较略】" class="headerlink" title="学习向量量化-LVQ【较略】"></a>学习向量量化-LVQ【较略】</h2><p>LVQ的关键是如何更新原型向量。</p><p><img src="/2022/07/01/AI/%E3%80%8A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%91%A8%E5%BF%97%E5%8D%8E/%E7%AC%AC%E4%B9%9D%E7%AB%A0%20%E8%81%9A%E7%B1%BB%20513b4a2cd967414cb2ee17ce9bdaf8fc/Untitled%206.png" alt="Untitled"></p><p><img src="/2022/07/01/AI/%E3%80%8A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%91%A8%E5%BF%97%E5%8D%8E/%E7%AC%AC%E4%B9%9D%E7%AB%A0%20%E8%81%9A%E7%B1%BB%20513b4a2cd967414cb2ee17ce9bdaf8fc/Untitled%207.png" alt="Untitled"></p><h2 id="高斯混合聚类【较略】"><a href="#高斯混合聚类【较略】" class="headerlink" title="高斯混合聚类【较略】"></a>高斯混合聚类【较略】</h2><p>高斯混合聚类采用概率模型来表达聚类原型。由若干个高斯分布加权而得：</p><p><img src="/2022/07/01/AI/%E3%80%8A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%91%A8%E5%BF%97%E5%8D%8E/%E7%AC%AC%E4%B9%9D%E7%AB%A0%20%E8%81%9A%E7%B1%BB%20513b4a2cd967414cb2ee17ce9bdaf8fc/Untitled%208.png" alt="Untitled"></p><p>求解方法为：<code>EM算法</code>。</p><h1 id="9-5-密度聚类-DBSCAN【较略】"><a href="#9-5-密度聚类-DBSCAN【较略】" class="headerlink" title="9.5 密度聚类-DBSCAN【较略】"></a>9.5 密度聚类-DBSCAN【较略】</h1><p>基于密度的聚类能够根据密度来考察样本的可连接性。DBSCAN是代表性算法。</p><p><img src="/2022/07/01/AI/%E3%80%8A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%91%A8%E5%BF%97%E5%8D%8E/%E7%AC%AC%E4%B9%9D%E7%AB%A0%20%E8%81%9A%E7%B1%BB%20513b4a2cd967414cb2ee17ce9bdaf8fc/Untitled%209.png" alt="Untitled"></p><p><img src="/2022/07/01/AI/%E3%80%8A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%91%A8%E5%BF%97%E5%8D%8E/%E7%AC%AC%E4%B9%9D%E7%AB%A0%20%E8%81%9A%E7%B1%BB%20513b4a2cd967414cb2ee17ce9bdaf8fc/Untitled%2010.png" alt="Untitled"></p><p><img src="/2022/07/01/AI/%E3%80%8A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%91%A8%E5%BF%97%E5%8D%8E/%E7%AC%AC%E4%B9%9D%E7%AB%A0%20%E8%81%9A%E7%B1%BB%20513b4a2cd967414cb2ee17ce9bdaf8fc/Untitled%2011.png" alt="Untitled"></p><h1 id="9-6-层次聚类"><a href="#9-6-层次聚类" class="headerlink" title="9.6 层次聚类"></a>9.6 层次聚类</h1><p>层次聚类试图在不同层次上对数据集进行划分，形成树状结构，即可自上而下，也可自下而上。</p><p>AGNES是自底向上聚合的代表性算法：先将每个样本当做是一类，然后将距离最近的两类聚合，不断合并，直至达到目标。</p><p><img src="/2022/07/01/AI/%E3%80%8A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%91%A8%E5%BF%97%E5%8D%8E/%E7%AC%AC%E4%B9%9D%E7%AB%A0%20%E8%81%9A%E7%B1%BB%20513b4a2cd967414cb2ee17ce9bdaf8fc/Untitled%2012.png" alt="Untitled"></p><p><img src="/2022/07/01/AI/%E3%80%8A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%91%A8%E5%BF%97%E5%8D%8E/%E7%AC%AC%E4%B9%9D%E7%AB%A0%20%E8%81%9A%E7%B1%BB%20513b4a2cd967414cb2ee17ce9bdaf8fc/Untitled%2013.png" alt="Untitled"></p><p><img src="/2022/07/01/AI/%E3%80%8A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%91%A8%E5%BF%97%E5%8D%8E/%E7%AC%AC%E4%B9%9D%E7%AB%A0%20%E8%81%9A%E7%B1%BB%20513b4a2cd967414cb2ee17ce9bdaf8fc/Untitled%2014.png" alt="Untitled"></p>]]></content>
      
      
      <categories>
          
          <category> AI </category>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 《机器学习》周志华 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《机器学习》 第八章 集成学习</title>
      <link href="/2022/07/01/AI/%E3%80%8A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%91%A8%E5%BF%97%E5%8D%8E/%E7%AC%AC%E5%85%AB%E7%AB%A0%20%E9%9B%86%E6%88%90%E5%AD%A6%E4%B9%A0%20f8f2c2d2e40849e3837d8ea2396e358a/"/>
      <url>/2022/07/01/AI/%E3%80%8A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%91%A8%E5%BF%97%E5%8D%8E/%E7%AC%AC%E5%85%AB%E7%AB%A0%20%E9%9B%86%E6%88%90%E5%AD%A6%E4%B9%A0%20f8f2c2d2e40849e3837d8ea2396e358a/</url>
      
        <content type="html"><![CDATA[<h1 id="第八章-集成学习"><a href="#第八章-集成学习" class="headerlink" title="第八章 集成学习"></a>第八章 集成学习</h1><h1 id="8-1-个体与集成"><a href="#8-1-个体与集成" class="headerlink" title="8.1 个体与集成"></a>8.1 个体与集成</h1><p>集成学习就是构建并结合多个学习器来完成学习任务，也被称作是多分类器系统。</p><p>一般是先产生一组“个体学习器”，再根据某种策略将它们结合起来，一般由现有的算法生成，比如决策树、神经网络等等；既有同质的集成也有异质的集成，取决于是否使用相同的基学习算法。</p><p>集成学习将多个学习器进行结合，常常可以获得比单一学习器更优秀的性能。这对于弱学习器更加明显。</p><blockquote><p>通常来说，将好坏的东西混合在一起，会比最好的差一些，最差的好一些，平均了。<br>但是我们想要的是比最好的还好一些。</p></blockquote><p>集成学习的<code>原则</code>是要：好而不同。既要有一定的准确性，还要有多样性，学习器之间有差异。但是这两样又是互相<code>冲突的</code>。</p><p><code>分类</code>：</p><p>1、强依赖关系、必须串行化生成的序列化方法：如Boosting</p><p>2、并行化，如：Bagging和RF</p><h1 id="8-2-Boosting【有省略】"><a href="#8-2-Boosting【有省略】" class="headerlink" title="8.2 Boosting【有省略】"></a>8.2 Boosting【有省略】</h1><p><code>工作机制</code>：先用训练数据生成一个基学习器，再根据基学习器的表现对训练样本进行调整，使得做错的样本收到更多的关注，调整以后再训练下一个基分类器。</p><p>代表算法是<code>AdaBoost</code>【只能用于二分类】</p><p><img src="/2022/07/01/AI/%E3%80%8A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%91%A8%E5%BF%97%E5%8D%8E/%E7%AC%AC%E5%85%AB%E7%AB%A0%20%E9%9B%86%E6%88%90%E5%AD%A6%E4%B9%A0%20f8f2c2d2e40849e3837d8ea2396e358a/Untitled.png" alt="Untitled"></p><p>从<code>偏差-方差</code>角度理解，Boosting算法主要是为了降低偏差，因此可以从泛化性能弱的学习器中构建很强的集成。如上图。</p><h1 id="8-3-Bagging和随机森林"><a href="#8-3-Bagging和随机森林" class="headerlink" title="8.3 Bagging和随机森林"></a>8.3 Bagging和随机森林</h1><p>想要得到比较强的集成，个体学习器应该要互相独立；但是现实任务独立无法做到，但是可以设法实现数据集有较大的差异。如进行采样【前面讲得自助采样法】，每个子集训练一个学习器；这个子集不能太小，不然无法学习足够好。</p><h2 id="8-3-1-Bagging"><a href="#8-3-1-Bagging" class="headerlink" title="8.3.1 Bagging"></a>8.3.1 Bagging</h2><p>基于自助采样法，抽取一个样本再放回去继续抽，这样m个样本抽取m次，大约有0.632的样本出现在训练集。</p><p>因此可以构造T个学习器，然后对预测输出进行结合，比如<code>分类</code>使用简单投票法、<code>回归</code>任务使用平均法，票数相同时可以使用随机也可以使用置信度。</p><blockquote><p>包外估计有许多优点。可以用来做验证集、辅助剪枝等等</p></blockquote><p>从<code>偏差-方差</code>角度看，Bagging主要关注降低<code>方差</code></p><h2 id="8-3-2-随机森林"><a href="#8-3-2-随机森林" class="headerlink" title="8.3.2 随机森林"></a>8.3.2 随机森林</h2><p>是以<code>决策树</code>为基学习器构建<code>Bagging集成</code>的基础上，进一步在决策树的训练过程中引入了<code>随机属性选择</code>。</p><p><code>传统的决策树</code>在选择划分属性时选择最优属性，在RF中，先随机选择一个包含k个属性的子集，再选择最优属性。k对于1时，随机选择一个属性；推荐k=log2 维度。</p><p>随机森林简单、容易实现、计算开销小。</p><h1 id="8-4-结合策略"><a href="#8-4-结合策略" class="headerlink" title="8.4 结合策略"></a>8.4 结合策略</h1><p>结合学习器的<code>好处</code>：</p><ul><li>假设空间比较大，单个学习器可能再训练集不错，但是泛化性能可能不佳，结合多个学习器可以减少这一风险</li><li>算法可能陷入局部最小，多次运行结合可能可以跳出局部最小。</li></ul><p>1、平均法【数值型输出】</p><ul><li>简单平均法</li><li>加权平均法</li></ul><p>一般而言，个体性能差距较大，可以使用加权平均法；个体性能相近使用简单平均法</p><p>2、投票法【类别】</p><ul><li>绝对多数投票法：过半，否则拒绝</li><li>相对多数：票数最多的</li><li>加权投票法</li></ul><p>3、学习法：通过另一个学习器来结合</p><ul><li>多响应线性回归</li><li>贝叶斯模型平均</li></ul><h1 id="8-5-多样性【略】"><a href="#8-5-多样性【略】" class="headerlink" title="8.5 多样性【略】"></a>8.5 多样性【略】</h1>]]></content>
      
      
      <categories>
          
          <category> AI </category>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 《机器学习》周志华 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《机器学习》 第七章 贝叶斯分类器</title>
      <link href="/2022/07/01/AI/%E3%80%8A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%91%A8%E5%BF%97%E5%8D%8E/%E7%AC%AC%E4%B8%83%E7%AB%A0%20%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%88%86%E7%B1%BB%E5%99%A8%203ff39e25ec7e42678ed297d26fa406c8/"/>
      <url>/2022/07/01/AI/%E3%80%8A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%91%A8%E5%BF%97%E5%8D%8E/%E7%AC%AC%E4%B8%83%E7%AB%A0%20%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%88%86%E7%B1%BB%E5%99%A8%203ff39e25ec7e42678ed297d26fa406c8/</url>
      
        <content type="html"><![CDATA[<h1 id="第七章-贝叶斯分类器"><a href="#第七章-贝叶斯分类器" class="headerlink" title="第七章 贝叶斯分类器"></a>第七章 贝叶斯分类器</h1><h1 id="7-1-贝叶斯决策论"><a href="#7-1-贝叶斯决策论" class="headerlink" title="7.1 贝叶斯决策论"></a>7.1 贝叶斯决策论</h1><p>对于N种可能的类别标记，$\lambda_{ij}$是将真实样本cj作物分类为ci产生的损失。基于后验概率可以计算将样本分类为ci的期望损失，即在样本x上的条件风险。</p><script type="math/tex; mode=display">\begin{align} R(c_i|x)=\sum_{i=1}^N{\lambda_{ij}P(c_j|x)}\end{align}</script><blockquote><p>上述公式的意思就是：一个样本来了，对于每一类都有一个概率，对样本x计算错分成其他类别的概率再乘以损失，得到总的损失。就是条件风险</p></blockquote><p>而我们要做的就是找到一个判定准则，使得总体风险最小。</p><script type="math/tex; mode=display">\begin{align} R(h)=\mathbb{E}_x[R(h(x)|x)] \end{align}</script><p>如果对于每一个样本都能够最小化风险R，那么总体的风险就将被最小化。</p><p>这就是<code>贝叶斯判定准则</code>：为最小化总体风险，只需要对<code>每个样本</code>选择那个能够使条件风险最小化的类别标记。</p><script type="math/tex; mode=display">\begin{align} h^*(x)=\arg \min_{c\in Y}R(c|x) \end{align}</script><p>此时，h(x)被称作是贝叶斯最优分类器，与之对应的R是贝叶斯风险。</p><blockquote><p>问题：如何求后验概率</p></blockquote><p>具体来说，对于每个样本，选择使得<code>后验概率</code>$P(c|x)$最大的类别标记即可。</p><p>但是现实任务中很难直接获得。主要有两种策略：</p><p>1、给定x，直接建模$P(c|x)$来预测c，这样得到的是<code>判别式模型</code>。前面的决策树、神经网络、SVM都是这类。</p><p>2、先对联合概率密度建模$P(x,c)$，然后再获得$P(c|x)$，这样是<code>生成式模型</code>。</p><blockquote><p>贝叶斯定理求解</p></blockquote><p>根据贝叶斯定理，后验概率可以改写为：</p><script type="math/tex; mode=display">\begin{align} P(c|x)&=\frac{P(x,c)}{P(x)}\\&=\frac{P(c)P(x|c)}{P(x)}\end{align}</script><p>其中$P(c)$是类的“<code>先验概率</code>”；</p><p>$P(x|c)$是样本x相对于标记c的<code>类条件概率</code>，也被称作是似然。（也就是在好瓜中，声音清脆的比例，等等）</p><p>$P(x)$是由于归一化的<code>“证据”因子</code>，对于给定样本x，证据因子与类别标记无关。</p><p>因此求解后验概率就变成了求解先验概率和类条件概率。</p><p>1、对于先验概率：表达了样本空间中每类样本所占的比例，根据大数定律，可以根据各类样本所占的比例来估计。</p><p>2、对于类条件概率：由于涉及到样本x的所有属性的联合概率，直接按频率估计会有比较大的困难，因为很多样本根本没有出现，比如n维2值属性，样本空间就有2的n次方，样本数往往达不到，因此用频率估计会有很大的问题。不用因为没有观测到，就认为出现的概率为0。</p><h1 id="7-2-极大似然估计"><a href="#7-2-极大似然估计" class="headerlink" title="7.2 极大似然估计"></a>7.2 极大似然估计</h1><blockquote><p>对于估计类条件概率，常用的策略是先假设分布形式，再根据样本来估计参数。这就是数理统计中的参数估计部分的内容。<br>有两个学派：<br>1、频率主义学派：认为参数未知，但是是固定值，可以通过矩估计、最大似然估计等计算。<br>2、贝叶斯学派，认为参数是一个随机变量，也符合一个分布，先假设服从一个先验分布，再根据观测的数据计算参数的后验分布。</p></blockquote><p>本节介绍最大似然估计</p><blockquote></blockquote><p>核心思想是：如果一个事件发生了，哪个假设（参数）能 使得事件发生的概率最大，我们就选择哪个假设（参数）。</p><p>比如：猎人和萌新去打猎，兔子被打死了，是谁打的呢？猎人打中的概率明显高于新手，我们可以认为是猎人干的。</p><p>例子2：从符合正态分布的总体（均值未知）中取出许多个点，每个点都有一个概率公式，我们让所有点的概率公式连乘，就可以认为是这抽取一批样本联合概率。</p><blockquote><p>这种方法较为简单，但是非常依赖假设的概率分布是否接近潜在真实分布</p></blockquote><h1 id="7-3-朴素贝叶斯分类器"><a href="#7-3-朴素贝叶斯分类器" class="headerlink" title="7.3 朴素贝叶斯分类器"></a>7.3 朴素贝叶斯分类器</h1><p>从第一节中可以看到，估计后验概率的主要困难在于：类条件概率是在所有属性上的联合概率，难以从有限样本中估计。</p><p>朴素贝叶斯分类器采用了“属性条件独立性假设”，也就是所有属性相互独立。后验概率重写为：</p><script type="math/tex; mode=display">\begin{align} P(c|x)&=\frac{P(c)P(x|c)}{P(x)} \\&=\frac{P(c)}{P(x)}\prod_{i=1}^d P(x_i|c)\end{align}</script><blockquote><p>具体来说，将原来的n维互相影响的随机变量变成n维独立地随机变量，然后分解成n个简单的概率。<br>这里可能有个小问题，如果某个属性的样本数为0，那么连乘之后的概率还是0，不太合理，需要平滑数据。</p></blockquote><p><img src="/2022/07/01/AI/%E3%80%8A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%91%A8%E5%BF%97%E5%8D%8E/%E7%AC%AC%E4%B8%83%E7%AB%A0%20%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%88%86%E7%B1%BB%E5%99%A8%203ff39e25ec7e42678ed297d26fa406c8/Untitled.png" alt="Untitled"></p><p><img src="/2022/07/01/AI/%E3%80%8A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%91%A8%E5%BF%97%E5%8D%8E/%E7%AC%AC%E4%B8%83%E7%AB%A0%20%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%88%86%E7%B1%BB%E5%99%A8%203ff39e25ec7e42678ed297d26fa406c8/Untitled%201.png" alt="Untitled"></p><p><img src="/2022/07/01/AI/%E3%80%8A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%91%A8%E5%BF%97%E5%8D%8E/%E7%AC%AC%E4%B8%83%E7%AB%A0%20%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%88%86%E7%B1%BB%E5%99%A8%203ff39e25ec7e42678ed297d26fa406c8/Untitled%202.png" alt="Untitled"></p><p><img src="/2022/07/01/AI/%E3%80%8A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%91%A8%E5%BF%97%E5%8D%8E/%E7%AC%AC%E4%B8%83%E7%AB%A0%20%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%88%86%E7%B1%BB%E5%99%A8%203ff39e25ec7e42678ed297d26fa406c8/Untitled%203.png" alt="Untitled"></p><h1 id="7-4-半朴素贝叶斯分类器"><a href="#7-4-半朴素贝叶斯分类器" class="headerlink" title="7.4 半朴素贝叶斯分类器"></a>7.4 半朴素贝叶斯分类器</h1><p>前一节中，为了降低贝叶斯公式中后验概率的估计，采用了属性独立性假设，但是现实任务中较难成立，于是把条件适当放松，允许一部分属性相互依赖，半朴素贝叶斯分类器允许每个属性最多依赖一个其他属性。</p><blockquote><p>计算方法【略】</p></blockquote><h1 id="7-5-贝叶斯网"><a href="#7-5-贝叶斯网" class="headerlink" title="7.5 贝叶斯网"></a>7.5 贝叶斯网</h1><p>借助有向无环图（DAG图）来刻画属性之间的依赖关系。</p><h1 id="7-6-EM算法"><a href="#7-6-EM算法" class="headerlink" title="7.6 EM算法"></a>7.6 EM算法</h1><p>前面的算法假设所有属性都能直接被观测到，但是现实中不是这样，比如西瓜的根蒂有时会脱落，无法得知。</p><p>但是我们可以假设无法观测到的属性值为隐变量，而EM算法就是估计隐变量的好方法。</p><p>基本思想是：如果分布的参数已知，则可以根据训练数据推断出最优隐变量的值；反之，如果隐变量的值已知，则可以方便地估计参数。</p><p>算法步骤：</p><p>1、E步：先初始化一个分布的参数值，利用这个参数值来计算对数似然的期望值，来估计隐变量；</p><p>2、M步：利用E步得到的隐变量，来估计心得参数值</p><p>这么循环，直至收敛至最优解。</p>]]></content>
      
      
      <categories>
          
          <category> AI </category>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 《机器学习》周志华 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《机器学习》 第六章 支持向量机</title>
      <link href="/2022/06/30/AI/%E3%80%8A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%91%A8%E5%BF%97%E5%8D%8E/%E7%AC%AC%E5%85%AD%E7%AB%A0%20%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA%2077ca28176e6d4e3194113a438fcf3fb4/"/>
      <url>/2022/06/30/AI/%E3%80%8A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%91%A8%E5%BF%97%E5%8D%8E/%E7%AC%AC%E5%85%AD%E7%AB%A0%20%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA%2077ca28176e6d4e3194113a438fcf3fb4/</url>
      
        <content type="html"><![CDATA[<h1 id="第六章-支持向量机"><a href="#第六章-支持向量机" class="headerlink" title="第六章 支持向量机"></a>第六章 支持向量机</h1><blockquote><p>在这一节中，将介绍SVM的基本思想，以及转换成数学表达式。</p></blockquote><h1 id="6-1-间隔与支持向量"><a href="#6-1-间隔与支持向量" class="headerlink" title="6.1 间隔与支持向量"></a>6.1 间隔与支持向量</h1><blockquote><p>SVM的直观理解</p></blockquote><p>对于一个二分类问题，我们基于一个训练集D可以在样本空间（特征空间）中找到一个超平面来区分开，但是超平面可能很多，我们应该找哪一个呢？</p><p><img src="/2022/06/30/AI/%E3%80%8A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%91%A8%E5%BF%97%E5%8D%8E/%E7%AC%AC%E5%85%AD%E7%AB%A0%20%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA%2077ca28176e6d4e3194113a438fcf3fb4/Untitled.png" alt="Untitled"></p><p>直观上来说，我们喜欢中间粗的线，因为最能够将两类样本分开，而且鲁棒性最高，抗干扰。</p><hr><blockquote><p>基本表示</p></blockquote><p>在样本（特征）空间中，划分超平面可以通过如下方程描述：</p><script type="math/tex; mode=display">\begin{align} w^T x + b = 0\end{align}</script><p>空间中点到超平面的距离可以为：</p><script type="math/tex; mode=display">\begin{align} r = \frac {|  w^T   x + b|}{||   w||} \end{align}</script><p>对于两类样本，正类和反类应该满足：（在曲线两侧）</p><script type="math/tex; mode=display">\begin{align} {  w^T   x_i + b} \geq 0, y_i & = +1 \\{  w^T   x_i + b} \leq 0, y_i  & = -1\end{align}</script><h3 id="支持向量"><a href="#支持向量" class="headerlink" title="支持向量"></a>支持向量</h3><p>距离超平面最近的几个训练样本使得上式成立，他们就被称作是支持向量【虚线上圈出来的点】。</p><h3 id="间隔（margin）"><a href="#间隔（margin）" class="headerlink" title="间隔（margin）"></a>间隔（margin）</h3><p>而一对异类的支持向量到超平面的距离，就是间隔：</p><script type="math/tex; mode=display">\begin{align} margin=2r = 2 \cdot \frac {|  w^T   x + b|}{||   w||} \end{align}</script><p><img src="/2022/06/30/AI/%E3%80%8A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%91%A8%E5%BF%97%E5%8D%8E/%E7%AC%AC%E5%85%AD%E7%AB%A0%20%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA%2077ca28176e6d4e3194113a438fcf3fb4/Untitled%201.png" alt="Untitled"></p><hr><blockquote><p>SVM的数学表示</p></blockquote><p>而支持向量机核心思想就是<code>最大间隔</code>的分类器，在满足分类的情况下使间隔最大化。</p><p>我们可以对<code>公式3、4</code>【约束条件】简化：代入y</p><script type="math/tex; mode=display">\begin{align} s.t. \quad y_i ({  w^T   x_i + b}) \geq 0\end{align}</script><p>又因为左式必定能找到一个下界R，即：</p><script type="math/tex; mode=display">\begin{align} \exist \ R > 0, \ \min \  y_i ({  w^T   x_i + b}) = R\end{align}</script><p>因为在坐标系中对直线参数统一放缩之后，表示的仍然是同一条直线，公式6可以转为：</p><script type="math/tex; mode=display">\begin{align} s.t. \quad y_i ({  w^T   x_i + b}) \geq 1\end{align}</script><p>我们还可以对<code>公式5</code>化简。因为分子部分大于0，且必定存在一个下界，又因为在坐标系中对直线参数统一放缩之后，表示的仍然是同一条直线，所以，对于分子部分，我们也可以用1来替换，即：</p><script type="math/tex; mode=display">\begin{align} \max_{w,b}  \quad \frac {1}{||   w||} \end{align}</script><p>最优化问题常常用求最小表示，公式9又可改为</p><script type="math/tex; mode=display">\begin{align} \min_{w,b} \quad \frac 1 2 {||   w||}^2 \end{align}</script><p>综上，<code>SVM的基本数学模型</code>为：</p><script type="math/tex; mode=display">\begin{align} \min_{w,b} & \quad \frac 1 2 {||   w||}^2 \\s.t. & \quad y_i ({  w^T   x_i + b}) \geq 1, \ i=1,2...,m\end{align}</script><h1 id="6-2-对偶问题"><a href="#6-2-对偶问题" class="headerlink" title="6.2 对偶问题"></a>6.2 对偶问题</h1><p>我们希望求解【公式11】来得到超平面的模型，w和b是模型参数，其本身是一个凸优化问题，可以使用现成的优化计算包解决，但是我们有更高效的方法。</p><h2 id="6-2-1-拉格朗日乘子法"><a href="#6-2-1-拉格朗日乘子法" class="headerlink" title="6.2.1 拉格朗日乘子法"></a>6.2.1 拉格朗日乘子法</h2><p>实质：将一个有n 个变量与k 个约束条件的最优化问题转换为一个有n + k个变量的方程组的极值问题，其变量不受任何约束。</p><p>对于有约束问题：</p><script type="math/tex; mode=display">\begin{align} \max_{x,y} &\quad  f(x,y) \\s.t. & \quad g(x,y)=0\end{align}</script><p>构造：</p><script type="math/tex; mode=display">\begin{align} L(x,y,\lambda)=f(x,y)-\lambda \cdot g(x,y)\end{align}</script><p>对各个参数求<code>偏导等于0</code>，求解方程组即可。</p><h2 id="6-2-2-对偶问题"><a href="#6-2-2-对偶问题" class="headerlink" title="6.2.2 对偶问题"></a>6.2.2 对偶问题</h2><p>对于【公式11】，我们可以使用<code>拉格朗日乘子法</code>得到其“<code>对偶问题</code>”。</p><p>对于【公式12】中的每一个约束我们添加一个拉格朗日乘子（大于0），则该问题的拉格朗日函数为：</p><script type="math/tex; mode=display">\begin{align} & L(  w,b,  \lambda)=\frac 1 2 {||   w||}^2 + \sum_{i=1}^m{\lambda _i \cdot(1-y_i(  w^T   x_i+b))} \end{align}</script><p>则原问题的无约束表示为【先求最大再求最小】：</p><script type="math/tex; mode=display">\left \{  \begin{align} &\min_{w,b} \max_\lambda L(  w,b,  \lambda)  \quad \quad \quad \quad \quad \\ & s.t. \quad \lambda _i \geq 0 \end{align}\right.</script><p>那么<code>对偶问题</code>为：【最大最小调换顺序】【同解：原本19式的解强于17式的解，是弱对偶关系；但是由于原问题是凸二次优化问题，所以是强对偶关系，同解。】</p><script type="math/tex; mode=display">\left \{  \begin{align} & \max_\lambda \min_{w,b} L(  w,b,  \lambda) \quad \quad \quad \quad \quad \\ & s.t. \quad \lambda _i \geq 0 \end{align}\right.</script><p> 步骤1：求解w，b为变量时的最小值，对【公式16】中的w和b求偏导等于0得：（这一步比较简单哦）</p><script type="math/tex; mode=display">\begin{align}   w &= \sum_{i=1}^m {\lambda_iy_ix_i} \\0 &= \sum_{i=1}^m{\lambda_i y_i}\end{align}</script><p>把w和b代入L中消去【这里代入导数为0的值，其实就是把求最小过程中的最优解得到，再代入】，得：</p><script type="math/tex; mode=display">\left \{ \begin{align} \max_\lambda \ L(  \lambda) &= \frac 1 2 (\sum_{i=1}^m {\lambda_iy_ix_i})^T(\sum_{j=1}^m {\lambda_jy_jx_j}) + \sum_{i=1}^m{[\lambda _i -\lambda _i y_i(  w^T   x_i+b)]} \quad \quad \quad \quad \quad\\&= \frac 1 2 \sum_{i=1}^m \sum_{j=1}^m \lambda_i \lambda_j y_i y_j   x_i^T   x_j + \sum_{i=1}^m \lambda _i \\s.t. \quad & \sum_{i=1}^m{\lambda_i y_i} =0,\ \lambda_i \geq 0\end{align}\right.</script><p>【如何求解$\lambda$？<code>SMO算法</code>】</p><h3 id="SMO算法"><a href="#SMO算法" class="headerlink" title="SMO算法"></a>SMO算法</h3><p>对于求解公式23，可以使用通用的二次规划问题来求解，但是问题的规模正比于样本数，会有很大的开销。因此提出了很多高效算法，SMO是其中一种。</p><p>基本思路：对于m个要求解的参数，选取一对需要更新的参数，固定其他的参数。</p><p>求解出$\lambda$之后，再求出w和b即可得到模型。<code>w</code>可通过【公式21】求出；</p><script type="math/tex; mode=display">\begin{align} \color{red}  w^* &= \sum_{i=1}^m {\lambda_iy_ix_i}\end{align}</script><p>如何<code>求解b</code>？我们必定能找到一个样本使得【公式33】等式成立，实际上也就是<code>支持向量[Xk, Yk]</code>使之成立。样本值代入即可求得：</p><script type="math/tex; mode=display">\begin{align} \color{red}{b^*} &= y_k -   w^*   x_k\end{align}</script><blockquote><p>从中我们可以看出w是对样本的线性组合，而且只和虚线上的样本【支持向量】有关（因为不是支持向量的点求出的$\lambda$等于0）。<br>而对于b，只需要使用一个支持向量即可求解；而在实际中我们会选择更鲁棒的做法：使用所有支持向量求解的均值。</p></blockquote><p>最后模型为：</p><script type="math/tex; mode=display">\color{red}\begin{align} f(x) &=   w^T   x+b \\&= \sum_{i=1}^m \lambda_i y_i   x_i^T   x_i + b^*\end{align}</script><h3 id="KKT条件"><a href="#KKT条件" class="headerlink" title="KKT条件"></a>KKT条件</h3><p>将原问题【公式17】转换成对偶问题【公式19】的时候说过他们是强对偶关系【同解】。为什么呢？因为他们满足<code>KKT条件</code>。</p><script type="math/tex; mode=display">\left \{  \begin{align} &\frac {\partial L}{\partial   w} =0, \ \frac {\partial L}{\partial b} =0,\  \frac {\partial L}{\partial   \lambda} =0 \\&\lambda_i(1-y_i(  w^Tx_i+b)) = 0 \\ & \lambda_i \geq 0 \\&1-y_i(  w^Tx_i+b) \leq 0 \end{align}\right.</script><p>【公式30】：梯度条件</p><p>【公式31.32】：互补松弛条件。当29等于0时，30或31必有一项为0。</p><p>【公式33】：可行条件</p><p><img src="/2022/06/30/AI/%E3%80%8A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%91%A8%E5%BF%97%E5%8D%8E/%E7%AC%AC%E5%85%AD%E7%AB%A0%20%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA%2077ca28176e6d4e3194113a438fcf3fb4/Untitled%201.png" alt="Untitled"></p><p>再看这张图，对于实线延伸出来的两条虚线</p><ul><li>如果样本点在虚线上，那么【公式33】的值为0，则对$\lambda$的值没有约束；</li><li>如果不在虚线上，那么【公式33】的值不为0，则$\lambda$必须为0；</li></ul><p>这样的话，除了线上的点有意义，其他的点都没有意义<code>（因为等于0，【公式29】求w*时对其他样本的线性组合时自然等于0，没有作用）</code>，可以不需要这些样本。最终模型只与支持向量有关。</p><h1 id="6-3-核函数"><a href="#6-3-核函数" class="headerlink" title="6.3 核函数"></a>6.3 核函数</h1><p>之前的样例较为简单，在低维空间中就线性可分。倘若线性不可分时，我们可以将样本映射到高维空间中，就变得线性可分了，如下所示</p><p><img src="/2022/06/30/AI/%E3%80%8A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%91%A8%E5%BF%97%E5%8D%8E/%E7%AC%AC%E5%85%AD%E7%AB%A0%20%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA%2077ca28176e6d4e3194113a438fcf3fb4/Untitled%202.png" alt="Untitled"></p><p>在新特征空间中划分超平面的模型为：</p><script type="math/tex; mode=display">\begin{align} f(  x) &=   w^T \cdot {\phi(  x)}+b \\\end{align}</script><p>对偶问题也变成了：</p><script type="math/tex; mode=display">\left \{ \begin{align} \max_\lambda \ & L(  \lambda)= \frac 1 2 \sum_{i=1}^m \sum_{j=1}^m \lambda_i \lambda_j y_i y_j \phi(  x_i)^T\phi(   x_j) + \sum_{i=1}^m \lambda _i \quad \quad \quad \quad \quad \\s.t. \quad & \sum_{i=1}^m{\lambda_i y_i} =0,\ \lambda_i \geq 0\end{align}\right.</script><p>这里有个问题，需要求解映射后的特征空间的向量内积，可能维度很高或者是无穷维，而为了避开这个问题，我们设计了一个核函数</p><script type="math/tex; mode=display">\begin{align} K(x_i,x_j)=<\phi(x_i),\phi(x_j)>=\phi(x_i)^T\phi(x_j)\end{align}</script><p>对偶问题进一步表示为：</p><script type="math/tex; mode=display">\left \{ \begin{align} \max_\lambda \ & L(  \lambda)= \frac 1 2 \sum_{i=1}^m \sum_{j=1}^m \lambda_i \lambda_j y_i y_j {\color{red}K(  x_i,  x_j)}+ \sum_{i=1}^m \lambda _i \quad \quad \quad \quad \quad \\s.t. \quad & \sum_{i=1}^m{\lambda_i y_i} =0,\ \lambda_i \geq 0\end{align}\right.</script><blockquote><p>原本的计算过程：样本特征经过映射后的新空间中的向量表示，再计算两个向量之间的内积<br>引入核函数之后：直接得到内积，不需要经过映射。</p></blockquote><script type="math/tex; mode=display">\begin{align} f(x) &=   w^T   x+b \\&= \sum_{i=1}^m \lambda_i y_i {\color{red}K(  x_i,  x_j)} + b^*\end{align}</script><blockquote><p>问题：如何找到这么一个核函数？</p></blockquote><p>已知映射，我们可以找到核函数；如果映射未知呢？核函数是否存在？</p><p>定理6.1：对于任意数据D={x1,x2,……,xn}，只要核矩阵是半正定的，总能找到一个与之对应的映射。</p><blockquote><p>问题：新特征空间对性能的影响</p></blockquote><p>选择不同的核函数就选择了不同的新特征空间，因此<code>核函数的选择</code>变成了最大的变量。核函数选择的不加，性能可能变得不好。常用的核函数：（高斯核也叫rbf核）</p><p><img src="/2022/06/30/AI/%E3%80%8A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%91%A8%E5%BF%97%E5%8D%8E/%E7%AC%AC%E5%85%AD%E7%AB%A0%20%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA%2077ca28176e6d4e3194113a438fcf3fb4/Untitled%203.png" alt="Untitled"></p><p>核函数还可以通过上述核的<code>线性组合</code>得到。</p><h1 id="6-4-软间隔和正则化"><a href="#6-4-软间隔和正则化" class="headerlink" title="6.4 软间隔和正则化"></a>6.4 软间隔和正则化</h1><h2 id="6-4-1-软间隔"><a href="#6-4-1-软间隔" class="headerlink" title="6.4.1 软间隔"></a>6.4.1 软间隔</h2><p>前面讨论的样本是线性可分的，然后现实中可能很多样本是线性不可分的，或者就算找到了一个线性可分的分界面，又如何确定是否过拟合呢？</p><p>缓解这个问题的方法是，允许向量机在一些样本上出错。具体来说是前面介绍的内容要求所有样本都分类正确，而软间隔允许某些样本不满足【公式8】。</p><p><img src="/2022/06/30/AI/%E3%80%8A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%91%A8%E5%BF%97%E5%8D%8E/%E7%AC%AC%E5%85%AD%E7%AB%A0%20%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA%2077ca28176e6d4e3194113a438fcf3fb4/Untitled%204.png" alt="Untitled"></p><p>优化目标为：<code>【这个公式是如何来的？】</code></p><script type="math/tex; mode=display">\begin{align} \min_{w,b} \quad \frac 1 2 {||   w||}^2 + C\sum_{i=1}^m{l_{0/1}(1-y_i(  w^T   x_i+b))} \end{align}</script><p>当C无穷大时，迫使所有样本满足约束；当C的值有限时，允许一些样本不满足约束，如上图的红色样本。</p><p>$l_{0/1}$是“0/1损失函数”。因为该函数不连续，可换为其他函数：</p><script type="math/tex; mode=display">\left \{ \begin{align} &hinge损失=\max(0,1-z)\quad\quad\quad\quad\quad\\&指数损失=\exp(-z) \\&对率损失=\log(1+\exp(-z))\end{align}\right.</script><p><img src="/2022/06/30/AI/%E3%80%8A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%91%A8%E5%BF%97%E5%8D%8E/%E7%AC%AC%E5%85%AD%E7%AB%A0%20%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA%2077ca28176e6d4e3194113a438fcf3fb4/Untitled%205.png" alt="Untitled"></p><p>以<code>hinge损失</code>为例，目标转为：</p><script type="math/tex; mode=display">\begin{align} \min_{w,b} \quad \frac 1 2 {||   w||}^2 + C\sum_{i=1}^m{\max(0,1-y_i(  w^T   x_i+b))} \end{align}</script><p>引入<code>松弛变量</code>。下面就是常用的软间隔支持向量机：</p><script type="math/tex; mode=display">\left \{ \begin{align} \min_{w,b,\xi_i} \quad &\frac 1 2 {||   w||}^2 + {\color{red}C\sum_{i=1}^m \xi_i}\quad\quad\quad\quad\quad\\ s.t. \quad &y_i ({  w^T   x_i + b}) \geq 1-\xi \\&\xi \geq 0, \ i=1,2...,m\end{align} \right.</script><p>其对偶问题为：（差别在于对偶变量的约束不同）【可以使用与前面相同的方法求解】【当然KKT条件也略有不同】</p><script type="math/tex; mode=display">\left \{ \begin{align} \max_\lambda \quad & L(  \lambda)= \frac 1 2 \sum_{i=1}^m \sum_{j=1}^m \lambda_i \lambda_j y_i y_j   x_i^T   x_j + \sum_{i=1}^m \lambda _i \quad \quad \quad \quad \quad \\s.t. \quad & \sum_{i=1}^m{\lambda_i y_i} =0,\\ &{\color{red}0 \leq \lambda_i \leq C},\ i=1,2...,m\end{align}\right.</script><h2 id="6-4-2-正则化"><a href="#6-4-2-正则化" class="headerlink" title="6.4.2 正则化"></a>6.4.2 正则化</h2><p>通过观察上述正常形式、引入核函数、软间隔的支持向量机可以表示为下面的形式：</p><script type="math/tex; mode=display">\begin{align} \min_{w,b} \quad  \Omega (f) + C\sum_{i=1}^m{loss(f(  x_i),y_i)} \end{align}</script><ul><li>前面一项可以看作是描述超平面间隔的大小，称为<code>“结构风险”</code>，用于描述模型的某些性质（比如复杂度小，换个角度，也就是<code>正则化</code>问题）。也可以叫做正则化项</li><li>后一项表示为在训练集上的误差，称为<code>“经验风险”</code>，用于描述模型与训练数据的契合程度。</li><li>参数C对二者进行折中。看作是正则化常数</li></ul><h1 id="6-5-支持向量回归"><a href="#6-5-支持向量回归" class="headerlink" title="6.5 支持向量回归"></a>6.5 支持向量回归</h1><blockquote><p>这一部分内容有省略步骤</p></blockquote><p>对于回归问题，传统的回归模型通过模型输出与真实输出之间的差别来计算损失。但两者完全相同时，损失为0.</p><p>而支持向量回归不同，它能够容忍一定程度的错误样本，即差别大于一定值时才计算损失。假设我们能容忍$\varepsilon$的偏差，就相当于以f(x)为中心延伸了$2\varepsilon$的区域，只要在这个范围内都认为是正确的。</p><p>如下图所示，在隔离带内的样本损失为0.</p><p><img src="/2022/06/30/AI/%E3%80%8A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%91%A8%E5%BF%97%E5%8D%8E/%E7%AC%AC%E5%85%AD%E7%AB%A0%20%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA%2077ca28176e6d4e3194113a438fcf3fb4/Untitled%206.png" alt="Untitled"></p><p>因此，SVR可以<code>形式化</code>为：</p><script type="math/tex; mode=display">\begin{align} \min_{w,b} \quad \frac 1 2 {||   w||}^2 + C\sum_{i=1}^m{l_\varepsilon(1-y_i(  w^T   x_i+b))} \end{align}</script><p>其中，</p><p><img src="/2022/06/30/AI/%E3%80%8A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%91%A8%E5%BF%97%E5%8D%8E/%E7%AC%AC%E5%85%AD%E7%AB%A0%20%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA%2077ca28176e6d4e3194113a438fcf3fb4/Untitled%207.png" alt="Untitled"></p><p>引入松弛变量，可以重写为：</p><script type="math/tex; mode=display">\left \{ \begin{align} \min_{w,b,\xi_i} \quad &\frac 1 2 {||   w||}^2 + C\sum_{i=1}^m (\xi_i+ \hat{\xi_i})\quad\quad\quad\quad\quad\\ s.t. \quad & f(x_i)-y_i \leq \varepsilon+\xi_i \\&y_i-f(x_i) \leq \varepsilon+\hat{\xi_i} \\&\xi_i \geq 0,\hat{\xi_i} \geq 0, \ i=1,2...,m\end{align} \right.</script><p>仍然是引入拉格朗日乘子，求解步骤【略】</p><p>KKT条件【略】</p><p>解得：（也可引入核函数）</p><script type="math/tex; mode=display">\begin{align} f(x) &=\sum_{i=1}^m {\color{red}(\hat \lambda_i-\lambda_i)}   x_i^T   x_i + b^*\end{align}</script><h1 id="6-6-核方法"><a href="#6-6-核方法" class="headerlink" title="6.6 核方法"></a>6.6 核方法</h1><p>无论SVM还是SVR，学得的模型总是能够表示成为核函数的线性组合。因此</p><ul><li>表示定理：优化问题的最优解h(x)都可以表示成为核函数的线性组合。</li></ul><p>人们发展出的一系列基于“核函数”的方法统称为“核方法”。如，通过“核化”将线性学习器变成非线性学习器。如KLDA。</p>]]></content>
      
      
      <categories>
          
          <category> AI </category>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 《机器学习》周志华 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《机器学习》 第五章 神经网络</title>
      <link href="/2022/06/26/AI/%E3%80%8A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%91%A8%E5%BF%97%E5%8D%8E/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%203a634a124057462ca0b45c25c1cde913/"/>
      <url>/2022/06/26/AI/%E3%80%8A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%91%A8%E5%BF%97%E5%8D%8E/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%203a634a124057462ca0b45c25c1cde913/</url>
      
        <content type="html"><![CDATA[<h1 id="第五章-神经网络"><a href="#第五章-神经网络" class="headerlink" title="第五章 神经网络"></a>第五章 神经网络</h1><p><img src="/2022/06/26/AI/%E3%80%8A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%91%A8%E5%BF%97%E5%8D%8E/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%203a634a124057462ca0b45c25c1cde913/Untitled.jpeg" alt="watermelon"></p><p>watermelon</p><h1 id="5-1-神经元模型"><a href="#5-1-神经元模型" class="headerlink" title="5.1 神经元模型"></a>5.1 神经元模型</h1><h2 id="5-1-1-什么是神经网络？"><a href="#5-1-1-什么是神经网络？" class="headerlink" title="5.1.1 什么是神经网络？"></a>5.1.1 什么是神经网络？</h2><p>神经网络是具有适应性的简简单单的单元<code>（神经元）</code>互连的网络，能够模拟生物神经网络系统对真实世界的物体做出交互反应。</p><h2 id="5-1-2-神经元"><a href="#5-1-2-神经元" class="headerlink" title="5.1.2 神经元"></a>5.1.2 神经元</h2><p>在生物神经网络中，当某个神经元的电位超过了一个阈值，那么他就会被激活，即“兴奋”；向其他神经元发送神经递质，进而影响其他神经元。</p><p>1943年，McCulloch和Pitts将上述情形抽象成为“M-P神经元模型”，如下图所示：</p><p><img src="/2022/06/26/AI/%E3%80%8A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%91%A8%E5%BF%97%E5%8D%8E/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%203a634a124057462ca0b45c25c1cde913/Untitled.png" alt="Untitled"></p><p>神经元接收其他n个神经元传递过来的<code>输入信号</code>，将这些信号通过带<code>权重</code>的连接进行传递，将总输入值与阈值进行比较，最后通过<code>激活函数</code>处理产生神经元的<code>输出</code>。</p><p>理想中的激活函数应该是阶跃函数，但是不光滑、不连续，实际上我们常用Sigmod函数。</p><p><img src="/2022/06/26/AI/%E3%80%8A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%91%A8%E5%BF%97%E5%8D%8E/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%203a634a124057462ca0b45c25c1cde913/Untitled%201.png" alt="Untitled"></p><p>将这样的神经元按照一定的层次连接起来，就得到了神经网络。</p><h1 id="5-2-感知机与多层网络"><a href="#5-2-感知机与多层网络" class="headerlink" title="5.2 感知机与多层网络"></a>5.2 感知机与多层网络</h1><h2 id="5-2-1-感知机"><a href="#5-2-1-感知机" class="headerlink" title="5.2.1 感知机"></a>5.2.1 感知机</h2><p>感知机由两层神经网络组成，输入层接收输入信号后传递给输出层（这里只有输出层的神经元是在运算，因此也被称作是<code>功能神经元</code>），输出层是M-P神经元。</p><p>感知机能够容易的实现逻辑与或非等<code>线性可分</code>的问题，但是不能实现异或这样简单的<code>非线性可分</code>的问题。</p><p><img src="/2022/06/26/AI/%E3%80%8A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%91%A8%E5%BF%97%E5%8D%8E/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%203a634a124057462ca0b45c25c1cde913/Untitled%202.png" alt="Untitled"></p><p>如果预测正确，则感知机不变化；否则将更新权，感知机的权重<code>更新公式</code>：</p><script type="math/tex; mode=display">\begin{align} w_i &\gets w_i + \Delta w_i \\\Delta w_i &= \eta(y-y_i)x_i \end{align}</script><p>$\eta \in (0,1)$称之为<code>学习率</code>。</p><p>要解决非线性可分的问题，需要在增加一层神经元，通常被称作是<code>隐藏层</code>。隐藏层和输出层都是有激活功能的功能神经元。</p><p><img src="/2022/06/26/AI/%E3%80%8A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%91%A8%E5%BF%97%E5%8D%8E/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%203a634a124057462ca0b45c25c1cde913/Untitled%203.png" alt="Untitled"></p><p>通常，神经元在同层之间不存在连接，也不存在跨层连接，这样的网络称之为<code>“多层前馈神经网络”</code>。</p><p>通常，输入层只接收外界输入，隐藏层和输出层对数据进行加工。通常被称作是“<code>两层神经网络</code>”，为了避免歧义，也叫作“<code>单隐层网络</code>”。</p><p>学习的过程就是根据训练数据来调整神经元之间的连接权重和每个功能神经元的阈值。换言之，神经网络学习到的东西就蕴含在<code>权值</code>和<code>阈值</code>中间。</p><p><img src="/2022/06/26/AI/%E3%80%8A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%91%A8%E5%BF%97%E5%8D%8E/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%203a634a124057462ca0b45c25c1cde913/Untitled%204.png" alt="Untitled"></p><h1 id="5-3-误差反向传播算法（BP算法）"><a href="#5-3-误差反向传播算法（BP算法）" class="headerlink" title="5.3 误差反向传播算法（BP算法）"></a>5.3 误差反向传播算法（BP算法）</h1><h2 id="5-3-1-前向传播"><a href="#5-3-1-前向传播" class="headerlink" title="5.3.1 前向传播"></a>5.3.1 前向传播</h2><p>层数标记：输入层记为第0层，中间层为l层，最后一层为L层，记在右上角。</p><p>前一层的输入（输入x或中间层的激活值a），</p><script type="math/tex; mode=display">\begin{align} 线性组合：Z^l &= W^l \alpha^{l-1}+b^l \\激活：\alpha^l &= \sigma (z^l) \\损失函数：C &= {\frac 1 2}  {||y - \alpha^L ||}_2\end{align}</script><p>具体到中间的某一个节点：</p><script type="math/tex; mode=display">\begin{align}线性组合：Z^l_j &= \sum_k W^l_j \alpha^{l-1}_k+b^l_j \\激活：\alpha^l_j &= \sigma (z^l_j) \\损失函数：C &= \frac 1 2 \sum_j {(y_j - \alpha^L_j)^2}\end{align}</script><h2 id="5-3-2-反向传播"><a href="#5-3-2-反向传播" class="headerlink" title="5.3.2 反向传播"></a>5.3.2 反向传播</h2><p>四个公式：</p><script type="math/tex; mode=display">\color{red} \begin{align} &BP1：\delta^L = \nabla_\alpha C \odot \sigma'(Z^L) \\&BP2：\delta^l = ((W^{l+1})^T \cdot \delta^{l+1}) \odot \sigma'(Z^l) \\&BP3：\frac {\partial C} {\partial w_{jk}^l} = \alpha_k^{l-1} \delta_j^l \\&BP4: \frac {\partial C} {\partial b_{j}^l} = \delta_j^l\end{align}</script><p><code>矩阵论知识</code>：如果$Y=W \cdot X + B,Y= \sigma(X)$，那么：</p><script type="math/tex; mode=display">\begin{align} \frac {\partial C} {\partial X} &= W^T \odot \sigma'(X)\\\frac {\partial C} {\partial X} &= W^T \cdot \frac {\partial C} {\partial Y} \\\frac {\partial C} {\partial W} &=   \frac {\partial C} {\partial Y} \cdot X^T \\\frac {\partial C} {\partial B} &=   \frac {\partial C} {\partial Y} \end{align}</script><h3 id="BP1："><a href="#BP1：" class="headerlink" title="BP1："></a>BP1：</h3><p>作为一个<code>记号【非常有用】</code>，表示损失值到最后一层L（从第一层隐藏层开始记数1，输入是第0层）的线性加权的输出Z的导数。</p><p><code>具体来说</code>：根据链式求导法则：C先对激活后的值a求导，再点乘激活值a对加权值Z的导数。</p><p>（为什么用点乘？<code>【公式13】</code>因为得到加权值后，再计算激活值，这里面是n对的一对一的实数值的映射，不需要矩阵乘法）</p><h3 id="BP2："><a href="#BP2：" class="headerlink" title="BP2："></a>BP2：</h3><p>作为一个<code>记号</code>，表示损失值到第l层的线性加权的输出Z的导数。</p><p><code>具体来说</code>：这是一个递推公式，假设我们已经得到了第l+1层的导数，我们要计算再到第l层的导数。先看前半部分，根据公式3（线性组合），第l+1层的Z对第l层的a的导数为$W^{l+1}$，用矩阵来描述就是矩阵$W^{l+1}$的转置左乘<code>【公式14】</code>我们已经得到的$\delta^{l+1}$。</p><p>接下来继续按照链式求导法则，点乘对第l层Z的导数即可。</p><h3 id="BP3："><a href="#BP3：" class="headerlink" title="BP3："></a>BP3：</h3><p>损失到第l层权重矩阵的第j行k列的导数：</p><p>具体来说（用记号简化公式）：</p><script type="math/tex; mode=display">\begin{align} \frac {\partial C} {\partial w_{jk}^l} &= \frac {\partial C} {\partial Z_j^l} \cdot \frac {\partial Z_j^l} {\partial w_{jk}^l} \\&= {\color{red}\delta_j^l} \cdot \frac{\partial (w_{jk}^l \alpha_k^{l-1}+b_j^l)}{\partial w_{jk}^l} \\&= {\color{red}\delta_j^l} \cdot \alpha_j^{l-1}\end{align}</script><h3 id="BP4："><a href="#BP4：" class="headerlink" title="BP4："></a>BP4：</h3><p>损失到第l层偏置向量的第j个元素的导数：</p><script type="math/tex; mode=display">\begin{align} \frac {\partial C} {\partial b_j^l} &= \frac {\partial C} {\partial Z_j^l} \cdot \frac {\partial Z_j^l} {\partial b_j^l} \\&= {\color{red}\delta_j^l} \cdot \frac{\partial (w_{jk}^l \alpha_k^{l-1}+b_j^l)}{\partial w_{jk}^l} \\&= {\color{red}\delta_j^l} \cdot 1\end{align}</script><h2 id="5-3-3-更新"><a href="#5-3-3-更新" class="headerlink" title="5.3.3 更新"></a>5.3.3 更新</h2><p>得到了导数/梯度我们就可以方便地使用梯度更新公式更新参数，即：$\eta$ 为学习率</p><script type="math/tex; mode=display">\begin{align} W^l &= W^l-\eta \cdot dW^l \\b^l &= b^l-\eta \cdot db^l\end{align}</script><h2 id="5-3-4-批量梯度下降"><a href="#5-3-4-批量梯度下降" class="headerlink" title="5.3.4 批量梯度下降"></a>5.3.4 批量梯度下降</h2><p>上述内容是针对单个样本的梯度下降，会存在：参数更新频繁，对不同样例进行更新可能会抵消效果，因此累计/批量梯度下降针对整个训练集或者一部分进行更新，频率低很多，在下降一定程度之后，进一步下降会比较慢，会获得比较好的解，尤其在训练集很大的时候。</p><h2 id="5-3-5-过拟合"><a href="#5-3-5-过拟合" class="headerlink" title="5.3.5 过拟合"></a>5.3.5 过拟合</h2><p>神经网络常常会过拟合。如何应对过拟合？</p><p>1、早停：训练集误差降低但是验证集升高，停止训练。</p><p>2、正则化：约束大小，降低神经网络拟合能力。</p><h1 id="5-4-全局最小和局部最小"><a href="#5-4-全局最小和局部最小" class="headerlink" title="5.4 全局最小和局部最小"></a>5.4 全局最小和局部最小</h1><p>根据梯度下降法，如果参数空间中有多个极小值，优化的参数值就有可能落入极小值中</p><p><img src="/2022/06/26/AI/%E3%80%8A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%91%A8%E5%BF%97%E5%8D%8E/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%203a634a124057462ca0b45c25c1cde913/Untitled%205.png" alt="Untitled"></p><p>解决方法：</p><ul><li>多组初始化参数值，即从不同起点开始寻找最小值</li><li>模拟退火算法：可以接受一定的比当前结果更差的值（次优解）</li><li>随机梯度下降。计算的梯度不可能为0</li><li>遗传算法</li></ul><h1 id="5-5-其他常见神经网络"><a href="#5-5-其他常见神经网络" class="headerlink" title="5.5 其他常见神经网络"></a>5.5 其他常见神经网络</h1><p>有RBF、ART、SOM、级联相关网络、Elman网络、Boltzmann机。</p><p>不详细介绍。</p><h1 id="5-6-深度学习"><a href="#5-6-深度学习" class="headerlink" title="5.6 深度学习"></a>5.6 深度学习</h1><p>参数越多的模型复杂度也越高，能够完成复杂度更高的任务，但是训练效率也低、容易过拟合。但是由于计算能力、数据量的大幅提升，使得深度学习变得火热。</p><p>典型的深度学习就是很深层的网络：</p><ul><li>1、增加层数</li><li>2、单纯增加隐藏层神经元数目</li></ul><p>这两种方法一个是横向一个是纵向。增加层数比增加神经元数目更有效。但是深层网络不容易收敛。</p><p>难以训练的问题可以通过“预训练+微调”的方式解决，如DBN。还可以通过权值共享解决，如CNN。</p><p>对深度学习的理解：</p><p>通过多层处理，可以将低层次的特征表示为高层次的特征，然后就可以用简单模型完成复杂的分类任务。可以理解为“提特征”、“特征学习”、“表示学习”（与人工设计的特征不同）。</p>]]></content>
      
      
      <categories>
          
          <category> AI </category>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 《机器学习》周志华 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《机器学习》 第四章 决策树</title>
      <link href="/2022/06/10/AI/%E3%80%8A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%91%A8%E5%BF%97%E5%8D%8E/%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E5%86%B3%E7%AD%96%E6%A0%91%201b6c663806a843019cde9bb6d98c7ef5/"/>
      <url>/2022/06/10/AI/%E3%80%8A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%91%A8%E5%BF%97%E5%8D%8E/%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E5%86%B3%E7%AD%96%E6%A0%91%201b6c663806a843019cde9bb6d98c7ef5/</url>
      
        <content type="html"><![CDATA[<h1 id="第四章-决策树"><a href="#第四章-决策树" class="headerlink" title="第四章 决策树"></a>第四章 决策树</h1><p><img src="/2022/06/10/AI/%E3%80%8A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%91%A8%E5%BF%97%E5%8D%8E/%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E5%86%B3%E7%AD%96%E6%A0%91%201b6c663806a843019cde9bb6d98c7ef5/Untitled.jpeg" alt="watermelon"></p><p>watermelon</p><h1 id="4-1-基本流程"><a href="#4-1-基本流程" class="headerlink" title="4.1 基本流程"></a>4.1 基本流程</h1><p>顾名思义，决策树是基于树结构来进行决策的。</p><p>这与人们面临决策时很自然的一种处理机制，即通过一系列的判断或“子决策”得出最终决策。决策过程中的每个判定问题都是对某个属性的测试，每个测试结果或是导出下一步的判定的问题，或是导出最终结果。</p><p>一般的，一颗决策树包含一个根节点，若干个内部节点和若干个叶节点；叶节点对应于决策结果；其他节点则对应于一个属性测试，每个节点包含的样本集合根据属性测试的结果划分到叶子节点中。从根节点到每个叶子节点的路径对应了一个判定测试序列。其基本流程遵循“分而治之”的策略。</p><p><img src="/2022/06/10/AI/%E3%80%8A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%91%A8%E5%BF%97%E5%8D%8E/%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E5%86%B3%E7%AD%96%E6%A0%91%201b6c663806a843019cde9bb6d98c7ef5/Untitled.png" alt="Untitled"></p><p>决策树的生成过程是一个递归过程。</p><p>在决策树基本算法中有三种情况导致递归返回：</p><ul><li>当前节点的样本全部属于一个类别，无需划分</li><li>当前样本的属性集为空或属性取值相同，无法划分（定义为叶子结点，类别为多数样本）</li><li>当前样本的集合为空，无法划分（标记为父节点的类别）</li></ul><h1 id="4-2-划分选择"><a href="#4-2-划分选择" class="headerlink" title="4.2 划分选择"></a>4.2 划分选择</h1><p>构建决策树的关键是选择每一次划分的属性；随着划分的不断进行，我们希望样本的纯度越来越高，尽可能属于同一类别。</p><h2 id="4-2-1-信息增益"><a href="#4-2-1-信息增益" class="headerlink" title="4.2.1 信息增益"></a>4.2.1 信息增益</h2><p><code>信息熵</code>：度量样本集合纯度最常用的一种指标。</p><p>假设样本集合D中，第k类样本所占的比例为Pk（如好瓜和坏瓜这两种），则信息熵的定义为：</p><script type="math/tex; mode=display">\begin{align} Ent(D) &= - \sum_{k=1}^{|y|} {p_k log_2 {p_k}} \end{align}</script><p><code>值越小</code>，纯度越高</p><p><code>信息增益</code>：考虑到不同分支的样本数不同，给与分支不同的权重，即样本数越大的分支影响越大，</p><p>于是可以计算用属性a对样本集合D进行划分的信息增益：</p><script type="math/tex; mode=display">\begin{align} Gain(D,a) = Ent(D)- \sum_{v=1}^{V}{ {\frac {|D_v|} {|D|}}Ent(D^v)}\end{align}</script><p>一般来说，信息增益越大，意味着用属性a来划分的所获得的纯度越高。</p><blockquote><p>举例：西瓜数据集2.0，一共有17个样本，两种类别。</p></blockquote><p><img src="/2022/06/10/AI/%E3%80%8A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%91%A8%E5%BF%97%E5%8D%8E/%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E5%86%B3%E7%AD%96%E6%A0%91%201b6c663806a843019cde9bb6d98c7ef5/Untitled%201.png" alt="Untitled"></p><p>一开始时，两种类别，D包含所有样例，正例8/17，反例9/17.所以信息熵为：</p><script type="math/tex; mode=display">\begin{align} Ent(D) &= -\sum_{k=1}^{|y|} {p_k log_2 {p_k}} = -(\frac 8 {17}\log_2{\frac 8 {17}}+\frac 9 {17}\log_2{\frac 9 {17}}) =0.998\end{align}</script><p>下面我们计算色泽的信息增益：</p><script type="math/tex; mode=display">\begin{align} Ent(D^1)  = -(\frac 3 {6}\log_2{\frac 3 {6}}+\frac 3 {6}\log_2{\frac 3 {6}}) = 1.000\end{align}</script><script type="math/tex; mode=display">\begin{align} Ent(D^2)  = -(\frac 4 {6}\log_2{\frac 4{6}}+\frac 2 {6}\log_2{\frac 2 {6}}) = 0.918\end{align}</script><script type="math/tex; mode=display">\begin{align} Ent(D^3)  = -(\frac 1 5\log_2{\frac 1 5}+\frac 4 5\log_2{\frac 4 5}) = 0.722\end{align}</script><p>所以“色泽”的信息增益为：</p><script type="math/tex; mode=display">\begin{align} Gain(D, 色泽) &= Ent(D) - \sum_{v=1}^{V}{ {\frac {|D_v|} {|D|}} Ent(D^v) } \\&= 0.998 -(\frac6{17} \times 1.000 +\frac6{17} \times 0.918+\frac5{17} \times 0.722) \\&= 0.109\end{align}</script><p>类似的，我们可以计算其他属性的信息增益。</p><p>Gain(D,根蒂)=0.143；Gain(D,敲声)=0.141；Gain(D,纹理)=0.381；Gain(D,脐部)=0.289；Gain(D,触感)=0.006；</p><p>“纹理”的信息增益最大，所以被选为划分属性。划分结果：</p><p><img src="/2022/06/10/AI/%E3%80%8A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%91%A8%E5%BF%97%E5%8D%8E/%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E5%86%B3%E7%AD%96%E6%A0%91%201b6c663806a843019cde9bb6d98c7ef5/Untitled%202.png" alt="Untitled"></p><p>按照此过程继续划分，可以得到：</p><p><img src="/2022/06/10/AI/%E3%80%8A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%91%A8%E5%BF%97%E5%8D%8E/%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E5%86%B3%E7%AD%96%E6%A0%91%201b6c663806a843019cde9bb6d98c7ef5/Untitled%203.png" alt="Untitled"></p><h2 id="4-2-2-增益率"><a href="#4-2-2-增益率" class="headerlink" title="4.2.2 增益率"></a>4.2.2 增益率</h2><p>上述方法有个问题，如果考虑将编号也作为一个划分属性，其信息增益为0.998，远大于其他。其将产生17个分支，每个分支一个样本，纯度也是最大的。但是这样的决策没有泛化能力，无法对新样本进行预测。</p><p><strong>实际上，信息增益对可选取值数目较多的属性有所偏好。</strong></p><p>所以著名的<code>C4.5</code>算法不直接使用上述算法，而是使用增益率来选择最优属性。增益率定义为：</p><script type="math/tex; mode=display">\begin{align} Gain\_ratio(D,a)  &=\frac {Gain(D,a)}{IV(a)}\\IV(a)&=- \sum_{v=1}^{V}{\frac{|D^v|}{|D|}\log_2\frac{|D^v|}{|D|}}\end{align}</script><p>IV(a)称为属性a的固有值，如果属性可取值的数目越多，那么IV(a)的值<code>通常</code>也会越大。</p><p>但是，增益率又会对可取值较少的属性有偏好，所以一般不是直接选择增益率最大的属性，而是使用启发式算法。</p><p>先从属性里面找到信息增益比较高的，在从中找出增益率最高的。</p><h2 id="4-2-3-基尼指数"><a href="#4-2-3-基尼指数" class="headerlink" title="4.2.3 基尼指数"></a>4.2.3 基尼指数</h2><p><code>CART</code>决策树使用“基尼指数”来选择划分的属性。数据集D的纯度可以用基尼值来度量：</p><script type="math/tex; mode=display">\begin{align} Gini(D,a)  &= \sum_{k=1}^{|Y|}{\sum_{k'\neq k}p_kp_{k'}}\\&=1- \sum_{k=1}^{|Y|}{p_k^2}\end{align}</script><p>直观来说，反映了数据集D中随机抽取两个样本，其类别标记不一样的概率，<code>Gini值越小</code>，纯度越高。</p><p>如果改成与公式11相同的形式，则：</p><script type="math/tex; mode=display">\begin{align} Gini\_index(D,a)  &=- \sum_{v=1}^{V}{\frac{|D^v|}{|D|}Gini(D^v)}\end{align}</script><p>最后在候选属性集合A中，选择基尼指数最小的即可。</p><h1 id="4-3-剪枝处理"><a href="#4-3-剪枝处理" class="headerlink" title="4.3 剪枝处理"></a>4.3 剪枝处理</h1><p>剪枝算法是决策树学习处理“过拟合”的主要手段，在节点划分的过程中，有可能造成决策树的分支过多，这时候可能因为训练样本而训练得“太好了”，以致于<code>过拟合</code>。所以可以主动去掉一些分支来降低过拟合的风险。</p><p><img src="/2022/06/10/AI/%E3%80%8A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%91%A8%E5%BF%97%E5%8D%8E/%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E5%86%B3%E7%AD%96%E6%A0%91%201b6c663806a843019cde9bb6d98c7ef5/Untitled%204.png" alt="未剪枝的决策树"></p><p>未剪枝的决策树</p><h2 id="4-3-1-预剪枝"><a href="#4-3-1-预剪枝" class="headerlink" title="4.3.1 预剪枝"></a>4.3.1 预剪枝</h2><p>预剪枝就是在生成过程中，对每个节点划分前进行估计，如果当前节点划分不能带来决策树<code>泛化性能的提升</code>，则停止划分。</p><blockquote><p>举例：一开始根节点的类别标记为样例最多的类别</p></blockquote><p><img src="/2022/06/10/AI/%E3%80%8A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%91%A8%E5%BF%97%E5%8D%8E/%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E5%86%B3%E7%AD%96%E6%A0%91%201b6c663806a843019cde9bb6d98c7ef5/Untitled%205.png" alt="预剪枝的决策树"></p><p>预剪枝的决策树</p><p>1、用脐部划分之后，验证集的准确率提升为0.714，于是划分确定。</p><p>2、之后再对节点2进行划分，根据信息增益挑选“色泽”，划分后，验证集准确率为0.571，取消划分。</p><p>……</p><h2 id="4-3-2-后剪枝"><a href="#4-3-2-后剪枝" class="headerlink" title="4.3.2 后剪枝"></a>4.3.2 后剪枝</h2><p>首先是生成一颗完整的决策树，然后自底向上地对非叶子结点进行考察，如果将子树变成叶子结点，泛化性能有提升，则将子树替换成叶子结点。</p><blockquote><p>举例：先生成完整的决策树。</p></blockquote><p>1、考察节点6-纹理。将节点替换成叶子结点，准确率提升为0.571，剪枝</p><p>……</p><p>结果为：</p><p><img src="/2022/06/10/AI/%E3%80%8A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%91%A8%E5%BF%97%E5%8D%8E/%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E5%86%B3%E7%AD%96%E6%A0%91%201b6c663806a843019cde9bb6d98c7ef5/Untitled%206.png" alt="Untitled"></p><blockquote><p>对比预剪枝和后剪枝：<br>可以看出，后剪枝保留了更多的分支，欠拟合风险小，而且泛化性能高于预剪枝；<br>但是后剪枝需要建立完整的决策树，需要时间开销。</p></blockquote><h1 id="4-4-连续与缺失值"><a href="#4-4-连续与缺失值" class="headerlink" title="4.4 连续与缺失值"></a>4.4 连续与缺失值</h1><h2 id="4-4-1-连续值处理"><a href="#4-4-1-连续值处理" class="headerlink" title="4.4.1 连续值处理"></a>4.4.1 连续值处理</h2><p>到目前为止，我们讨论的都是离散值，而我们常常会遇到连续值。连续属性往往数目不再有限，此时，我们可以使用连续值离散化处理，比如最简单的<code>二分法</code>进行处理。这也是C4.5中使用的方法。</p><p>样本集合D，给定连续属性a，则取n个不同的取值，将其从小到大排序，则有n-1个划分方法。（样本排序后，两两之间的均值作为候选划分点）。</p><script type="math/tex; mode=display">\begin{align} Gain(D,a) &= \max_{t \in T_a}{Gain(D,a,t)} \\&= \max Ent(D) - \sum_{ \lambda \in \{ -,+ \}}{\frac {|D_\lambda|} {|D|} Ent(D^\lambda_t)}\end{align}</script><blockquote><p>举例：西瓜数据集3.0。增加两个连续值，密度、含糖率</p></blockquote><p><img src="/2022/06/10/AI/%E3%80%8A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%91%A8%E5%BF%97%E5%8D%8E/%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E5%86%B3%E7%AD%96%E6%A0%91%201b6c663806a843019cde9bb6d98c7ef5/Untitled%207.png" alt="Untitled"></p><p>对于连续值密度：有17个样本，计算得到16个候选划分点的候选值：</p><p><img src="/2022/06/10/AI/%E3%80%8A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%91%A8%E5%BF%97%E5%8D%8E/%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E5%86%B3%E7%AD%96%E6%A0%91%201b6c663806a843019cde9bb6d98c7ef5/Untitled%208.png" alt="Untitled"></p><p>同样的，可以得到含糖率的结果为：</p><p><img src="/2022/06/10/AI/%E3%80%8A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%91%A8%E5%BF%97%E5%8D%8E/%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E5%86%B3%E7%AD%96%E6%A0%91%201b6c663806a843019cde9bb6d98c7ef5/Untitled%209.png" alt="Untitled"></p><p>对比其他属性，最后可以得到一颗决策树：</p><p><img src="/2022/06/10/AI/%E3%80%8A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%91%A8%E5%BF%97%E5%8D%8E/%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E5%86%B3%E7%AD%96%E6%A0%91%201b6c663806a843019cde9bb6d98c7ef5/Untitled%2010.png" alt="Untitled"></p><blockquote><p>注意：当使用了某个连续值属性之后，子树部分还是可以继续使用这个连续属性的。</p></blockquote><h2 id="4-4-2-缺失值处理"><a href="#4-4-2-缺失值处理" class="headerlink" title="4.4.2 缺失值处理"></a>4.4.2 缺失值处理</h2><p>现实中，往往会遇到需要某个属性缺失的情况，如果不使用这些数据，可能导致可用的数据不多。</p><p>C4.5算法的解决策略：</p><p>给定样本集D和属性a，先用没有缺失的子集合根据信息增益等方式挑选出最好的属性。再将缺失属性的样本划分到每一个子树，但是每一个样本有一个新的权重。（其实也就是以一个不同的概率进入不同的分支）</p><blockquote><p>举例：带缺失值的样本集合</p></blockquote><p><img src="/2022/06/10/AI/%E3%80%8A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%91%A8%E5%BF%97%E5%8D%8E/%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E5%86%B3%E7%AD%96%E6%A0%91%201b6c663806a843019cde9bb6d98c7ef5/Untitled%2011.png" alt="Untitled"></p><p>1、开始时，有17个样本，各个样本的权值为1。</p><p>以属性色泽为例：无缺失值的有14个样本，色泽取值为青绿、乌黑、浅白的样本子集的信息熵为1.0,0.918,0.0</p><p>则在无缺失值样本子集D’信息增益为：</p><p><img src="/2022/06/10/AI/%E3%80%8A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%91%A8%E5%BF%97%E5%8D%8E/%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E5%86%B3%E7%AD%96%E6%A0%91%201b6c663806a843019cde9bb6d98c7ef5/Untitled%2012.png" alt="Untitled"></p><p>样本集D上的信息增益为：</p><p><img src="/2022/06/10/AI/%E3%80%8A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%91%A8%E5%BF%97%E5%8D%8E/%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E5%86%B3%E7%AD%96%E6%A0%91%201b6c663806a843019cde9bb6d98c7ef5/Untitled%2013.png" alt="Untitled"></p><p>类似的也可以计算出其他属性的信息增益：</p><p><img src="/2022/06/10/AI/%E3%80%8A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%91%A8%E5%BF%97%E5%8D%8E/%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E5%86%B3%E7%AD%96%E6%A0%91%201b6c663806a843019cde9bb6d98c7ef5/Untitled%2014.png" alt="Untitled"></p><p>纹理的信息增益最大，所以选择纹理进行划分。</p><p>对于编号8的样本在属性“纹理”上出现了缺失值，将同时进入三个分支，但是权值不一样，即7/15,5/15,3/15。递归生成：</p><p><img src="/2022/06/10/AI/%E3%80%8A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%91%A8%E5%BF%97%E5%8D%8E/%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E5%86%B3%E7%AD%96%E6%A0%91%201b6c663806a843019cde9bb6d98c7ef5/Untitled%2015.png" alt="Untitled"></p><h1 id="4-5-多变量决策树"><a href="#4-5-多变量决策树" class="headerlink" title="4.5 多变量决策树"></a>4.5 多变量决策树</h1><p>如果把每一个属性看作是一个坐标轴，那么样本分类意味着，在坐标空间中每次寻找一个轴，在这个轴上选择与其他轴平行的分类边界。这个每一段都是与坐标轴平行的，具有较好的可解释性，现实中分类边界比较复杂时，需要比较多次的判断，如下图：</p><p><img src="/2022/06/10/AI/%E3%80%8A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%91%A8%E5%BF%97%E5%8D%8E/%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E5%86%B3%E7%AD%96%E6%A0%91%201b6c663806a843019cde9bb6d98c7ef5/Untitled%2016.png" alt="Untitled"></p><p>决策树需要经过多次的测试，开销大。</p><p>如果能够使用斜的分界面，那么模型将会大为简化。<code>“多变量决策树”</code>就是干这么一件事。</p><p>此类决策树中非叶子节点不再是针对某个属性，而是对属性的线性组合进行测试。与单变量不同，这里不是要得到一个最优划分属性，而是试图建立一个合适的线性分类器。如下图所示：</p><p><img src="/2022/06/10/AI/%E3%80%8A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%91%A8%E5%BF%97%E5%8D%8E/%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E5%86%B3%E7%AD%96%E6%A0%91%201b6c663806a843019cde9bb6d98c7ef5/Untitled%2017.png" alt="Untitled"></p>]]></content>
      
      
      <categories>
          
          <category> AI </category>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 《机器学习》周志华 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《机器学习》 第三章 线性模型</title>
      <link href="/2022/05/29/AI/%E3%80%8A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%91%A8%E5%BF%97%E5%8D%8E/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B%2089a45d87f303413e8112782de2e9e930/"/>
      <url>/2022/05/29/AI/%E3%80%8A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%91%A8%E5%BF%97%E5%8D%8E/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B%2089a45d87f303413e8112782de2e9e930/</url>
      
        <content type="html"><![CDATA[<h1 id="第三章-线性模型"><a href="#第三章-线性模型" class="headerlink" title="第三章 线性模型"></a>第三章 线性模型</h1><p><img src="/2022/05/29/AI/%E3%80%8A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%91%A8%E5%BF%97%E5%8D%8E/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B%2089a45d87f303413e8112782de2e9e930/Untitled.jpeg" alt="Untitled"></p><h1 id="3-1-基本形式"><a href="#3-1-基本形式" class="headerlink" title="3.1 基本形式"></a>3.1 基本形式</h1><p>给定一个d维的描述示例的向量（特征）</p><script type="math/tex; mode=display">\begin{align}\vec{x} = \left ( x_1; x_2; \cdots ; x_d \right )\end{align}</script><p>线性模型试图通过学得一个通过属性的线性组合来进行预测的函数</p><script type="math/tex; mode=display">\begin{align} f(x) &= w_1 x_1 + w_2x_2 + \cdots + w_d x_d + b \\f(x)&= w^T x + b \end{align}</script><p>w和b学习得到之后，模型就确定了。</p><ul><li><p><strong>优点：</strong></p><p>  1）简单、易于建模<br>  2）可引入层级结构或者高维映射使其变为更强大的非线性模型<br>  3）可解释性：最终的输出结果可以看作是不同属性的权重叠加</p></li></ul><blockquote><p>本章下文逻辑：<br>先从回归任务开始（线性），然后讨论二分类（对数几率回归、线性判别分析）和多分类任务。</p></blockquote><h1 id="3-2-线性回归"><a href="#3-2-线性回归" class="headerlink" title="3.2 线性回归"></a>3.2 线性回归</h1><blockquote><p>要解决的问题：</p></blockquote><p>给定一个数据集D包含很多样本，每个样本包含多个属性，通过学习得到一个线性模型预测真实的输出标记。</p><blockquote><p>离散属性如何表示？<br>1）若属性值之间<code>存在“序”</code>关系，可以通过连续化将其转化成为<code>连续值</code>。如高和矮可以量化为1和0。<br>2）若离散属性<code>不存在“序”</code>的关系，如果有k个属性值，通常转换成<code>k维向量</code></p></blockquote><h2 id="3-2-1-一元线性回归分析"><a href="#3-2-1-一元线性回归分析" class="headerlink" title="3.2.1 一元线性回归分析"></a>3.2.1 一元线性回归分析</h2><p>如何确定这个w和b呢？</p><p>均方误差通常是回归任务中常用的性能度量，因此我们可以让均方误差最小化，即</p><script type="math/tex; mode=display">\begin{align} (w^*,b^*)&=\mathop{\arg \min} \limits_{(w,b)}\sum_{i=1}^{m}{(f(x_i)-y_i)^2} \\&=\mathop{\arg\min}\limits_{(w,b)}\sum_{i=1}^{m}{(y_i-wx_i-b)^2}\end{align}</script><p>均方误差有很好的几何意义，对应了常用的<code>欧氏距离</code>，基于均方误差最小化来进行模型求解的方法称为<code>“最小二乘法”</code>，在线性回归中，最小二乘法就是找到一条直线，使得所有样本到直线上的欧氏距离最小。</p><p>求解的w和b过程就是使得上式最小化，求导即可：</p><script type="math/tex; mode=display">\begin{align}\frac{\partial E_{(w,b)}}{\partial w} &= 2\left( w \sum_{i=1}^{m}{x_i^2} - \sum_{i=1}^{m}{(y_i - b)x_i}\right) \\\frac{\partial E_{(w,b)}}{\partial w} &= 2\left( mb- \sum_{i=1}^{m}{(y_i - wx_i)} \right)\end{align}</script><blockquote><p>到这一步是拆开平方项，求偏导即可</p></blockquote><p>令上式等于0即可得到w和b的最优解的闭式解：</p><script type="math/tex; mode=display">\begin{align}\hat{w} &= \frac{\sum_{i=1}^{m}{y_i(x_i-\bar x)}}{\sum_{i=1}^{m}{\left(x_i - \bar{x} \right) ^2} } \\\hat{b} &= \bar{y} - \hat{\beta} \bar{x}\end{align}</script><blockquote><p>上述公式推导在<code>《数理统计》</code>课程中也会有详细推导</p></blockquote><h2 id="3-2-2-多元线性回归分析"><a href="#3-2-2-多元线性回归分析" class="headerlink" title="3.2.2 多元线性回归分析"></a>3.2.2 多元线性回归分析</h2><p>类似的，也可以用最小二乘法对w和b进行估计。为了方便讨论，会把w和b吸收成向量形式。</p><script type="math/tex; mode=display">\begin{align} \hat{w} &= \{ w_1,w_2,…,w_d,b \} \\\end{align}</script><p>样本特征增加一个维度，常量1，如下所示：</p><script type="math/tex; mode=display">\begin{align} X &= \begin{pmatrix}x_{11} & x_{12} & … & x_{1d} & 1\\ x_{21} & x_{22} & … & x_{2d} & 1\\\cdots & \cdots & \ddots & \cdots &\cdots \\x_{m1} & x_{m2} & … & x_{md} & 1\\\end{pmatrix} \end{align}</script><p>再把标签也写成向量形式，类似于w。有：</p><script type="math/tex; mode=display">\begin{align} \hat{w}^* = \mathop{\arg \min} \limits_{\hat{w}} {(y-X \hat w)^T(y-X\hat w)}\end{align}</script><p>求偏导得：</p><script type="math/tex; mode=display">\begin{align} \frac{\partial E_{\hat w}}{\partial \hat w} &= 2 X^T \left(X {\hat w} - y \right)\end{align}</script><blockquote><p>由于涉及到矩阵逆的运算，会比较复杂。下面简单讨论：</p></blockquote><p>1、如果 $X^TX$ 是<code>满秩矩阵</code>或<code>正定矩阵</code> ，令上式为0，可得：</p><script type="math/tex; mode=display">\begin{align} \hat{w}^* = (X^TX)^{-1}X^Ty\end{align}</script><blockquote><p>这个式子也比较常见哦</p></blockquote><p>2、往往<code>不是可逆矩阵</code>。比如变量超过样本数，不满秩，可以有<code>多个解</code>，均能使均方误差最小化。如何选择一个输出呢？常见的做法是引入正则化，约束w的大小。</p><h2 id="3-2-3-扩展"><a href="#3-2-3-扩展" class="headerlink" title="3.2.3 扩展"></a>3.2.3 扩展</h2><p>线性回归模型虽然简单，但是可以有丰富的变化。</p><p>对于原始的模型，我们可以让模型的预测接近于y的衍生物。我们可以假设输出标记是在对数尺度上变化，那么就可以将对数作为线性模型的逼近的目标，即</p><blockquote><p>这个特性很重要</p></blockquote><script type="math/tex; mode=display">\begin{align} \ln y = w^T x + b\end{align}</script><p>这就成为了<code>“对数线性回归”</code>，实际上让 $e^{w^Tx+b}$逼近于y。</p><p>更一般地，可以取单调可微函数g，使得：</p><script type="math/tex; mode=display">\begin{align} y=g^{-1}(w^Tx+b)\end{align}</script><p>这样的模型称之为<code>“广义线性模型”</code>，函数g称为联系函数。</p><h1 id="3-3-对数几率回归"><a href="#3-3-对数几率回归" class="headerlink" title="3.3 对数几率回归"></a>3.3 对数几率回归</h1><blockquote><p>上一节讨论的是回归，这一节讨论的则是分类。<br>答案蕴含在“广义线性模型中”：找一个单调可微函数，将线性回归的预测值与类别标记y联系起来。</p></blockquote><p>考虑二分类任务输出为0,1，而回归任务的输出为实数值，所以需要将 实数值转换成 0/1。</p><p>理想的方法是单位阶跃函数，但是单位阶跃函数不连续，不能用。所以需要找一个近似的函数，即<code>对数几率函数</code>：</p><script type="math/tex; mode=display">\begin{align} y= \frac{1}{1+e^{-z}}\end{align}</script><p><img src="/2022/05/29/AI/%E3%80%8A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%91%A8%E5%BF%97%E5%8D%8E/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B%2089a45d87f303413e8112782de2e9e930/Untitled.png" alt="Untitled"></p><h2 id="3-3-1-对数几率回归（logistics-regression-logit-regression）"><a href="#3-3-1-对数几率回归（logistics-regression-logit-regression）" class="headerlink" title="3.3.1 对数几率回归（logistics regression, logit regression）"></a>3.3.1 对数几率回归（logistics regression, logit regression）</h2><p>对数几率是一种“Sigmod函数”，将z值转换成为0/1的y值。将z代入得到：</p><script type="math/tex; mode=display">\begin{align} y= \frac{1}{1+e^{-(w^Tx+b)}}\end{align}</script><p>可以变化为：</p><script type="math/tex; mode=display">\begin{align} \ln \frac{y}{1-y}=w^Tx+b\end{align}</script><p>将y看作是预测为正例的可能性，1-y为反例的可能性，那么两者的比值$\frac{y}{1-y}$称为<code>“几率”</code>，取对数$\ln \frac{y}{1-y}$，可以得到<code>“对数几率”（称log odds, logit）</code>。</p><p>因此，模型被称作是“对数几率回归”。虽然名字是回归，但是实际上是分类算法。</p><blockquote><p>优点：<br>1）对分类可能性直接建模，无需事先假设数据分布。<br>2）不仅仅预测类别，还可以获得预测的可能性，对概论决策任务很有用。<br>3）目标函数任意阶可导的凸函数。</p></blockquote><h2 id="3-3-2-对数回归求解（略）"><a href="#3-3-2-对数回归求解（略）" class="headerlink" title="3.3.2 对数回归求解（略）"></a>3.3.2 对数回归求解（略）</h2><blockquote><p>通过“最大似然法”估计参数，梯度下降法得到最优解</p></blockquote><h1 id="3-4-线性判别分析LDA"><a href="#3-4-线性判别分析LDA" class="headerlink" title="3.4 线性判别分析LDA"></a>3.4 线性判别分析LDA</h1><p>LDA的思想：<br>给定训练样本集合，将样本投影到一条直线上，使得同类样本尽可能近，不同类样本投影尽可能远；新样本来时，将其投影到同样的这条直线上，根据投影的位置来确定新样本的类别。</p><p>如下图所示：</p><p><img src="/2022/05/29/AI/%E3%80%8A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%91%A8%E5%BF%97%E5%8D%8E/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B%2089a45d87f303413e8112782de2e9e930/Untitled%201.png" alt="Untitled"></p><h2 id="3-4-1-目标函数理论推导"><a href="#3-4-1-目标函数理论推导" class="headerlink" title="3.4.1 目标函数理论推导"></a>3.4.1 目标函数理论推导</h2><p>给定数据集D，假设$X_i,\mu_i,\Sigma_i$分别为第i类的样本，均值向量、协方差矩阵。</p><p>将数据投影到直线$w$上，则两类<code>样本的中心</code>在直线上的投影为$w^T \mu_0和w^T \mu_1$；若将所有样本都投影到直线上，两类样本的<code>协方差</code>分别为$w^T \Sigma_0w和w_T \Sigma_1w$。</p><p>想要同类投影点尽可能近，可以让协方差尽可能小，即$w^T \Sigma_0w+w_T \Sigma_1w$尽可能小。不同类尽可能远离，可以让类中心距离尽可能大，即$\vert\vert w^T\mu_0-w^T\mu_1 \vert\vert_2^2$尽可能大。</p><p>同时考虑两者，那么<code>目标</code>为：</p><script type="math/tex; mode=display">\begin{align} J &= \frac{\vert\vert w^T\mu_0-w^T\mu_1 \vert\vert_2^2}{w^T \Sigma_0w+w_T \Sigma_1w} \\&= \frac{w^T (\mu_0-\mu_1)^T(\mu_0-\mu_1)w}{w^T (\Sigma_0+\Sigma_1)w}\end{align}</script><blockquote><p>进一步化简：</p></blockquote><p>定义：<code>类内散度矩阵</code></p><script type="math/tex; mode=display">\begin{align} S_w &= \Sigma_0+\Sigma_1 \\&= \sum_{x \in X_0}{(x-\mu_1)(x-\mu_0)^T} +\sum_{x \in X_1}{(x-\mu_1)(x-\mu_1)^T}\end{align}</script><p><code>类间散度矩阵</code></p><script type="math/tex; mode=display">\begin{align} S_b = (\mu_0-\mu_1)(\mu_0-\mu_1)^T\end{align}</script><p>则J可以重写为：</p><script type="math/tex; mode=display">\begin{align} J &= \frac{w^T S_b w}{w^T S_w w}\end{align}</script><p>这就是LDA最大化的目标，广义瑞利商。</p><h2 id="3-4-2-求解（略）"><a href="#3-4-2-求解（略）" class="headerlink" title="3.4.2 求解（略）"></a>3.4.2 求解（略）</h2><blockquote><p>拉格朗日乘子法<br>最终结果为：</p><script type="math/tex; mode=display">\begin{align} w=S_w^{-1}(\mu_0-\mu_1)\end{align}</script></blockquote><h1 id="3-5-多分类学习"><a href="#3-5-多分类学习" class="headerlink" title="3.5 多分类学习"></a>3.5 多分类学习</h1><p>有些二分类算法可以直接推广到多分类算法，但是更多情况下是基于这些基本策略，利用二分类学习器来解决多分类问题。</p><h2 id="3-5-1-三种策略"><a href="#3-5-1-三种策略" class="headerlink" title="3.5.1 三种策略"></a>3.5.1 三种策略</h2><p>1、<code>一对一 OvO</code></p><p>将N个类别两两配对，产生N(N-1)/2个 分类器和结果，最终结果投票产生。</p><p>2、<code>一对其余 OvR</code></p><p>一个类作为正例，其他类别作为反例，训练N个分类器。如果预测是仅有一个分类器预测为正例，那么就作为最终结果；如果有多个类，则根据置信度来判断。</p><blockquote><p>对比：<br>OvO的<code>存储开销</code>和<code>测试时间</code>开销大，<br>OvR在训练时每个分类器均使用全部训练样例，因此<code>训练时间</code>开销大。</p></blockquote><p>3、<code>多对多 MvM</code></p><p>取若干类为正类，若干类为反类，但是要有独特的设计，不能随意选取。</p><p>介绍一种常用的技术：<code>“纠错输出码”，ECOC</code></p><h2 id="3-5-2-纠错输出码ECOC"><a href="#3-5-2-纠错输出码ECOC" class="headerlink" title="3.5.2 纠错输出码ECOC"></a>3.5.2 纠错输出码ECOC</h2><ul><li>编码：对N个类做M次划分，一部分作为正类，一部分作为反类，从而形成一个二分类训练集；这样有M个训练集和分类器</li><li>解码：对M个分类器分别进行测试，将测试结果组成一个编码。将这个预测编码和每个类别各自的编码进行比较，其中距离最小的作为最终结果。</li></ul><p>常见的类别划分有二元码或三元码。三元码多了一个停用类。</p><p><img src="/2022/05/29/AI/%E3%80%8A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%91%A8%E5%BF%97%E5%8D%8E/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B%2089a45d87f303413e8112782de2e9e930/Untitled%202.png" alt="Untitled"></p><blockquote><p>为什么称作是“纠错输出码”呢？<br>因为该编码对分类器的错误有一定的容忍和修正能力。某个结果错了，仍然可以得到正确的结果。</p><ul><li>对于同一个任务，编码越长纠错能力越强；但是计算、存储开销也会增大；组合有限时，增长也会变得没有意义。</li><li>同等长度的编码，任意两个类别之间的距离越远，则纠错能力越强。但是当编码变长时，难以有效确定最优编码。</li></ul></blockquote><h1 id="3-6-类别不平衡问题"><a href="#3-6-类别不平衡问题" class="headerlink" title="3.6 类别不平衡问题"></a>3.6 类别不平衡问题</h1><blockquote><p>前面的内容都有一个基本的假设，即不同类别的训练样本的数目基本相当。</p></blockquote><p><code>类别不平衡</code>是指：不同类别的训练样本数目差距很大的情况。</p><p>几率$\frac{y}{1-y}$反映了正例可能性和反例可能性的比值，阈值0.5表明分类器认为正反例可能性相同，因此当$\frac{y}{1-y}&gt;1$时，预测为正例。</p><p>当正反例数目不同时，观测几率为：$\frac {m^+}{m^-}$，那么只要分类器预测几率高于观测几率即可判断为正例，即</p><script type="math/tex; mode=display">\begin{align} \frac{y}{1-y}&>\frac{m^+}{m^-} \\\frac{y'}{1-y'}&=\frac{y}{1-y}\times \frac{m^+}{m^-}\end{align}</script><p>这就是一个基本策略：<code>“再缩放”（rescaling）</code></p><blockquote><p>上述操作简单，但是实际操作不平凡。</p></blockquote><p>现在的技术上大体分成三类：</p><ul><li>1、对训练集里的负样本<code>“欠采样”（undersampling）</code></li></ul><p>欠采样时间开销小，代表性算法是：<code>EasyEnsemble</code></p><ul><li>2、对正样本<code>“过采样”（oversampling）</code></li></ul><p>不能简单重复采样，不然会严重过拟合。代表性算法是<code>SMOTE</code>：通过插值获得新样本。</p><ul><li>3、在原训练集直接训练，预测过程中试用上述<code>再缩放</code>策略。</li></ul><p><img src="/2022/05/29/AI/%E3%80%8A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%91%A8%E5%BF%97%E5%8D%8E/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B%2089a45d87f303413e8112782de2e9e930/Untitled%201.jpeg" alt="Untitled"></p>]]></content>
      
      
      <categories>
          
          <category> AI </category>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 《机器学习》周志华 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《机器学习》 第二章 模型的评估与选择</title>
      <link href="/2022/05/26/AI/%E3%80%8A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%91%A8%E5%BF%97%E5%8D%8E/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E6%A8%A1%E5%9E%8B%E7%9A%84%E8%AF%84%E4%BC%B0%E4%B8%8E%E9%80%89%E6%8B%A9%203551668d792a4de7b4b497e84f4b341d/"/>
      <url>/2022/05/26/AI/%E3%80%8A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%91%A8%E5%BF%97%E5%8D%8E/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E6%A8%A1%E5%9E%8B%E7%9A%84%E8%AF%84%E4%BC%B0%E4%B8%8E%E9%80%89%E6%8B%A9%203551668d792a4de7b4b497e84f4b341d/</url>
      
        <content type="html"><![CDATA[<h1 id="第二章-模型的评估与选择"><a href="#第二章-模型的评估与选择" class="headerlink" title="第二章 模型的评估与选择"></a>第二章 模型的评估与选择</h1><p><img src="/2022/05/26/AI/%E3%80%8A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%91%A8%E5%BF%97%E5%8D%8E/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E6%A8%A1%E5%9E%8B%E7%9A%84%E8%AF%84%E4%BC%B0%E4%B8%8E%E9%80%89%E6%8B%A9%203551668d792a4de7b4b497e84f4b341d/Untitled.jpeg" alt="Untitled"></p><h1 id="2-1-经验误差和过拟合"><a href="#2-1-经验误差和过拟合" class="headerlink" title="2.1 经验误差和过拟合"></a>2.1 经验误差和过拟合</h1><h2 id="2-1-1-经验误差和泛化误差"><a href="#2-1-1-经验误差和泛化误差" class="headerlink" title="2.1.1 经验误差和泛化误差"></a>2.1.1 经验误差和泛化误差</h2><ul><li><p>错误率</p><p>  分类错误的样本数占样本总数的比例</p></li><li><p>精度（accuracy）</p><p>  精度=1-错误率</p></li><li><p>误差</p><p>  学习器的实际预测输出和样本的真是输出之间的差异</p></li><li><p>训练误差/经验误差</p><p>  学习器在训练集上的误差</p></li><li><p>泛化误差</p><p>  在新样本上的误差</p></li></ul><blockquote><p>实际上，我们能做的就是使<strong>训练误差</strong>最小化</p></blockquote><h2 id="2-1-2-过拟合和欠拟合"><a href="#2-1-2-过拟合和欠拟合" class="headerlink" title="2.1.2 过拟合和欠拟合"></a>2.1.2 过拟合和欠拟合</h2><blockquote><p>但是，我们想要的是，在新样本上表现好</p><ul><li>过拟合</li></ul></blockquote><pre><code>由于在训练集上学习器已经把样本学得“太好了”，很可能会把训练样本自身的一些特点当做所有潜在样本都具有的一般性质，这样就会导致泛化性能下降</code></pre><ul><li><p>欠拟合</p><p>  对训练样本的一般性质尚未学好</p></li></ul><p>欠拟合通常是由于学习能力过于低下导致的，容易避免。</p><p>克服方法：如换更复杂的模型，增加训练轮数等</p><p>过拟合常见的是学习能力过于强大，把不太一般的特性都学习到了。</p><p>克服较难：关键障碍。无法彻底避免，只能缓解</p><p><img src="/2022/05/26/AI/%E3%80%8A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%91%A8%E5%BF%97%E5%8D%8E/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E6%A8%A1%E5%9E%8B%E7%9A%84%E8%AF%84%E4%BC%B0%E4%B8%8E%E9%80%89%E6%8B%A9%203551668d792a4de7b4b497e84f4b341d/Untitled.png" alt="Untitled"></p><h1 id="2-2-评估方法"><a href="#2-2-评估方法" class="headerlink" title="2.2 评估方法"></a>2.2 评估方法</h1><blockquote><p>通常来说会有多种算法可以选择，理想的方案是根据泛化误差进行评估，找到泛化误差最小的那个<br>但是我们无法直接获得泛化误差，而训练误差又可能存在过拟合，那么该如何选择？</p></blockquote><p>通常，我们可以通过实验测试来对泛化误差进行评估。<br>具体来说就是设置一个“测试集”，来测试学习器对新样本的判别能力，以“测试误差”作为泛化误差的近似。</p><blockquote></blockquote><p>通常我们假设测试样本也是从样本的真是分布中采集得到；同时还要尽可能与训练集<strong>互斥</strong>。</p><blockquote><p>如果训练样本出现在测试集中，就有可能得到过于“乐观”的结果。</p></blockquote><p>现在我们有一个训练集，既要训练又要测试，如何做呢？</p><p>答案是对D进行适当的处理，从中产生<strong>训练集S和测试集T</strong>。下面介绍几种常见的做法：</p><h2 id="2-2-1-留出法"><a href="#2-2-1-留出法" class="headerlink" title="2.2.1 留出法"></a>2.2.1 留出法</h2><p>直接将数据集划分为两个<strong>互斥</strong>的集合。</p><p>划分时要尽可能保持数据分布的一致性，避免因为划分引入额外的<strong>偏差</strong>而对最终结果造成影响。所以一般采用“<strong>分层抽样</strong>”的方式保留类别比例。</p><blockquote><p>尽管给定两个集合相同的样本比例，仍然存在多种划分方式对原始数据集进行分割。<br>单次使用留出法结果往往不够稳定可靠，一般采用若干次随机划分、重复试验后<strong>取平均</strong>。</p><p>窘境：<br>1、如果训练集S包含绝大多数样本，训练出来的模型可能接近于用D训练的，但是测试集T比较小，评估结果可能不够可靠<br>2、如果T的样本多一些，训练集S和D的差别更大了，降低了评估结果的保真性。<br>做法：（没有完美解决方案）<br>2/3~4/5作为训练集</p></blockquote><h2 id="2-2-2-交叉验证法"><a href="#2-2-2-交叉验证法" class="headerlink" title="2.2.2 交叉验证法"></a>2.2.2 交叉验证法</h2><p>先将数据集划分为k个大小相似的互斥子集（尽可能保持数据分布的一致性，即从数据集D中分层采样得到）。每次用k-1个子集的并集作为训练集，余下的子集作为测试集，从而进行k次训练和测试，最终返回k个测试结果的均值。</p><p>这被称作“k折交叉验证”，k最常用的取值是10。</p><p><img src="/2022/05/26/AI/%E3%80%8A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%91%A8%E5%BF%97%E5%8D%8E/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E6%A8%A1%E5%9E%8B%E7%9A%84%E8%AF%84%E4%BC%B0%E4%B8%8E%E9%80%89%E6%8B%A9%203551668d792a4de7b4b497e84f4b341d/Untitled%201.png" alt="Untitled"></p><blockquote><p>交叉验证法也可能由于不同的划分而有所差别，所以也要划分p次，最终评估结果是p次k折交叉验证的均值。如“10次10折交叉验证”</p></blockquote><h2 id="2-2-3-留一法（LOO）"><a href="#2-2-3-留一法（LOO）" class="headerlink" title="2.2.3 留一法（LOO）"></a>2.2.3 留一法（LOO）</h2><p>m个样本划分为m个子集——每个子集包含一个样本。 </p><blockquote><p>是交叉验证法的一个特例</p></blockquote><p>训练集与D极为相似，所以评估结果比较准确。</p><p>但在数据集较大时，计算开销很大（多少个样本就要计算多少个模型）。</p><h2 id="2-2-4-自助法"><a href="#2-2-4-自助法" class="headerlink" title="2.2.4 自助法"></a>2.2.4 自助法</h2><p>以“自助采样法”为基础，大致做法，从D中采用一个样本，采样完放回D，采样次数和原始数据集规模一致。这样就有可能有的样本被采样多次，有的没有被采样到，没有被采样到的就可以作为测试集。</p><script type="math/tex; mode=display">\lim_{m \to \infty} \left( 1- \frac{1}{m} \right) ^m  \to \frac {1}{e} \approx 0.368</script><blockquote><p>优势：<br>自助法在训练集较小时、难以有效划分训练集、测试集时很有用；<br>劣势：<br>改变了初始数据集的分布，可能引入“偏差”</p></blockquote><p>所以，当数据集足够时，通常采用留出法和交叉验证法。</p><blockquote></blockquote><h2 id="2-2-5-调参与最终模型"><a href="#2-2-5-调参与最终模型" class="headerlink" title="2.2.5 调参与最终模型"></a>2.2.5 调参与最终模型</h2><blockquote><p>大多数模型需要设定参数，不同的参数性能往往有巨大的差别</p></blockquote><p>调参和算法选择没有本质差别，每种参数配置训练一个模型，挑选最好的模型作为结果。</p><p>在调参的过程中，每个参数通常是个实数或者范围很大，因此我们需要设定步长，在性能和计算开销中折中。</p><p><strong>验证集：</strong><br>模型评估与选择中用于评估测试的数据集。（同一算法不同模型对比，也就是训练过程中）</p><p><strong>测试集：</strong><br>对比不同算法的泛化性能。（不同算法对比）</p><h1 id="2-3-性能度量"><a href="#2-3-性能度量" class="headerlink" title="2.3 性能度量"></a>2.3 性能度量</h1><p>对学习器的泛化性能进行评估不仅需要有效的评估方法，还需要衡量泛化能力的评估标准，就是<strong>性能度量</strong></p><p><strong>回归任务</strong>最常见的性能度量就是“均方误差”（mean squared error，MSE）</p><script type="math/tex; mode=display">E(f;D)= \frac{1}{m} \sum_{i=1}^{m} {(f(x_i)-y_i)^2}</script><p>下面介绍<strong>分类任务</strong>中常见的性能度量。</p><h2 id="2-3-1-错误率和精度"><a href="#2-3-1-错误率和精度" class="headerlink" title="2.3.1 错误率和精度"></a>2.3.1 错误率和精度</h2><p>本章开头提出的错误率和精度，是分类任务中最常用的两种性能度量，既适用于二分类，也适用于多分类。</p><p><strong>错误率</strong>：分类错误的样本总数占样本总数的百分比</p><script type="math/tex; mode=display">E(f;D)= \frac{1}{m} \sum_{i=1}^{m} {\phi(f(x_i)\neq y_i)}</script><p><strong>精度</strong>：是分类正确的样本数占的百分比</p><script type="math/tex; mode=display">acc(f;D)=1-E(f;D)= \frac{1}{m} \sum_{i=1}^{m} {\phi(f(x_i)= y_i)}</script><h2 id="2-3-2-查准率、查全率与F1"><a href="#2-3-2-查准率、查全率与F1" class="headerlink" title="2.3.2 查准率、查全率与F1"></a>2.3.2 查准率、查全率与F1</h2><blockquote><p>光有错误率和精度不能满足所有要求。比如拉来一车西瓜，我们通常想要知道的是：经过判别器判别之后，“挑出来的瓜中真正有多少好瓜”，或者“所有的好瓜中有多少被挑选出来了”</p></blockquote><p>对于二分类问题，可以根据真实类别和学习器预测的类别进行组合划分：真正例（true positive）、假正例（false positive）、真反例（true negative）、假反例（false negative）。</p><p>TP+FP+TN+FN=ALL。混淆矩阵如下：</p><div class="table-container"><table><thead><tr><th></th><th>预测结果</th><th>预测结果</th></tr></thead><tbody><tr><td>真实情况</td><td>正例</td><td>反例</td></tr><tr><td>正例</td><td>TP（真正例）</td><td>FN（假反例）</td></tr><tr><td>反例</td><td>FP（假正例）</td><td>TN（真反例）</td></tr></tbody></table></div><h3 id="1、查准率（precision）"><a href="#1、查准率（precision）" class="headerlink" title="1、查准率（precision）"></a>1、查准率（precision）</h3><p>就是预测为正例的那一列数据中真正的正例的百分比</p><script type="math/tex; mode=display">P= \frac{TP}{TP+FP}</script><h3 id="2、查全率（recall）"><a href="#2、查全率（recall）" class="headerlink" title="2、查全率（recall）"></a>2、查全率（recall）</h3><p>真实为正例的那一行数据中预测为正例的百分比</p><script type="math/tex; mode=display">R = \frac{TP}{TP+FN}</script><blockquote><p>查准率和查全率通常是一对矛盾的度量。一个高另一个往往比较低。<br>举例：<br>如果希望好瓜尽可能挑选出来，那么可以把所有西瓜都选上，但是查准率会比较低；如果希望好瓜比例尽可能高，那么只需要选择把握最高的瓜，那样查全率又会比较低。</p></blockquote><h3 id="3、P-R图"><a href="#3、P-R图" class="headerlink" title="3、P-R图"></a>3、P-R图</h3><p>学习器把预测结果对样例进行排序，概率高的在前面，逐个把样例看作是正例，每次可以计算出当前的查全率、查准率。</p><p>以查准率为纵轴、查全率为横轴作图，就叫做 “P-R图”</p><p><img src="/2022/05/26/AI/%E3%80%8A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%91%A8%E5%BF%97%E5%8D%8E/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E6%A8%A1%E5%9E%8B%E7%9A%84%E8%AF%84%E4%BC%B0%E4%B8%8E%E9%80%89%E6%8B%A9%203551668d792a4de7b4b497e84f4b341d/Untitled%202.png" alt="Untitled"></p><blockquote><p>P-R图能够整体上反映查全率、查准率。</p></blockquote><p>性能比较：</p><p>1）完全包住：面积大的性能优。<br>2）有交叉时：使用平衡点（BEP）度量，利用平衡点对应的查全率进行比较。</p><h3 id="4、F1"><a href="#4、F1" class="headerlink" title="4、F1"></a>4、F1</h3><p>F1度量：根据对查准率和查全率的而重视程度不同而用的度量方法。</p><script type="math/tex; mode=display">F1 = \frac{2 \times P \times R}{P + R}</script><blockquote><p>当有多个二分类矩阵，希望估计全局最优或者是执行多分类任务时每两两类别对应一个混淆矩阵。</p></blockquote><h3 id="5、宏平均和微平均"><a href="#5、宏平均和微平均" class="headerlink" title="5、宏平均和微平均"></a>5、宏平均和微平均</h3><blockquote><p>宏平均的做法是在各个混淆矩阵上分别计算查准率和查全率、F1，再计算平均值<br>微平均的做法是先对各个混淆矩阵的对应元素进行平均，再计算P、R、F1</p></blockquote><p>1）宏查准率（macro-P）：${macro-P} = \frac{1}{n} \sum_{i=1}^{n}{P_i}$</p><p>2）宏查准率（macro-R）：${macro-R} = \frac{1}{n} \sum_{i=1}^{n}{R_i}$</p><p>3）宏查准率（macro-F1）：${macro-F1} = \frac{1}{n} \sum_{i=1}^{n}{F1_i}$</p><p>4）微查准率（micro-P）：${micro-P} = \frac{\overline {TP}}{\overline {TP} + \overline {FP}}$ </p><p>5）微查准率（micro-P）：${micro-R} = \frac{\overline {TP}}{\overline {TP} + \overline {FN}}$ </p><p>6）微查准率（micro-P）：${micro-P} = \frac{2 \times micro-R \times micro-P}{micro-P + micro-R}$ </p><h2 id="2-3-3-ROC和AUC"><a href="#2-3-3-ROC和AUC" class="headerlink" title="2.3.3 ROC和AUC"></a>2.3.3 ROC和AUC</h2><h3 id="1、ROC曲线"><a href="#1、ROC曲线" class="headerlink" title="1、ROC曲线"></a>1、ROC曲线</h3><p>与P-R曲线不同，ROC曲线纵轴是“真正例率”（TPR），横轴是“假正例率”（FPR）</p><blockquote><p>对于表格，这两个指标是按行看，<br>TPR是第一行中（也就是所有真正正例样本），预测为正例的样本数的比例<br>FPR是第二行在（也就是所有真正反例样本），预测为正例样本数的比例</p></blockquote><p>就是正反例样本中预测为正例的比例。</p><blockquote></blockquote><script type="math/tex; mode=display">\begin{split} TPR= \frac{TP}{TP+FN} \\ FPR=\frac{FP}{TN+FP} \end{split}</script><p>ROC曲线的绘制：</p><p>根据学习器的预测结果进行排序，逐个将样本作为正例，每次计算出两个重要的值作为横纵坐标。</p><blockquote><p>如一开始把分类阈值设置为最大，即把所有样例分为反例，那么真、假正例率都是0；然后逐步调小阈值，也就是每次分一个正例样本。</p></blockquote><p>现实中的例子通常是有限的，曲线不是很平滑。</p><p><img src="/2022/05/26/AI/%E3%80%8A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%91%A8%E5%BF%97%E5%8D%8E/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E6%A8%A1%E5%9E%8B%E7%9A%84%E8%AF%84%E4%BC%B0%E4%B8%8E%E9%80%89%E6%8B%A9%203551668d792a4de7b4b497e84f4b341d/Untitled%203.png" alt="Untitled"></p><h3 id="2、AUC"><a href="#2、AUC" class="headerlink" title="2、AUC"></a>2、AUC</h3><p>如果ROC曲线包住另一个，可以说性能优秀。</p><p>如果有交叉，那么需要计算AUC（曲线下面积）判断。</p><h2 id="2-3-4-代价敏感错误率与代价曲线"><a href="#2-3-4-代价敏感错误率与代价曲线" class="headerlink" title="2.3.4 代价敏感错误率与代价曲线"></a>2.3.4 代价敏感错误率与代价曲线</h2><h3 id="1、代价敏感错误率"><a href="#1、代价敏感错误率" class="headerlink" title="1、代价敏感错误率"></a>1、代价敏感错误率</h3><p>不同的错误有不同的代价，计算求和即可</p><h3 id="2、代价曲线"><a href="#2、代价曲线" class="headerlink" title="2、代价曲线"></a>2、代价曲线</h3><p>由ROC曲线转换而来，$FNR=1-TPR$，由（FPR，TPR）计算FNR，然后绘制（0，FPR）到（1，FNR）的线段，取得所有线段的下界。</p><p><img src="/2022/05/26/AI/%E3%80%8A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%91%A8%E5%BF%97%E5%8D%8E/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E6%A8%A1%E5%9E%8B%E7%9A%84%E8%AF%84%E4%BC%B0%E4%B8%8E%E9%80%89%E6%8B%A9%203551668d792a4de7b4b497e84f4b341d/Untitled%204.png" alt="Untitled"></p><h1 id="2-4-比较检验（略）"><a href="#2-4-比较检验（略）" class="headerlink" title="2.4 比较检验（略）"></a>2.4 比较检验（略）</h1><h1 id="2-5-偏差和方差"><a href="#2-5-偏差和方差" class="headerlink" title="2.5 偏差和方差"></a>2.5 偏差和方差</h1><p><strong>泛化误差</strong><br>可分解为偏差、方差和噪声之和。</p><p><strong>偏差：</strong><br>期望输出与真实标签的偏离程度。刻画了学习算法本身的拟合能力。</p><p><strong>方差：</strong><br>同样大小的训练集的变动造成学习性能的变化。刻画了数据扰动所造成的影响。</p><p><strong>噪声：</strong><br>当前任务上任何学习算法所能达到的期望泛化误差的下界。刻画的学习本身的难度。</p><h3 id="偏差-方差窘境"><a href="#偏差-方差窘境" class="headerlink" title="偏差-方差窘境"></a><strong>偏差-方差窘境</strong></h3><p>一般来说，偏差和方差是有冲突的</p><p>1）训练不足：拟合能力不够，训练数据的扰动不足以使分类器性能发生显著变化，偏差占主导地位</p><p>2）训练加深：拟合能力增强，训练数据发生扰动逐渐能够被检测到，方差主导</p><p>3）训练充足：拟合能力已经非常强，训练数据发生扰动会导致分类器发生显著变化；若数据的自身特性被学习到，那么会发生过拟合。</p><p><img src="/2022/05/26/AI/%E3%80%8A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%91%A8%E5%BF%97%E5%8D%8E/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E6%A8%A1%E5%9E%8B%E7%9A%84%E8%AF%84%E4%BC%B0%E4%B8%8E%E9%80%89%E6%8B%A9%203551668d792a4de7b4b497e84f4b341d/Untitled%205.png" alt="Untitled"></p>]]></content>
      
      
      <categories>
          
          <category> AI </category>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 《机器学习》周志华 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《机器学习》周志华 第一章 绪论</title>
      <link href="/2022/05/25/AI/%E3%80%8A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%91%A8%E5%BF%97%E5%8D%8E/%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E7%BB%AA%E8%AE%BA%204c3f7b9232d6485f9b3c2cf6e620f5bd/"/>
      <url>/2022/05/25/AI/%E3%80%8A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%91%A8%E5%BF%97%E5%8D%8E/%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E7%BB%AA%E8%AE%BA%204c3f7b9232d6485f9b3c2cf6e620f5bd/</url>
      
        <content type="html"><![CDATA[<h1 id="第一章-绪论"><a href="#第一章-绪论" class="headerlink" title="第一章 绪论"></a>第一章 绪论</h1><p><img src="/2022/05/25/AI/%E3%80%8A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%91%A8%E5%BF%97%E5%8D%8E/%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E7%BB%AA%E8%AE%BA%204c3f7b9232d6485f9b3c2cf6e620f5bd/Untitled.jpeg" alt="Untitled"></p><h1 id="1-1-引言"><a href="#1-1-引言" class="headerlink" title="1.1 引言"></a>1.1 引言</h1><h1 id="1-2-基本术语"><a href="#1-2-基本术语" class="headerlink" title="1.2 基本术语"></a>1.2 基本术语</h1><ul><li><p>数据集</p><p>  样本的集合。每个样本可以是一个事件或对象的描述。</p></li><li><p>属性、特征</p><p>  反映事件或者对象某方面的表现或性质</p></li><li><p>属性空间、样本空间</p><p>  属性张成的空间，如果有三个属性，那么就是三维坐标系</p></li><li><p><strong>特征向量</strong></p><p>  每个样本都可以在样本空间中找到自己的坐标向量，长度称为维数</p></li><li><p>训练、学习</p><p>  从数据中学得模型。</p><p>  训练过程中试用的数据称为训练数据，每一个样本称为训练样本，训练样本组成的集合称为训练集</p></li><li><p>输出空间、标记空间</p><p>  预测的结果的集合</p></li></ul><h2 id="1-2-1-几个比较重要的概念"><a href="#1-2-1-几个比较重要的概念" class="headerlink" title="1.2.1 几个比较重要的概念"></a>1.2.1 几个比较重要的概念</h2><ul><li><p><strong>分类和回归</strong></p><p>  分类任务用于预测离散值</p><p>  回归任务用于预测连续值</p></li><li><p><strong>监督学习</strong>和<strong>无监督学习</strong></p><p>  训练数据是否拥有标记信息。</p><p>  其中分类和回归是监督学习的代表，聚类是无监督学习的代表。</p></li><li><p><strong>泛化能力</strong></p><p>  学习的模型适用于新样本的能力</p><blockquote><p>机器学习的目标是使得模型能够很好地适用于“新样本”，而不仅仅是训练样本</p></blockquote></li><li><p><strong>独立同分布</strong></p><p>  假设样本空间中全体样本服从一个未知“分布”，我们获得的每个样本都是独立地从这个分布上采样获得的</p></li></ul><h1 id="1-3-假设空间"><a href="#1-3-假设空间" class="headerlink" title="1.3 假设空间"></a>1.3 假设空间</h1><ul><li><p><strong>归纳与演绎</strong></p><p>  <strong>归纳</strong>：从具体事实中归结出一般性规律，从特殊到一般的“泛化”过程。</p><p>  <strong>演绎</strong>：从基础原理推演出具体状况，从一般到特殊的“特化”过程。</p></li><li><p><strong>归纳学习</strong></p><p>  “从样例从学习”显然是一个归纳的过程</p></li></ul><h1 id="1-4-归纳偏好"><a href="#1-4-归纳偏好" class="headerlink" title="1.4 归纳偏好"></a>1.4 归纳偏好</h1><ul><li><p>（归纳）<strong>偏好</strong></p><p>  机器学习算法在学习过程中对某种类型假设的偏好。</p></li><li><p><strong>奥卡姆剃刀</strong></p><p>  若有多个假设与观察一致，则选择最简单的那个。</p></li><li><p><strong>NFL定理（天下没有免费的午餐）</strong></p><blockquote><p>脱离具体的问题，空谈什么算法最好没有意义。</p></blockquote><p>  在考虑所有潜在的问题时的期望值都相同。</p></li></ul><h1 id="1-5-发展历程"><a href="#1-5-发展历程" class="headerlink" title="1.5 发展历程"></a>1.5 发展历程</h1><p>二十世纪五十年代到七十年代初期，处于推理期。</p><p>赋予机器人推理能力，“逻辑推理家”程序出现。但是慢慢发现仅有推理能力实现不了人工智能。</p><p>七十年代中期开始，进入了知识期。</p><p>大量专家系统开始问世，但是后来专家们希望机器能够自己学习知识多好。</p><p>八十年代，“从样例中学习”（广义归纳学习），研究最多，应用最广。</p><blockquote><p>涵盖了监督学习和无监督学习，也是本书的主要内容</p></blockquote><p>这一时期的一大主流是符号主义学习，包括决策树和基于逻辑的学习（ILP）。</p><p>九十年代中期以前，另一主流技术是基于神经网络的连结主义学习。</p><blockquote><p>其实连结主义在五十年代中后期就已经取得了大发展，但是由于许多人工智能学者偏爱符号主义。当时也有巨大问题，连异或问题无法处理</p></blockquote><p>1986年发明了BP算法，产生了深远影响。</p><p>局限性：连结主义是黑箱模型。最大的是试错性，学习过程涉及大量参数，参数的设置也缺乏理论指导，主要靠手工调参。</p><p>九十年代中期，“统计学习”闪亮登场占据主流，代表技术是支持向量机，以及更为一般的核方法。</p><p>二十一世纪初，连接主义卷土重来。由于数据规模大了，计算能力变强了。</p><p>虽然缺乏严格的理论指导，但是降低了机器学习应用者的门槛。</p><h1 id="1-6-应用现状"><a href="#1-6-应用现状" class="headerlink" title="1.6 应用现状"></a>1.6 应用现状</h1>]]></content>
      
      
      <categories>
          
          <category> AI </category>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 《机器学习》周志华 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《深度学习》章五 RNN 第3节 序列模型与注意力机制</title>
      <link href="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%BA%94%20RNN%20%E7%AC%AC3%E8%8A%82%20%E5%BA%8F%E5%88%97%E6%A8%A1%E5%9E%8B%E4%B8%8E%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6%209d61c051b9df481e9e2f4af63c108bf8/"/>
      <url>/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%BA%94%20RNN%20%E7%AC%AC3%E8%8A%82%20%E5%BA%8F%E5%88%97%E6%A8%A1%E5%9E%8B%E4%B8%8E%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6%209d61c051b9df481e9e2f4af63c108bf8/</url>
      
        <content type="html"><![CDATA[<h1 id="章五-RNN-第3节-序列模型与注意力机制"><a href="#章五-RNN-第3节-序列模型与注意力机制" class="headerlink" title="章五 RNN 第3节 序列模型与注意力机制"></a>章五 RNN 第3节 序列模型与注意力机制</h1><h1 id="第3节-序列模型与注意力机制"><a href="#第3节-序列模型与注意力机制" class="headerlink" title="第3节 序列模型与注意力机制"></a>第3节 序列模型与注意力机制</h1><h2 id="3-1-Basic-Models"><a href="#3-1-Basic-Models" class="headerlink" title="3.1 Basic Models"></a>3.1 <strong>Basic Models</strong></h2><p>Sequence to sequence（序列）模型在机器翻译和语音识别方面都有着广泛的应用。</p><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%BA%94%20RNN%20%E7%AC%AC3%E8%8A%82%20%E5%BA%8F%E5%88%97%E6%A8%A1%E5%9E%8B%E4%B8%8E%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6%209d61c051b9df481e9e2f4af63c108bf8/Untitled.png" alt="Untitled"></p><p>其中，encoder vector代表了输入语句的编码特征。encoder network和decoder network都是RNN模型，可使用GRU或LSTM单元。这种“编码网络（encoder network）”+“解码网络（decoder network）”的模型，在实际的机器翻译应用中有着不错的效果。</p><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%BA%94%20RNN%20%E7%AC%AC3%E8%8A%82%20%E5%BA%8F%E5%88%97%E6%A8%A1%E5%9E%8B%E4%B8%8E%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6%209d61c051b9df481e9e2f4af63c108bf8/Untitled%201.png" alt="Untitled"></p><h2 id="3-2-找出最有可能的句子"><a href="#3-2-找出最有可能的句子" class="headerlink" title="3.2 找出最有可能的句子"></a>3.2 找出最有可能的句子</h2><p>Sequence to sequence machine translation模型与我们第一节课介绍的language模型有一些相似，但也存在不同之处。</p><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%BA%94%20RNN%20%E7%AC%AC3%E8%8A%82%20%E5%BA%8F%E5%88%97%E6%A8%A1%E5%9E%8B%E4%B8%8E%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6%209d61c051b9df481e9e2f4af63c108bf8/Untitled%202.png" alt="Untitled"></p><p><strong>Language mode</strong>l是<strong>自动生成一条完整语句，语句是随机的</strong>。而<strong>machine translation</strong> model是<strong>根据输入语句，进行翻译，生成另外一条完整语句。</strong>上图中，绿色部分表示encoder network，紫色部分表示decoder network。decoder network与language model是相似的，<strong>encoder network可以看成是language model的a<0>a<0></0></0></strong>，是模型的一个条件。也就是说，在输入语句的条件下，生成正确的翻译语句。因此，<strong>machine translation可以看成是有条件的语言模型（conditional language model）。</strong>这就是二者之间的区别与联系。</p><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%BA%94%20RNN%20%E7%AC%AC3%E8%8A%82%20%E5%BA%8F%E5%88%97%E6%A8%A1%E5%9E%8B%E4%B8%8E%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6%209d61c051b9df481e9e2f4af63c108bf8/Untitled%203.png" alt="Untitled"></p><p><strong>Greedy search</strong></p><p>实现优化目标的方法之一是使用<strong>贪婪搜索（greedy search）</strong>。Greedy search根据条件，每次只寻找一个最佳单词作为翻译输出，力求把每个单词都翻译准确。例如，首先根据输入语句，找到第一个翻译的单词“Jane”，然后再找第二个单词“is”，再继续找第三个单词“visiting”，以此类推。这也是其“贪婪”名称的由来。</p><p>Greedy search存在一些缺点。首先，因为<strong>greedy search每次只搜索一个单词，没有考虑该单词前后关系，概率选择上有可能会出错。</strong>例如，上面翻译语句中，第三个单词“going”比“visiting”更常见，模型很可能会错误地选择了“going”，而错失最佳翻译语句。其次，greedy search大大增加了运算成本，降低运算速度。</p><p>因此，greedy search并不是最佳的方法。下一小节，我们将介绍Beam Search，使用近似最优的查找方式，最大化输出概率，寻找最佳的翻译语句。</p><h2 id="3-3-Beam-Search"><a href="#3-3-Beam-Search" class="headerlink" title="3.3 Beam Search"></a><strong>3.3 Beam Search</strong></h2><p>Greedy search每次是找出预测概率最大的单词，而beam search则是每次找出预测概率最大的B个单词。其中，参数B表示取概率最大的单词个数，可调。本例中，令B=3。<br>按照beam search的搜索原理，首先，先从词汇表中找出翻译的第一个单词概率最大的B个预测单词。例如上面的例子中，预测得到的第一个单词为：in，jane，september。</p><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%BA%94%20RNN%20%E7%AC%AC3%E8%8A%82%20%E5%BA%8F%E5%88%97%E6%A8%A1%E5%9E%8B%E4%B8%8E%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6%209d61c051b9df481e9e2f4af63c108bf8/Untitled%204.png" alt="Untitled"></p><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%BA%94%20RNN%20%E7%AC%AC3%E8%8A%82%20%E5%BA%8F%E5%88%97%E6%A8%A1%E5%9E%8B%E4%B8%8E%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6%209d61c051b9df481e9e2f4af63c108bf8/Untitled%205.png" alt="Untitled"></p><h2 id="3-4-Refinements-to-Beam-Search"><a href="#3-4-Refinements-to-Beam-Search" class="headerlink" title="3.4 Refinements to Beam Search"></a>3.<strong>4 Refinements to Beam Search</strong></h2><p><strong>数值下溢</strong></p><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%BA%94%20RNN%20%E7%AC%AC3%E8%8A%82%20%E5%BA%8F%E5%88%97%E6%A8%A1%E5%9E%8B%E4%B8%8E%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6%209d61c051b9df481e9e2f4af63c108bf8/Untitled%206.png" alt="Untitled"></p><p><strong>倾向于短语句</strong></p><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%BA%94%20RNN%20%E7%AC%AC3%E8%8A%82%20%E5%BA%8F%E5%88%97%E6%A8%A1%E5%9E%8B%E4%B8%8E%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6%209d61c051b9df481e9e2f4af63c108bf8/Untitled%207.png" alt="Untitled"></p><h2 id="3-5-Error-analysis-in-beam-search"><a href="#3-5-Error-analysis-in-beam-search" class="headerlink" title="3.5 Error analysis in beam search"></a>3.5 <strong>Error analysis in beam search</strong></h2><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%BA%94%20RNN%20%E7%AC%AC3%E8%8A%82%20%E5%BA%8F%E5%88%97%E6%A8%A1%E5%9E%8B%E4%B8%8E%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6%209d61c051b9df481e9e2f4af63c108bf8/Untitled%208.png" alt="Untitled"></p><h2 id="3-6-Bleu-Score-optional"><a href="#3-6-Bleu-Score-optional" class="headerlink" title="3.6 Bleu Score(optional)"></a>3.6 <strong>Bleu Score(optional)</strong></h2><h2 id="3-7-Attention-Model-Intuition"><a href="#3-7-Attention-Model-Intuition" class="headerlink" title="3.7 Attention Model Intuition"></a>3.7 <strong>Attention Model Intuition</strong></h2><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%BA%94%20RNN%20%E7%AC%AC3%E8%8A%82%20%E5%BA%8F%E5%88%97%E6%A8%A1%E5%9E%8B%E4%B8%8E%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6%209d61c051b9df481e9e2f4af63c108bf8/Untitled%209.png" alt="Untitled"></p><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%BA%94%20RNN%20%E7%AC%AC3%E8%8A%82%20%E5%BA%8F%E5%88%97%E6%A8%A1%E5%9E%8B%E4%B8%8E%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6%209d61c051b9df481e9e2f4af63c108bf8/Untitled%2010.png" alt="Untitled"></p><h2 id="3-8-Attention-Models"><a href="#3-8-Attention-Models" class="headerlink" title="3.8 Attention Models"></a>3.8 <strong>Attention Models</strong></h2><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%BA%94%20RNN%20%E7%AC%AC3%E8%8A%82%20%E5%BA%8F%E5%88%97%E6%A8%A1%E5%9E%8B%E4%B8%8E%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6%209d61c051b9df481e9e2f4af63c108bf8/Untitled%2011.png" alt="Untitled"></p><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%BA%94%20RNN%20%E7%AC%AC3%E8%8A%82%20%E5%BA%8F%E5%88%97%E6%A8%A1%E5%9E%8B%E4%B8%8E%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6%209d61c051b9df481e9e2f4af63c108bf8/Untitled%2012.png" alt="Untitled"></p><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%BA%94%20RNN%20%E7%AC%AC3%E8%8A%82%20%E5%BA%8F%E5%88%97%E6%A8%A1%E5%9E%8B%E4%B8%8E%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6%209d61c051b9df481e9e2f4af63c108bf8/Untitled%2013.png" alt="Untitled"></p><h2 id="3-9-Speech-recognition"><a href="#3-9-Speech-recognition" class="headerlink" title="3.9 Speech recognition"></a>3.9 <strong>Speech recognition</strong></h2><p>深度学习中，语音识别的输入是声音，量化成时间序列。更一般地，可以把信号转化为频域信号，即声谱图（spectrogram），再进入RNN模型进行语音识别。</p><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%BA%94%20RNN%20%E7%AC%AC3%E8%8A%82%20%E5%BA%8F%E5%88%97%E6%A8%A1%E5%9E%8B%E4%B8%8E%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6%209d61c051b9df481e9e2f4af63c108bf8/Untitled%2014.png" alt="Untitled"></p><p>之前，语言学家们会将语音中每个单词分解成多个音素（phoneme），构建更精准的传统识别算法。但在end-to-end深度神经网络模型中，一般不需要这么做也能得到很好的识别效果。通常训练样本很大，需要上千上万个小时的语音素材。</p><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%BA%94%20RNN%20%E7%AC%AC3%E8%8A%82%20%E5%BA%8F%E5%88%97%E6%A8%A1%E5%9E%8B%E4%B8%8E%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6%209d61c051b9df481e9e2f4af63c108bf8/Untitled%2015.png" alt="Untitled"></p><h2 id="3-10-Trigger-Word-Detection"><a href="#3-10-Trigger-Word-Detection" class="headerlink" title="3.10 Trigger Word Detection"></a>3.10 <strong>Trigger Word Detection</strong></h2><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%BA%94%20RNN%20%E7%AC%AC3%E8%8A%82%20%E5%BA%8F%E5%88%97%E6%A8%A1%E5%9E%8B%E4%B8%8E%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6%209d61c051b9df481e9e2f4af63c108bf8/Untitled%2016.png" alt="Untitled"></p><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%BA%94%20RNN%20%E7%AC%AC3%E8%8A%82%20%E5%BA%8F%E5%88%97%E6%A8%A1%E5%9E%8B%E4%B8%8E%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6%209d61c051b9df481e9e2f4af63c108bf8/Untitled%2017.png" alt="Untitled"></p>]]></content>
      
      
      <categories>
          
          <category> AI </category>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 《深度学习》吴恩达 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《深度学习》章五 RNN 第2节 NLP &amp; Word Embeddings</title>
      <link href="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%BA%94%20RNN%20%E7%AC%AC2%E8%8A%82%20NLP%20&amp;%20Word%20Embeddings%20cde6e8cb0d7e46c989633ee5f2468ead/"/>
      <url>/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%BA%94%20RNN%20%E7%AC%AC2%E8%8A%82%20NLP%20&amp;%20Word%20Embeddings%20cde6e8cb0d7e46c989633ee5f2468ead/</url>
      
        <content type="html"><![CDATA[<h1 id="章五-RNN-第2节-NLP-amp-Word-Embeddings"><a href="#章五-RNN-第2节-NLP-amp-Word-Embeddings" class="headerlink" title="章五 RNN 第2节 NLP &amp; Word Embeddings"></a>章五 RNN 第2节 NLP &amp; Word Embeddings</h1><h1 id="第2节-NLP-amp-Word-Embeddings"><a href="#第2节-NLP-amp-Word-Embeddings" class="headerlink" title="第2节 NLP &amp; Word Embeddings"></a>第2节 NLP &amp; Word Embeddings</h1><h2 id="2-1-单词表示"><a href="#2-1-单词表示" class="headerlink" title="2.1 单词表示"></a>2.1 单词表示</h2><p><strong>one-hot</strong>表征单词的方法最大的缺点就是每个单词都是<strong>独立的、正交的</strong>，<strong>无法知道不同单词之间的相似程度</strong>。例如Apple和Orange都是水果，词性相近，但是单从one-hot编码上来看，内积为零，无法知道二者的相似性。在NLP中，<strong>我们更希望能掌握不同单词之间的相似程度。</strong></p><p>因此，我们可以使用<strong>特征表征（Featurized representation）</strong>的方法对每个单词进行编码。也就是<strong>使用一个特征向量表征单词</strong>，特征向量的每个元素都是对该单词某一特征的量化描述，<strong>量化范围可以是[-1,1]</strong>之间。</p><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%BA%94%20RNN%20%E7%AC%AC2%E8%8A%82%20NLP%20&%20Word%20Embeddings%20cde6e8cb0d7e46c989633ee5f2468ead/Untitled.png" alt="Untitled"></p><p>特征向量的长度依情况而定，特征元素越多则对单词表征得越全面。这里的特征向量长度设定为300。使用特征表征之后，词汇表中的每个单词都可以使用对应的300 x 1的向量来表示，该向量的每个元素表示该单词对应的某个特征值。每个单词用e+词汇表索引的方式标记</p><p>这种特征表征的优点是<strong>根据特征向量能清晰知道不同单词之间的相似程度</strong>，例如Apple和Orange之间的相似度较高，很可能属于同一类别。这种单词“类别”化的方式，大大提高了有限词汇量的泛化能力。这种特征化单词的操作被称为<strong>Word Embeddings，即单词嵌入。</strong></p><p>值得一提的是，这里特征向量的<strong>每个特征元素含义是具体的，对应到实际特征，例如性别、年龄等。</strong>而<strong>在实际应用中</strong>，特征向量很多特征元素并<strong>不一定对应到有物理意义</strong>的特征，<strong>是比较抽象的</strong>。但是，这并不影响对每个单词的有效表征，同样能比较不同单词之间的相似性。</p><h2 id="2-2-使用词嵌入"><a href="#2-2-使用词嵌入" class="headerlink" title="2.2 使用词嵌入"></a><strong>2.2 使用词嵌入</strong></h2><p>featurized representation的优点是可以减少训练样本的数目，前提是对海量单词建立特征向量表述（word embedding）。这样，即使训练样本不够多，测试时遇到陌生单词，例如“durian cultivator”，根据之前海量词汇特征向量就判断出“durian”也是一种水果，与“apple”类似，而“cultivator”与“farmer”也很相似。</p><p>通过 word embedding 得到特征向量，</p><p>这样遇到训练过程没有的样本时，由于特征向量时类似的，所以，神经网络也能得到相应的输出</p><p>featurized representation的特性使得很多NLP任务能方便地进行迁移学习。方法是：</p><ul><li>从海量词汇库中学习word embeddings，即所有单词的特征向量。或者从网上下载预训练好的word embeddings。</li><li>使用较少的训练样本，将word embeddings迁移到新的任务中。</li><li>（可选）：继续使用新数据微调word embeddings。</li></ul><p>人脸特征编码有很多相似性。人脸图片经过Siamese网络，得到其特征向量f(x)f(x)，这点跟word embedding是类似的。二者不同的是Siamese网络输入的人脸图片可以是数据库之外的；而word embedding一般都是已建立的词汇库中的单词，非词汇库单词统一用&lt; UNK &gt;表示。</p><p>对于embedding的理解：大概是得到神经网络的输入的部分，也就是编码部分，获得特征部分，这一部分也是要训练的把。</p><h2 id="2-3-Properties-of-word-embeddings"><a href="#2-3-Properties-of-word-embeddings" class="headerlink" title="2.3 Properties of word embeddings"></a>2.<strong>3 Properties of word embeddings</strong></h2><p>Word embeddings可以帮助我们找到不同单词之间的相似类别关系。</p><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%BA%94%20RNN%20%E7%AC%AC2%E8%8A%82%20NLP%20&%20Word%20Embeddings%20cde6e8cb0d7e46c989633ee5f2468ead/Untitled%201.png" alt="Untitled"></p><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%BA%94%20RNN%20%E7%AC%AC2%E8%8A%82%20NLP%20&%20Word%20Embeddings%20cde6e8cb0d7e46c989633ee5f2468ead/Untitled%202.png" alt="Untitled"></p><h2 id="2-4-Embedding-matrix"><a href="#2-4-Embedding-matrix" class="headerlink" title="2.4 Embedding matrix"></a>2.<strong>4 Embedding matrix</strong></h2><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%BA%94%20RNN%20%E7%AC%AC2%E8%8A%82%20NLP%20&%20Word%20Embeddings%20cde6e8cb0d7e46c989633ee5f2468ead/Untitled%203.png" alt="Untitled"></p><h2 id="2-5-Learning-word-embeddings"><a href="#2-5-Learning-word-embeddings" class="headerlink" title="2.5 Learning word embeddings"></a>2.5 <strong>Learning word embeddings</strong></h2><p>embedding matrix E可以通过构建自然语言模型，运用梯度下降算法得到。举个简单的例子，输入样本是下面这句话：</p><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%BA%94%20RNN%20%E7%AC%AC2%E8%8A%82%20NLP%20&%20Word%20Embeddings%20cde6e8cb0d7e46c989633ee5f2468ead/Untitled%204.png" alt="Untitled"></p><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%BA%94%20RNN%20%E7%AC%AC2%E8%8A%82%20NLP%20&%20Word%20Embeddings%20cde6e8cb0d7e46c989633ee5f2468ead/Untitled%205.png" alt="Untitled"></p><h2 id="2-6-Word2Vec"><a href="#2-6-Word2Vec" class="headerlink" title="2.6 Word2Vec"></a>2.6 <strong>Word2Vec</strong></h2><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%BA%94%20RNN%20%E7%AC%AC2%E8%8A%82%20NLP%20&%20Word%20Embeddings%20cde6e8cb0d7e46c989633ee5f2468ead/Untitled%206.png" alt="Untitled"></p><p>还提出，softmax运算量大，用树来解决，高频词汇在顶部</p><p>Skip-Gram模型是Word2Vec的一种，Word2Vec的另外一种模型是CBOW（Continuous Bag of Words）。</p><h2 id="2-7-Negative-Sampling"><a href="#2-7-Negative-Sampling" class="headerlink" title="2.7 Negative Sampling"></a>2.7 <strong>Negative Sampling</strong></h2><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%BA%94%20RNN%20%E7%AC%AC2%E8%8A%82%20NLP%20&%20Word%20Embeddings%20cde6e8cb0d7e46c989633ee5f2468ead/Untitled%207.png" alt="Untitled"></p><p>把 softmax转化成了 k+1个的二分类</p><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%BA%94%20RNN%20%E7%AC%AC2%E8%8A%82%20NLP%20&%20Word%20Embeddings%20cde6e8cb0d7e46c989633ee5f2468ead/Untitled%208.png" alt="Untitled"></p><h2 id="2-8-GloVe-word-vectors"><a href="#2-8-GloVe-word-vectors" class="headerlink" title="2.8 GloVe word vectors"></a>2.8 <strong>GloVe word vectors</strong></h2><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%BA%94%20RNN%20%E7%AC%AC2%E8%8A%82%20NLP%20&%20Word%20Embeddings%20cde6e8cb0d7e46c989633ee5f2468ead/Untitled%209.png" alt="Untitled"></p><h2 id="2-9-Sentiment-Classification"><a href="#2-9-Sentiment-Classification" class="headerlink" title="2.9 Sentiment Classification"></a>2.9 <strong>Sentiment Classification</strong></h2><p><strong>情感分类一</strong>般是根据一句话来判断其喜爱程度，例如1～5星分布。如下图所示：</p><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%BA%94%20RNN%20%E7%AC%AC2%E8%8A%82%20NLP%20&%20Word%20Embeddings%20cde6e8cb0d7e46c989633ee5f2468ead/Untitled%2010.png" alt="Untitled"></p><p>情感分类问题的一个主要挑战是缺少足够多的训练样本。而Word embedding恰恰可以帮助解决训练样本不足的问题。<br>首先介绍使用word embedding解决情感分类问题的一个简单模型算法。</p><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%BA%94%20RNN%20%E7%AC%AC2%E8%8A%82%20NLP%20&%20Word%20Embeddings%20cde6e8cb0d7e46c989633ee5f2468ead/Untitled%2011.png" alt="Untitled"></p><p>如上图所示，这句话的4个单词分别用embedding vector表示。e8928,e2468,e4694,e3180e8928,e2468,e4694,e3180计算均值，这样得到的平均向量的维度仍是300。最后经过softmax输出1～5星。这种模型结构简单，计算量不大，不论句子长度多长，都使用平均的方式得到300D的embedding vector。该模型实际表现较好。</p><p>但是，这种简单模型的缺点是使用平均方法，没有考虑句子中单词出现的次序，忽略其位置信息。而有时候，不同单词出现的次序直接决定了句意，即情感分类的结果。例如下面这句话：</p><p>Completely lacking in good taste, good service, and good ambience.</p><p>虽然这句话<strong>中包含了3个“good”，但是其前面出现了“lacking”，很明显这句话句意是negative的</strong>。如果使用上面介绍的平均算法，则很可能会错误识别为positive的，因为忽略了单词出现的次序。</p><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%BA%94%20RNN%20%E7%AC%AC2%E8%8A%82%20NLP%20&%20Word%20Embeddings%20cde6e8cb0d7e46c989633ee5f2468ead/Untitled%2012.png" alt="Untitled"></p><p>值得一提的是使用word embedding，能够有效提高模型的泛化能力，即使训练样本不多，也能保证模型有不错的性能。</p><h2 id="2-10-Debiasing-word-embeddings"><a href="#2-10-Debiasing-word-embeddings" class="headerlink" title="2.10 Debiasing word embeddings"></a>2.10 <strong>Debiasing word embeddings</strong></h2><p>Word embeddings中存在一些性别、宗教、种族等偏见或者歧视。例如下面这两句话：</p><p><strong>Man: Woman as King: Queen</strong></p><p><strong>Man: Computer programmer as Woman: Homemaker</strong></p><p><strong>Father: Doctor as Mother: Nurse</strong></p><p>很明显，第二句话和第三句话存在性别偏见，因为Woman和Mother也可以是Computer programmer和Doctor。</p><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%BA%94%20RNN%20%E7%AC%AC2%E8%8A%82%20NLP%20&%20Word%20Embeddings%20cde6e8cb0d7e46c989633ee5f2468ead/Untitled%2013.png" alt="Untitled"></p><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%BA%94%20RNN%20%E7%AC%AC2%E8%8A%82%20NLP%20&%20Word%20Embeddings%20cde6e8cb0d7e46c989633ee5f2468ead/Untitled%2014.png" alt="Untitled"></p><p>值得注意的是，掌握哪些单词需要中立化非常重要。一般来说，大部分英文单词，例如职业、身份等都需要中立化，消除embedding vector中性别这一维度的影响。</p>]]></content>
      
      
      <categories>
          
          <category> AI </category>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 《深度学习》吴恩达 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《深度学习》 章五 RNN 第1节 RNN</title>
      <link href="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%BA%94%20RNN%20%E7%AC%AC1%E8%8A%82%20RNN%20c6102cb4710b41e989d3ad80a333366a/"/>
      <url>/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%BA%94%20RNN%20%E7%AC%AC1%E8%8A%82%20RNN%20c6102cb4710b41e989d3ad80a333366a/</url>
      
        <content type="html"><![CDATA[<h1 id="章五-RNN-第1节-RNN"><a href="#章五-RNN-第1节-RNN" class="headerlink" title="章五 RNN 第1节 RNN"></a>章五 RNN 第1节 RNN</h1><h1 id="第1节-RNN"><a href="#第1节-RNN" class="headerlink" title="第1节 RNN"></a>第1节 RNN</h1><h2 id="1-1-什么是序列模型"><a href="#1-1-什么是序列模型" class="headerlink" title="1.1 什么是序列模型"></a>1.1 什么是序列模型</h2><p>序列模型能够应用在许多领域，例如：</p><ul><li><strong>语音识别</strong></li><li><strong>音乐发生器</strong></li><li><strong>情感分类</strong></li><li><strong>DNA序列分析</strong></li><li><strong>机器翻译</strong></li><li><strong>视频动作识别</strong></li><li><strong>命名实体识别</strong></li></ul><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%BA%94%20RNN%20%E7%AC%AC1%E8%8A%82%20RNN%20c6102cb4710b41e989d3ad80a333366a/Untitled.png" alt="Untitled"></p><p>这些序列模型基本都属于监督式学习，输入x和输出y不一定都是序列模型。如果都是序列模型的话，模型长度不一定完全一致。</p><h2 id="1-2-数学符号"><a href="#1-2-数学符号" class="headerlink" title="1.2 数学符号"></a>1.<strong>2 数学符号</strong></h2><p><strong>Harry Potter and Hermione Granger invented a new spell.</strong></p><p>该句话包含9个单词，输出y即为<strong>1 x 9向量</strong>，每位表征对应单词是否为人名的一部分，<strong>1表示是，0表示否。</strong></p><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%BA%94%20RNN%20%E7%AC%AC1%E8%8A%82%20RNN%20c6102cb4710b41e989d3ad80a333366a/Untitled%201.png" alt="Untitled"></p><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%BA%94%20RNN%20%E7%AC%AC1%E8%8A%82%20RNN%20c6102cb4710b41e989d3ad80a333366a/Untitled%202.png" alt="Untitled"></p><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%BA%94%20RNN%20%E7%AC%AC1%E8%8A%82%20RNN%20c6102cb4710b41e989d3ad80a333366a/Untitled%203.png" alt="Untitled"></p><h2 id="1-3-循环神经网络模型"><a href="#1-3-循环神经网络模型" class="headerlink" title="1.3 循环神经网络模型"></a>1.<strong>3 循环神经网络模型</strong></h2><p>对于序列模型，如果使用标准的神经网络，其模型结构如下：</p><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%BA%94%20RNN%20%E7%AC%AC1%E8%8A%82%20RNN%20c6102cb4710b41e989d3ad80a333366a/Untitled%204.png" alt="Untitled"></p><p>使用标准的神经网络模型存在两个问题：</p><p>第一个问题，不同样本的输入序列长度或输出序列长度不同。造成模型难以统一。解决办法之一是设定一个最大序列长度，对每个输入和输出序列补零并统一到最大长度。但是这种做法实际效果并不理想。<br>第二个问题，也是主要问题，这种标准神经网络结构无法共享序列不同x<t>之间的特征。值得一提的是，共享特征还有助于减少神经网络中的参数数量，一定程度上减小了模型的计算复杂度。例如上图所示的标准神经网络，假设每个x<t>x<t>扩展到最大序列长度为100，且词汇表长度为10000，则输入层就已经包含了100 x 10000个神经元了，权重参数很多，运算量将是庞大的。</t></t></t></p><h3 id="前向传播"><a href="#前向传播" class="headerlink" title="前向传播"></a><strong>前向传播</strong></h3><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%BA%94%20RNN%20%E7%AC%AC1%E8%8A%82%20RNN%20c6102cb4710b41e989d3ad80a333366a/Untitled%205.png" alt="Untitled"></p><h3 id="简化RNN计算过程"><a href="#简化RNN计算过程" class="headerlink" title="简化RNN计算过程"></a><strong>简化RNN计算过程</strong></h3><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%BA%94%20RNN%20%E7%AC%AC1%E8%8A%82%20RNN%20c6102cb4710b41e989d3ad80a333366a/Untitled%206.png" alt="Untitled"></p><h3 id="另外还有双向RNN，即BRNN"><a href="#另外还有双向RNN，即BRNN" class="headerlink" title="另外还有双向RNN，即BRNN"></a><strong>另外还有双向RNN，即BRNN</strong></h3><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%BA%94%20RNN%20%E7%AC%AC1%E8%8A%82%20RNN%20c6102cb4710b41e989d3ad80a333366a/Untitled%207.png" alt="Untitled"></p><h2 id="1-4-通过实践的反向传播"><a href="#1-4-通过实践的反向传播" class="headerlink" title="1.4 通过实践的反向传播"></a>1.<strong>4 通过实践的反向传播</strong></h2><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%BA%94%20RNN%20%E7%AC%AC1%E8%8A%82%20RNN%20c6102cb4710b41e989d3ad80a333366a/Untitled%208.png" alt="Untitled"></p><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%BA%94%20RNN%20%E7%AC%AC1%E8%8A%82%20RNN%20c6102cb4710b41e989d3ad80a333366a/Untitled%209.png" alt="Untitled"></p><h2 id="1-5-更多不同类型的RNNs"><a href="#1-5-更多不同类型的RNNs" class="headerlink" title="1.5 更多不同类型的RNNs"></a>1.5 <strong>更多不同类型的RNNs</strong></h2><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%BA%94%20RNN%20%E7%AC%AC1%E8%8A%82%20RNN%20c6102cb4710b41e989d3ad80a333366a/Untitled%2010.png" alt="Untitled"></p><h2 id="1-6-语言模型与序列生成"><a href="#1-6-语言模型与序列生成" class="headerlink" title="1.6 语言模型与序列生成"></a>1.6 语言模型与序列生成</h2><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%BA%94%20RNN%20%E7%AC%AC1%E8%8A%82%20RNN%20c6102cb4710b41e989d3ad80a333366a/Untitled%2011.png" alt="Untitled"></p><p>其实下面这些没有看懂，不知道为什么没有输出就能推测出一个句子，或者是生成一个句子了</p><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%BA%94%20RNN%20%E7%AC%AC1%E8%8A%82%20RNN%20c6102cb4710b41e989d3ad80a333366a/Untitled%2012.png" alt="Untitled"></p><p>其实也就是个条件概率，前面推测后面的概率</p><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%BA%94%20RNN%20%E7%AC%AC1%E8%8A%82%20RNN%20c6102cb4710b41e989d3ad80a333366a/Untitled%2013.png" alt="Untitled"></p><h2 id="1-7-对新序列采样"><a href="#1-7-对新序列采样" class="headerlink" title="1.7 对新序列采样"></a>1.7 <strong>对新序列采样</strong></h2><p>训练好模型之后，进行新的序列采样，产生新的语句。（这一节介绍了，随机采样获得新序列以及字符模型）</p><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%BA%94%20RNN%20%E7%AC%AC1%E8%8A%82%20RNN%20c6102cb4710b41e989d3ad80a333366a/Untitled%2014.png" alt="Untitled"></p><h2 id="1-8-带有神经网络的梯度消失"><a href="#1-8-带有神经网络的梯度消失" class="headerlink" title="1.8 带有神经网络的梯度消失"></a>1.8 <strong>带有神经网络的梯度消失</strong></h2><p>梯度消失与梯度爆炸（设置阈值，缩小）问题</p><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%BA%94%20RNN%20%E7%AC%AC1%E8%8A%82%20RNN%20c6102cb4710b41e989d3ad80a333366a/Untitled%2015.png" alt="Untitled"></p><h2 id="1-9-Gated-Recurrent-Unit-GRU"><a href="#1-9-Gated-Recurrent-Unit-GRU" class="headerlink" title="1.9 Gated Recurrent Unit(GRU)"></a>1.9 <strong>Gated Recurrent Unit(GRU)</strong></h2><h3 id="简化版GRU"><a href="#简化版GRU" class="headerlink" title="简化版GRU"></a><strong>简化版GRU</strong></h3><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%BA%94%20RNN%20%E7%AC%AC1%E8%8A%82%20RNN%20c6102cb4710b41e989d3ad80a333366a/Untitled%2016.png" alt="Untitled"></p><p>三个式子：<br>1、c-<t>：根据前面时刻传递的值和当前时刻的输入x来计算一个新的c-<t><br>2、Gate u（update）：计算的是一个门限值，通过sigmod函数之后输出的是0-1之间的数，（方便理解的话就是0或者1，然后就类似一个们，从c-<t>和c<t-1>里面选一个）<br>3、c<t>：也就是传递到下一时刻的值，由c-<t>和c<t-1>线性组合，门限值Gate u决定（注意：这里Gate u的理解就是核心，也就是记忆单元，当它等于1时，代表更新，当他等于0时，代表记忆，参考能够记忆前文的主语是单数还是复数；还有就是这是一个向量，有些0，有些是1，也就是有些保存，有些更新）<br>因此，Γu能够保证RNN模型中跨度很大的依赖关系不受影响，消除梯度消失问题。</t-1></t></t></t-1></t></t></t></p><p>综合起来理解就是，有一个门限值（0-1）来控制前一时刻传递给后面的值的保留程度。</p><h3 id="完整版GRU"><a href="#完整版GRU" class="headerlink" title="完整版GRU"></a><strong>完整版GRU</strong></h3><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%BA%94%20RNN%20%E7%AC%AC1%E8%8A%82%20RNN%20c6102cb4710b41e989d3ad80a333366a/Untitled%2017.png" alt="Untitled"></p><p>也就是加入了一个相关门，计算前一层传递的影响程度。</p><h2 id="1-10-LSTM"><a href="#1-10-LSTM" class="headerlink" title="1.10 LSTM"></a>1.10 <strong>LSTM</strong></h2><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%BA%94%20RNN%20%E7%AC%AC1%E8%8A%82%20RNN%20c6102cb4710b41e989d3ad80a333366a/Untitled%2018.png" alt="Untitled"></p><p>只有黄的是神经网络层（有参数），其他不是（运算）</p><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a><strong>流程</strong></h3><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%BA%94%20RNN%20%E7%AC%AC1%E8%8A%82%20RNN%20c6102cb4710b41e989d3ad80a333366a/Untitled%2019.png" alt="Untitled"></p><p>1、forget get:由前面的a和当前的x，线性计算后通过sigmoid，得到0-1之间的值，作用于前一个cell state，1表示保留，0表示丢弃。</p><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%BA%94%20RNN%20%E7%AC%AC1%E8%8A%82%20RNN%20c6102cb4710b41e989d3ad80a333366a/Untitled%2020.png" alt="Untitled"></p><p>2、input gate（update gate）：用于决定哪些信息将会被加入cell state中。决定哪些值将被更新<br>3、tenh层：构成的新候选词的向量生成器，可能被输入到cell state中。</p><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%BA%94%20RNN%20%E7%AC%AC1%E8%8A%82%20RNN%20c6102cb4710b41e989d3ad80a333366a/Untitled%2021.png" alt="Untitled"></p><p>4、旧状态加新的候选信息，组成当前cellstate.</p><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%BA%94%20RNN%20%E7%AC%AC1%E8%8A%82%20RNN%20c6102cb4710b41e989d3ad80a333366a/Untitled%2022.png" alt="Untitled"></p><p>5、决定输出：输出是基于cell state，但先会有一个滤波的过程（output gate）。首先通过这些output gate（sigmoid层）决定哪些cell state输出，同时将cell state传到tanh层（-1——1），再乘以output gate 得到输出。</p><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%BA%94%20RNN%20%E7%AC%AC1%E8%8A%82%20RNN%20c6102cb4710b41e989d3ad80a333366a/Untitled%2023.png" alt="Untitled"></p><h3 id="变体"><a href="#变体" class="headerlink" title="变体"></a><strong>变体</strong></h3><p>1、加入 c<t-1>到门的计算</t-1></p><p>2、只算遗忘门，不算更新（1-f），</p><p>3、GRU</p><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%BA%94%20RNN%20%E7%AC%AC1%E8%8A%82%20RNN%20c6102cb4710b41e989d3ad80a333366a/Untitled%2024.png" alt="Untitled"></p><p>和GRU相比没有输入门了，统一由update门控制，但是有一个rate门，（感觉这样一综合其实和之前的两个门其实也区别不大了吧。）<br>然后输入也少了一个（应该也不算，只是把cell的值，直接当场a的值了）</p><h2 id="1-11-BRNN"><a href="#1-11-BRNN" class="headerlink" title="1.11 BRNN"></a>1.11 <strong>BRNN</strong></h2><p>BRNN能够同时对序列进行双向处理，性能大大提高。但是计算量较大，且在处理实时语音时，需要等到完整的一句话结束时才能进行分析。</p><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%BA%94%20RNN%20%E7%AC%AC1%E8%8A%82%20RNN%20c6102cb4710b41e989d3ad80a333366a/Untitled%2025.png" alt="Untitled"></p><h2 id="1-12-Deep-RNNs"><a href="#1-12-Deep-RNNs" class="headerlink" title="1.12 Deep RNNs"></a>1.12 <strong>Deep RNNs</strong></h2><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%BA%94%20RNN%20%E7%AC%AC1%E8%8A%82%20RNN%20c6102cb4710b41e989d3ad80a333366a/Untitled%2026.png" alt="Untitled"></p><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%BA%94%20RNN%20%E7%AC%AC1%E8%8A%82%20RNN%20c6102cb4710b41e989d3ad80a333366a/Untitled%2027.png" alt="Untitled"></p>]]></content>
      
      
      <categories>
          
          <category> AI </category>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 《深度学习》吴恩达 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《深度学习》 章四 CNN 第4节 人脸识别和分割迁移</title>
      <link href="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E5%9B%9B%20CNN%20%E7%AC%AC4%E8%8A%82%20%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB%E5%92%8C%E5%88%86%E5%89%B2%E8%BF%81%E7%A7%BB%209f60e76fbedb4f45a6d0c77fef54c38d/"/>
      <url>/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E5%9B%9B%20CNN%20%E7%AC%AC4%E8%8A%82%20%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB%E5%92%8C%E5%88%86%E5%89%B2%E8%BF%81%E7%A7%BB%209f60e76fbedb4f45a6d0c77fef54c38d/</url>
      
        <content type="html"><![CDATA[<h1 id="章四-CNN-第4节-人脸识别和分割迁移"><a href="#章四-CNN-第4节-人脸识别和分割迁移" class="headerlink" title="章四 CNN 第4节 人脸识别和分割迁移"></a>章四 CNN 第4节 人脸识别和分割迁移</h1><h1 id="第4节-人脸识别和分割迁移"><a href="#第4节-人脸识别和分割迁移" class="headerlink" title="第4节 人脸识别和分割迁移"></a>第4节 人脸识别和分割迁移</h1><h2 id="4-1-什么是人脸识别"><a href="#4-1-什么是人脸识别" class="headerlink" title="4.1 什么是人脸识别"></a>4.1 <strong>什么是人脸识别</strong></h2><p>首先简单介绍一下人脸验证（face verification）和人脸识别（face recognition）的区别。</p><p><strong>人脸验证：输入一张人脸图片，验证输出与模板是否为同一人，即一对一问题。</strong></p><p><strong>人脸识别：输入一张人脸图片，验证输出是否为K个模板中的某一个，即一对多问题</strong></p><p>一般地，人脸识别比人脸验证更难一些。因为假设人脸验证系统的错误率是1%，那么在人脸识别中，输出分别与K个模板都进行比较，则相应的错误率就会增加，约K%。模板个数越多，错误率越大一些。</p><h2 id="4-2-One-Shot-学习"><a href="#4-2-One-Shot-学习" class="headerlink" title="4.2  One Shot 学习"></a>4.2  <strong>One Shot 学习</strong></h2><p>One-shot learning就是说数据库中每个人的训练样本只包含一张照片，然后训练一个CNN模型来进行人脸识别。若数据库有K个人，则CNN模型输出softmax层就是K维的。</p><p>但是One-shot learning的性能并不好，其包含了两个缺点：</p><ul><li><strong>每个人只有一张图片，训练样本少，构建的CNN网络不够健壮。</strong></li><li><strong>若数据库增加另一个人，输出层softmax的维度就要发生变化，相当于要重新构建CNN网络，使模型计算量大大增加，不够灵活。</strong></li></ul><p>为了解决One-shot learning的问题，我们先来介绍相似函数（similarity function）。相似函数表示两张图片的相似程度，用d(img1,img2)来表示。若d(img1,img2)较小，则表示两张图片相似；若d(img1,img2)较大，则表示两张图片不是同一个人。相似函数可以在人脸验证中使用：</p><p>对于人脸识别问题，则只需计算测试图片与数据库中K个目标的相似函数，取其中d(img1,img2)最小的目标为匹配对象。若所有的d(img1,img2)都很大，则表示数据库没有这个人。</p><h2 id="4-3-Siamese-网络"><a href="#4-3-Siamese-网络" class="headerlink" title="4.3 Siamese 网络"></a>4.3 <strong>Siamese 网络</strong></h2><p>CNN提取特征，然后计算范数、同类距离近，不同人距离远</p><p>若一张图片经过一般的CNN网络（包括CONV层、POOL层、FC层），最终得到全连接层FC，该FC层可以看成是原始图片的编码encoding，表征了原始图片的关键特征。这个网络结构我们称之为Siamese network。也就是说每张图片经过Siamese network后，由FC层每个神经元来表征。</p><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E5%9B%9B%20CNN%20%E7%AC%AC4%E8%8A%82%20%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB%E5%92%8C%E5%88%86%E5%89%B2%E8%BF%81%E7%A7%BB%209f60e76fbedb4f45a6d0c77fef54c38d/Untitled.png" alt="Untitled"></p><h2 id="4-4-Triplet-损失"><a href="#4-4-Triplet-损失" class="headerlink" title="4.4 Triplet 损失"></a>4.4 <strong>Triplet 损失</strong></h2><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E5%9B%9B%20CNN%20%E7%AC%AC4%E8%8A%82%20%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB%E5%92%8C%E5%88%86%E5%89%B2%E8%BF%81%E7%A7%BB%209f60e76fbedb4f45a6d0c77fef54c38d/Untitled%201.png" alt="Untitled"></p><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E5%9B%9B%20CNN%20%E7%AC%AC4%E8%8A%82%20%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB%E5%92%8C%E5%88%86%E5%89%B2%E8%BF%81%E7%A7%BB%209f60e76fbedb4f45a6d0c77fef54c38d/Untitled%202.png" alt="Untitled"></p><h2 id="4-5-人脸验证和二分类"><a href="#4-5-人脸验证和二分类" class="headerlink" title="4.5 人脸验证和二分类"></a>4.5 人脸验证和二分类</h2><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E5%9B%9B%20CNN%20%E7%AC%AC4%E8%8A%82%20%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB%E5%92%8C%E5%88%86%E5%89%B2%E8%BF%81%E7%A7%BB%209f60e76fbedb4f45a6d0c77fef54c38d/Untitled%203.png" alt="Untitled"></p><p>还可以保存模板（f(x)）来减少计算量，就不用保存原始图片了。</p><h2 id="5-6-什么是风格迁移"><a href="#5-6-什么是风格迁移" class="headerlink" title="5.6 什么是风格迁移"></a>5.6 什么是风格迁移</h2><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E5%9B%9B%20CNN%20%E7%AC%AC4%E8%8A%82%20%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB%E5%92%8C%E5%88%86%E5%89%B2%E8%BF%81%E7%A7%BB%209f60e76fbedb4f45a6d0c77fef54c38d/Untitled%204.png" alt="Untitled"></p><h2 id="4-7-深度卷积网络在学什么"><a href="#4-7-深度卷积网络在学什么" class="headerlink" title="4.7 深度卷积网络在学什么"></a>4.7 <strong>深度卷积网络在学什么</strong></h2><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E5%9B%9B%20CNN%20%E7%AC%AC4%E8%8A%82%20%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB%E5%92%8C%E5%88%86%E5%89%B2%E8%BF%81%E7%A7%BB%209f60e76fbedb4f45a6d0c77fef54c38d/Untitled%205.png" alt="Untitled"></p><h2 id="4-8-损失函数"><a href="#4-8-损失函数" class="headerlink" title="4.8 损失函数"></a>4.8 <strong>损失函数</strong></h2><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E5%9B%9B%20CNN%20%E7%AC%AC4%E8%8A%82%20%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB%E5%92%8C%E5%88%86%E5%89%B2%E8%BF%81%E7%A7%BB%209f60e76fbedb4f45a6d0c77fef54c38d/Untitled%206.png" alt="Untitled"></p><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E5%9B%9B%20CNN%20%E7%AC%AC4%E8%8A%82%20%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB%E5%92%8C%E5%88%86%E5%89%B2%E8%BF%81%E7%A7%BB%209f60e76fbedb4f45a6d0c77fef54c38d/Untitled%207.png" alt="Untitled"></p><h2 id="4-9-内容损失函数"><a href="#4-9-内容损失函数" class="headerlink" title="4.9 内容损失函数"></a>4.9 内容损失函数</h2><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E5%9B%9B%20CNN%20%E7%AC%AC4%E8%8A%82%20%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB%E5%92%8C%E5%88%86%E5%89%B2%E8%BF%81%E7%A7%BB%209f60e76fbedb4f45a6d0c77fef54c38d/Untitled%208.png" alt="Untitled"></p><h2 id="4-10-风格损失函数"><a href="#4-10-风格损失函数" class="headerlink" title="4.10 风格损失函数"></a>4.10 风格损失函数</h2><p>什么是图片的风格？利用CNN网络模型，图片的风格可以定义成第l层隐藏层<strong>不同通道间激活函数的乘积（相关性）。</strong></p><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E5%9B%9B%20CNN%20%E7%AC%AC4%E8%8A%82%20%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB%E5%92%8C%E5%88%86%E5%89%B2%E8%BF%81%E7%A7%BB%209f60e76fbedb4f45a6d0c77fef54c38d/Untitled%209.png" alt="Untitled"></p><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E5%9B%9B%20CNN%20%E7%AC%AC4%E8%8A%82%20%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB%E5%92%8C%E5%88%86%E5%89%B2%E8%BF%81%E7%A7%BB%209f60e76fbedb4f45a6d0c77fef54c38d/Untitled%2010.png" alt="Untitled"></p>]]></content>
      
      
      <categories>
          
          <category> AI </category>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 《深度学习》吴恩达 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《深度学习》 章四 CNN 第3节 目标检测</title>
      <link href="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E5%9B%9B%20CNN%20%E7%AC%AC3%E8%8A%82%20%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%202f9f1f7fe7c94d8cab5de22ac8bfca02/"/>
      <url>/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E5%9B%9B%20CNN%20%E7%AC%AC3%E8%8A%82%20%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%202f9f1f7fe7c94d8cab5de22ac8bfca02/</url>
      
        <content type="html"><![CDATA[<h1 id="章四-CNN-第3节-目标检测"><a href="#章四-CNN-第3节-目标检测" class="headerlink" title="章四 CNN 第3节 目标检测"></a>章四 CNN 第3节 目标检测</h1><h1 id="第3节-目标检测"><a href="#第3节-目标检测" class="headerlink" title="第3节 目标检测"></a>第3节 目标检测</h1><h2 id="3-1-目标定位"><a href="#3-1-目标定位" class="headerlink" title="3.1 目标定位"></a>3.1 <strong>目标定位</strong></h2><p>将继续深入介绍目标定位和目标检测（包含多目标检测）。</p><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E5%9B%9B%20CNN%20%E7%AC%AC3%E8%8A%82%20%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%202f9f1f7fe7c94d8cab5de22ac8bfca02/Untitled.png" alt="Untitled"></p><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E5%9B%9B%20CNN%20%E7%AC%AC3%E8%8A%82%20%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%202f9f1f7fe7c94d8cab5de22ac8bfca02/Untitled%201.png" alt="Untitled"></p><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E5%9B%9B%20CNN%20%E7%AC%AC3%E8%8A%82%20%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%202f9f1f7fe7c94d8cab5de22ac8bfca02/Untitled%202.png" alt="Untitled"></p><h2 id="3-2-特征点检测"><a href="#3-2-特征点检测" class="headerlink" title="3.2  特征点检测"></a>3.2  <strong>特征点检测</strong></h2><p>除了使用矩形区域检测目标类别和位置外，我们还可以仅对<strong>目标的关键特征点坐标进行定位</strong>，这些关键点被称为landmarks。</p><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E5%9B%9B%20CNN%20%E7%AC%AC3%E8%8A%82%20%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%202f9f1f7fe7c94d8cab5de22ac8bfca02/Untitled%203.png" alt="Untitled"></p><h2 id="3-3-目标检测"><a href="#3-3-目标检测" class="headerlink" title="3.3 目标检测"></a>3.3 <strong>目标检测</strong></h2><p>目标检测的一种简单方法是滑动窗算法。这种算法首先在训练样本集上搜集相应的各种目标图片和非目标图片。注意训练集图片尺寸较小，尽量仅包含相应目标，如下图所示：</p><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E5%9B%9B%20CNN%20%E7%AC%AC3%E8%8A%82%20%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%202f9f1f7fe7c94d8cab5de22ac8bfca02/Untitled%204.png" alt="Untitled"></p><p>然后，使用这些训练集构建CNN模型，使得模型有较高的识别率。</p><p>最后，在测试图片上，选择大小适宜的窗口、合适的步进长度，进行从左到右、从上倒下的滑动。每个窗口区域都送入之前构建好的CNN模型进行识别判断。若判断有目标，则此窗口即为目标区域；若判断没有目标，则此窗口为非目标区域。</p><p>滑动窗算法的优点是<strong>原理简单</strong>，且<strong>不需要人为选定目标区域</strong>（<strong>检测出目标的滑动窗即为目标区域</strong>）。但是其<strong>缺点</strong>也很明显，首先<strong>滑动窗的大小和步进长度都需要人为直观设定。滑动窗过小或过大，步进长度过大均会降低目标检测正确率。</strong>而且，<strong>每次滑动窗区域都要进行一次CNN网络计算，如果滑动窗和步进长度较小，整个目标检测的算法运行时间会很长</strong>。所以，滑动窗算法虽然简单，但是<strong>性能不佳，不够快，不够灵活</strong>。</p><h2 id="3-4-卷积的滑动窗口实现"><a href="#3-4-卷积的滑动窗口实现" class="headerlink" title="3.4 卷积的滑动窗口实现"></a>3.4 <strong>卷积的滑动窗口实现</strong></h2><p>也就是把背后的全连接层，转换成了卷积层，这样就不用一个滑动计算一次了，一开始卷积的时候就全部计算下来，然后最后的结果的一个像素就对应一次滑动（这个像素位置的多个通道代表结果）</p><h2 id="3-5-Bounding-Box-Predictions"><a href="#3-5-Bounding-Box-Predictions" class="headerlink" title="3.5 Bounding Box Predictions"></a>3.5 <strong>Bounding Box Predictions</strong></h2><p>滑动窗口算法有时会出现滑动窗不能完全涵盖目标的问题，如下图蓝色窗口所示。</p><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E5%9B%9B%20CNN%20%E7%AC%AC3%E8%8A%82%20%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%202f9f1f7fe7c94d8cab5de22ac8bfca02/Untitled%205.png" alt="Untitled"></p><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E5%9B%9B%20CNN%20%E7%AC%AC3%E8%8A%82%20%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%202f9f1f7fe7c94d8cab5de22ac8bfca02/Untitled%206.png" alt="Untitled"></p><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E5%9B%9B%20CNN%20%E7%AC%AC3%E8%8A%82%20%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%202f9f1f7fe7c94d8cab5de22ac8bfca02/Untitled%207.png" alt="Untitled"></p><h2 id="3-6-Intersection-Over-Union（IOU）"><a href="#3-6-Intersection-Over-Union（IOU）" class="headerlink" title="3.6 Intersection Over Union（IOU）"></a>3.6 <strong>Intersection Over Union（IOU）</strong></h2><p>交并比，IoU，即交集与并集之比，可以用来评价目标检测区域的准确性。</p><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E5%9B%9B%20CNN%20%E7%AC%AC3%E8%8A%82%20%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%202f9f1f7fe7c94d8cab5de22ac8bfca02/Untitled%208.png" alt="Untitled"></p><h2 id="3-7-Non-max-Suppression（NMS）"><a href="#3-7-Non-max-Suppression（NMS）" class="headerlink" title="3.7 Non-max Suppression（NMS）"></a>3.7 <strong>Non-max Suppression（NMS）</strong></h2><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E5%9B%9B%20CNN%20%E7%AC%AC3%E8%8A%82%20%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%202f9f1f7fe7c94d8cab5de22ac8bfca02/Untitled%209.png" alt="Untitled"></p><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E5%9B%9B%20CNN%20%E7%AC%AC3%E8%8A%82%20%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%202f9f1f7fe7c94d8cab5de22ac8bfca02/Untitled%2010.png" alt="Untitled"></p><h2 id="3-8-Anchor-Boxes"><a href="#3-8-Anchor-Boxes" class="headerlink" title="3.8 Anchor Boxes"></a>3.8 <strong>Anchor Boxes</strong></h2><p>一个网格检测多个目标：</p><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E5%9B%9B%20CNN%20%E7%AC%AC3%E8%8A%82%20%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%202f9f1f7fe7c94d8cab5de22ac8bfca02/Untitled%2011.png" alt="Untitled"></p><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E5%9B%9B%20CNN%20%E7%AC%AC3%E8%8A%82%20%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%202f9f1f7fe7c94d8cab5de22ac8bfca02/Untitled%2012.png" alt="Untitled"></p><h2 id="3-9-YOLO-Algorithm"><a href="#3-9-YOLO-Algorithm" class="headerlink" title="3.9 YOLO Algorithm"></a>3.9 <strong>YOLO Algorithm</strong></h2><p>这一节主要介绍YOLO算法的流程，算是对前几节内容的回顾。网络结构如下图所示，包含了两个Anchor Boxes。</p><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E5%9B%9B%20CNN%20%E7%AC%AC3%E8%8A%82%20%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%202f9f1f7fe7c94d8cab5de22ac8bfca02/Untitled%2013.png" alt="Untitled"></p><h2 id="3-10-Region-Proposals"><a href="#3-10-Region-Proposals" class="headerlink" title="3.10 Region Proposals"></a>3.10 <strong>Region Proposals</strong></h2><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E5%9B%9B%20CNN%20%E7%AC%AC3%E8%8A%82%20%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%202f9f1f7fe7c94d8cab5de22ac8bfca02/Untitled%2014.png" alt="Untitled"></p><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E5%9B%9B%20CNN%20%E7%AC%AC3%E8%8A%82%20%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%202f9f1f7fe7c94d8cab5de22ac8bfca02/Untitled%2015.png" alt="Untitled"></p>]]></content>
      
      
      <categories>
          
          <category> AI </category>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 《深度学习》吴恩达 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《深度学习》 章四 CNN 第2节 深度卷积模型案例研究</title>
      <link href="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E5%9B%9B%20CNN%20%E7%AC%AC2%E8%8A%82%20%E6%B7%B1%E5%BA%A6%E5%8D%B7%E7%A7%AF%E6%A8%A1%E5%9E%8B%E6%A1%88%E4%BE%8B%E7%A0%94%E7%A9%B6%20a34cd7d133a74a31a7444319cf1c81ba/"/>
      <url>/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E5%9B%9B%20CNN%20%E7%AC%AC2%E8%8A%82%20%E6%B7%B1%E5%BA%A6%E5%8D%B7%E7%A7%AF%E6%A8%A1%E5%9E%8B%E6%A1%88%E4%BE%8B%E7%A0%94%E7%A9%B6%20a34cd7d133a74a31a7444319cf1c81ba/</url>
      
        <content type="html"><![CDATA[<h1 id="章四-CNN-第2节-深度卷积模型案例研究"><a href="#章四-CNN-第2节-深度卷积模型案例研究" class="headerlink" title="章四 CNN 第2节 深度卷积模型案例研究"></a>章四 CNN 第2节 深度卷积模型案例研究</h1><h1 id="第2节-深度卷积模型案例研究"><a href="#第2节-深度卷积模型案例研究" class="headerlink" title="第2节 深度卷积模型案例研究"></a>第2节 深度卷积模型案例研究</h1><h2 id="1-1-Why-look-at-case-studies"><a href="#1-1-Why-look-at-case-studies" class="headerlink" title="1.1 Why look at case studies"></a>1.1 <strong>Why look at case studies</strong></h2><p>主要介绍几个典型的CNN案例</p><p>典型的CNN模型包括：</p><ul><li><strong>LeNet-5</strong></li><li><strong>AlexNet</strong></li><li><strong>VGG</strong></li></ul><p>除了这些性能良好的CNN模型之外，我们还会介绍Residual Network（ResNet）。其特点是可以构建很深很深的神经网络（目前最深的好像有152层）。</p><p>另外，还会介绍Inception Neural Network。</p><h2 id="1-2-经典网络"><a href="#1-2-经典网络" class="headerlink" title="1.2 经典网络"></a>1.2 经典网络</h2><h3 id="LeNet-5"><a href="#LeNet-5" class="headerlink" title="LeNet-5"></a><strong>LeNet-5</strong></h3><p>LeNet-5模型是Yann LeCun教授于<strong>1998年提出来</strong>的，它是第一个成功应用于数字识别问题的卷积神经网络。在<strong>MNIST</strong>数据中，它的准确率达到大约<strong>99.2%。</strong></p><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E5%9B%9B%20CNN%20%E7%AC%AC2%E8%8A%82%20%E6%B7%B1%E5%BA%A6%E5%8D%B7%E7%A7%AF%E6%A8%A1%E5%9E%8B%E6%A1%88%E4%BE%8B%E7%A0%94%E7%A9%B6%20a34cd7d133a74a31a7444319cf1c81ba/Untitled.png" alt="Untitled"></p><p>该LeNet模型总共包含了大约6万个参数。值得一提的是，当时Yann LeCun提出的LeNet-5模型池化层使用的是average pool，而且各层激活函数一般是Sigmoid和tanh。现在，我们可以根据需要，做出改进，使用max pool和激活函数ReLU。</p><h3 id="AlexNet"><a href="#AlexNet" class="headerlink" title="AlexNet"></a><strong>AlexNet</strong></h3><p>AlexNet模型与LeNet-5模型类似，只是要复杂一些，总共包含了大约6千万个参数。同样可以根据实际情况使用激活函数ReLU。原作者还提到了一种<strong>优化技巧，叫做Local Response Normalization(LRN)。 而在实际应用中，LRN的效果并不突出。</strong></p><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E5%9B%9B%20CNN%20%E7%AC%AC2%E8%8A%82%20%E6%B7%B1%E5%BA%A6%E5%8D%B7%E7%A7%AF%E6%A8%A1%E5%9E%8B%E6%A1%88%E4%BE%8B%E7%A0%94%E7%A9%B6%20a34cd7d133a74a31a7444319cf1c81ba/Untitled%201.png" alt="Untitled"></p><h3 id="VGG-16"><a href="#VGG-16" class="headerlink" title="VGG-16"></a><strong>VGG-16</strong></h3><p>VGG-16模型更加复杂一些，一般情况下，其CONV layer和POOL layer设置如下：</p><ul><li><strong>CONV = 3x3 filters, s = 1, same</strong></li><li><strong>MAX-POOL = 2x2, s = 2</strong></li></ul><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E5%9B%9B%20CNN%20%E7%AC%AC2%E8%8A%82%20%E6%B7%B1%E5%BA%A6%E5%8D%B7%E7%A7%AF%E6%A8%A1%E5%9E%8B%E6%A1%88%E4%BE%8B%E7%A0%94%E7%A9%B6%20a34cd7d133a74a31a7444319cf1c81ba/Untitled%202.png" alt="Untitled"></p><h2 id="1-3-ResNets"><a href="#1-3-ResNets" class="headerlink" title="1.3 ResNets"></a>1.3 <strong>ResNets</strong></h2><p>我们知道，如果神经网络层数越多，网络越深，源于梯度消失和梯度爆炸的影响，整个模型难以训练成功。解决的方法之一是<strong>人为地让神经网络某些层跳过下一层神经元的连接，隔层相连，弱化每层之间的强联系。</strong>这种神经网络被称为Residual Networks(ResNets)。</p><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E5%9B%9B%20CNN%20%E7%AC%AC2%E8%8A%82%20%E6%B7%B1%E5%BA%A6%E5%8D%B7%E7%A7%AF%E6%A8%A1%E5%9E%8B%E6%A1%88%E4%BE%8B%E7%A0%94%E7%A9%B6%20a34cd7d133a74a31a7444319cf1c81ba/Untitled%203.png" alt="Untitled"></p><p>a[l]直接隔层与下一层的线性输出相连，与z[l+2]共同通过激活函数（ReLU）输出a[l+2]。</p><p>该模型由Kaiming He, Xiangyu Zhang, Shaoqing Ren和Jian Sun共同提出。</p><p>由多个Residual block组成的神经网络就是Residual Network。实验表明，这种模型结构对于训练非常深的神经网络，效果很好。另外，为了便于区分，我们把<strong>非Residual Networks称为Plain Network。</strong></p><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E5%9B%9B%20CNN%20%E7%AC%AC2%E8%8A%82%20%E6%B7%B1%E5%BA%A6%E5%8D%B7%E7%A7%AF%E6%A8%A1%E5%9E%8B%E6%A1%88%E4%BE%8B%E7%A0%94%E7%A9%B6%20a34cd7d133a74a31a7444319cf1c81ba/Untitled%204.png" alt="Untitled"></p><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E5%9B%9B%20CNN%20%E7%AC%AC2%E8%8A%82%20%E6%B7%B1%E5%BA%A6%E5%8D%B7%E7%A7%AF%E6%A8%A1%E5%9E%8B%E6%A1%88%E4%BE%8B%E7%A0%94%E7%A9%B6%20a34cd7d133a74a31a7444319cf1c81ba/Untitled%205.png" alt="Untitled"></p><h2 id="1-4-Why-ResNets-Work"><a href="#1-4-Why-ResNets-Work" class="headerlink" title="1.4 Why ResNets Work"></a>1.4 <strong>Why ResNets Work</strong></h2><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E5%9B%9B%20CNN%20%E7%AC%AC2%E8%8A%82%20%E6%B7%B1%E5%BA%A6%E5%8D%B7%E7%A7%AF%E6%A8%A1%E5%9E%8B%E6%A1%88%E4%BE%8B%E7%A0%94%E7%A9%B6%20a34cd7d133a74a31a7444319cf1c81ba/Untitled%206.png" alt="Untitled"></p><p>也就是说,太深了之后,梯度消失,a[l+2]=a[l]了,就相当于identity function.从效果来说，相当于直接忽略了a[l]之后的这两层神经层,实现隔层线性传递。而且从性能上来说，这两层额外的Residual blocks也不会降低Big NN的性能。</p><p>如果维度不同,还可以通过矩阵运算解决.矩阵可以通过训练或者截断或者补0来完成</p><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E5%9B%9B%20CNN%20%E7%AC%AC2%E8%8A%82%20%E6%B7%B1%E5%BA%A6%E5%8D%B7%E7%A7%AF%E6%A8%A1%E5%9E%8B%E6%A1%88%E4%BE%8B%E7%A0%94%E7%A9%B6%20a34cd7d133a74a31a7444319cf1c81ba/Untitled%207.png" alt="Untitled"></p><p>ResNets同类型层之间，例如CONV layers，大多使用same类型，保持维度相同。如果是不同类型层之间的连接，例如CONV layer与POOL layer之间，如果维度不同，则引入矩阵Ws。</p><h2 id="1-5-1x1-Convolutions"><a href="#1-5-1x1-Convolutions" class="headerlink" title="1.5 1x1 Convolutions"></a>1.5 <strong>1x1 Convolutions</strong></h2><p>Min Lin, Qiang Chen等人提出了一种新的CNN结构，即1x1 Convolutions，也称Networks in Networks。这种结构的特点是滤波器算子filter的维度为1x1。对于单个filter，1x1的维度，意味着卷积操作等同于乘积操作。</p><p>1x1 Convolutions可以用来缩减输入图片的通道数目。方法如下图所示</p><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E5%9B%9B%20CNN%20%E7%AC%AC2%E8%8A%82%20%E6%B7%B1%E5%BA%A6%E5%8D%B7%E7%A7%AF%E6%A8%A1%E5%9E%8B%E6%A1%88%E4%BE%8B%E7%A0%94%E7%A9%B6%20a34cd7d133a74a31a7444319cf1c81ba/Untitled%208.png" alt="Untitled"></p><h2 id="1-6-Inception-Network-Motivation"><a href="#1-6-Inception-Network-Motivation" class="headerlink" title="1.6 Inception Network Motivation"></a>1.6 <strong>Inception Network Motivation</strong></h2><p>之前我们介绍的CNN单层的滤波算子filter尺寸是固定的，1x1或者3x3等。而<strong>Inception Network在单层网络上可以使用多个不同尺寸的filters，进行same convolutions</strong>，把各filter<strong>下得到的输出拼接起</strong>来。除此之外，还可以<strong>将CONV layer与POOL layer混合</strong>，同时实现各种效果。但是要注意使用<strong>same pool</strong>。</p><p>Inception Network在提升性能的同时，会带来计算量大的问题。</p><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E5%9B%9B%20CNN%20%E7%AC%AC2%E8%8A%82%20%E6%B7%B1%E5%BA%A6%E5%8D%B7%E7%A7%AF%E6%A8%A1%E5%9E%8B%E6%A1%88%E4%BE%8B%E7%A0%94%E7%A9%B6%20a34cd7d133a74a31a7444319cf1c81ba/Untitled%209.png" alt="Untitled"></p><p>通常我们把该<strong>1x1 Convolution称为“瓶颈层”（bottleneck layer）</strong>。引入bottleneck layer之后，总共需要的计算量为：<strong>28x28x16x192+28x28x32x5x5x16=12.4m</strong>。明显地，虽然多引入了1x1 Convolution层，但是总共的计<strong>算量减少了近90%</strong>，效果还是非常明显的。由此可见，1x1 Convolutions还可以有效减少CONV layer的计算量。</p><h2 id="1-7-Inception-Network"><a href="#1-7-Inception-Network" class="headerlink" title="1.7 Inception Network"></a>1.7 <strong>Inception Network</strong></h2><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E5%9B%9B%20CNN%20%E7%AC%AC2%E8%8A%82%20%E6%B7%B1%E5%BA%A6%E5%8D%B7%E7%A7%AF%E6%A8%A1%E5%9E%8B%E6%A1%88%E4%BE%8B%E7%A0%94%E7%A9%B6%20a34cd7d133a74a31a7444319cf1c81ba/Untitled%2010.png" alt="Untitled"></p><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E5%9B%9B%20CNN%20%E7%AC%AC2%E8%8A%82%20%E6%B7%B1%E5%BA%A6%E5%8D%B7%E7%A7%AF%E6%A8%A1%E5%9E%8B%E6%A1%88%E4%BE%8B%E7%A0%94%E7%A9%B6%20a34cd7d133a74a31a7444319cf1c81ba/Untitled%2011.png" alt="Untitled"></p><h2 id="1-9-Transfer-Learning（略）"><a href="#1-9-Transfer-Learning（略）" class="headerlink" title="1.9 Transfer Learning（略）"></a>1.9 <strong>Transfer Learning（略）</strong></h2><h2 id="1-10-数据增强"><a href="#1-10-数据增强" class="headerlink" title="1.10 数据增强"></a>1.10 数据增强</h2><p>常用的Data Augmentation方法是对已有的样本集进行<strong>Mirroring和Random Cropping。</strong></p><p>镜像\随即裁剪</p><p>另一种Data Augmentation的方法是<strong>color shifting</strong>。color shifting就是对图片的RGB通道数值进行随意增加或者减少，改变图片色调。</p><p>除了随意改变RGB通道数值外，还可以更有针对性地对图片的RGB通道进行<strong>PCA color augmentation</strong>，也就是对<strong>图片颜色进行主成分分析</strong>，对<strong>主要的通道颜色进行增加或减少，可以采用高斯扰动做法。</strong>这样也能增加有效的样本数量。具体的PCA color augmentation做法可以查阅AlexNet的相关论文。</p><h2 id="1-11-State-of-Computer-Vision"><a href="#1-11-State-of-Computer-Vision" class="headerlink" title="1.11 State of Computer Vision"></a>1.11 <strong>State of Computer Vision</strong></h2><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E5%9B%9B%20CNN%20%E7%AC%AC2%E8%8A%82%20%E6%B7%B1%E5%BA%A6%E5%8D%B7%E7%A7%AF%E6%A8%A1%E5%9E%8B%E6%A1%88%E4%BE%8B%E7%A0%94%E7%A9%B6%20a34cd7d133a74a31a7444319cf1c81ba/Untitled%2012.png" alt="Untitled"></p><p>值得一提的是hand-engineering是一项非常重要也比较困难的工作。很多时候，hand-engineering对模型训练效果影响很大，特别是在数据量不多的情况下。</p>]]></content>
      
      
      <categories>
          
          <category> AI </category>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 《深度学习》吴恩达 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《深度学习》 章四 CNN 第1节 卷积神经网络基础</title>
      <link href="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E5%9B%9B%20CNN%20%E7%AC%AC1%E8%8A%82%20%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%20a07096fcfe8c4962a959f6ae51b702e6/"/>
      <url>/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E5%9B%9B%20CNN%20%E7%AC%AC1%E8%8A%82%20%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%20a07096fcfe8c4962a959f6ae51b702e6/</url>
      
        <content type="html"><![CDATA[<h1 id="章四-CNN-第1节-卷积神经网络基础"><a href="#章四-CNN-第1节-卷积神经网络基础" class="headerlink" title="章四 CNN 第1节 卷积神经网络基础"></a>章四 CNN 第1节 卷积神经网络基础</h1><h1 id="第1节-卷积神经网络基础"><a href="#第1节-卷积神经网络基础" class="headerlink" title="第1节 卷积神经网络基础"></a>第1节 卷积神经网络基础</h1><h2 id="1-1-计算机视觉"><a href="#1-1-计算机视觉" class="headerlink" title="1.1 计算机视觉"></a>1.1 计算机视觉</h2><p>机器视觉（Computer Vision）是深度学习应用的主要方向之一。一般的CV问题包括以下三类：</p><ul><li><strong>Image Classification</strong></li><li><strong>Object detection</strong></li><li><strong>Neural Style Transfer</strong></li><li></li></ul><p>使用传统神经网络处理机器视觉的一个主要问题是<code>输入层维度很大</code>。例如一张64x64x3的图片，神经网络输入层的维度为12288。如果图片尺寸较大，例如一张1000x1000x3的图片，神经网络输入层的维度将达到3百万，<strong>使得网络权重W非常庞大</strong>。这样会造成两个后果，</p><p>一是神经网络<strong>结构复杂</strong>，<strong>数据量相对不够</strong>，<strong>容易出现过拟合</strong>；</p><p>二是所需<strong>内存、计算量较大</strong>。</p><p>解决这一问题的方法就是使用卷积神经网络（CNN）。</p><h2 id="1-2-举例：边缘检测"><a href="#1-2-举例：边缘检测" class="headerlink" title="1.2 举例：边缘检测"></a>1.2 举例：边缘检测</h2><p>从边缘检测角度说明卷积作用<br>最常检测的图片边缘有两类：一是垂直边缘（vertical edges），二是水平边缘（horizontal edges）</p><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E5%9B%9B%20CNN%20%E7%AC%AC1%E8%8A%82%20%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%20a07096fcfe8c4962a959f6ae51b702e6/Untitled.png" alt="Untitled"></p><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E5%9B%9B%20CNN%20%E7%AC%AC1%E8%8A%82%20%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%20a07096fcfe8c4962a959f6ae51b702e6/Untitled%201.png" alt="Untitled"></p><h2 id="1-3-更多边缘检测"><a href="#1-3-更多边缘检测" class="headerlink" title="1.3 更多边缘检测"></a>1.3 更多边缘检测</h2><p>图片边缘有两种渐变方式，一种是由明变暗，另一种是由暗变明。以垂直边缘检测为例，下图展示了两种方式的区别。实际应用中，这两种渐变方式并不影响边缘检测结果，可以对输出图片取绝对值操作，得到同样的结果。</p><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E5%9B%9B%20CNN%20%E7%AC%AC1%E8%8A%82%20%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%20a07096fcfe8c4962a959f6ae51b702e6/Untitled%202.png" alt="Untitled"></p><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E5%9B%9B%20CNN%20%E7%AC%AC1%E8%8A%82%20%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%20a07096fcfe8c4962a959f6ae51b702e6/Untitled%203.png" alt="Untitled"></p><p>在深度学习中，如果我们想检测图片的各种边缘特征，而不仅限于垂直边缘和水平边缘，那么filter的数值一般需要通过模型训练得到，类似于标准神经网络中的权重W一样由梯度下降算法反复迭代求得。<strong>CNN的主要目的就是计算出这些filter的数值。确定得到了这些filter后，CNN浅层网络也就实现了对图片所有边缘特征的检测。</strong></p><h2 id="1-4-Padding"><a href="#1-4-Padding" class="headerlink" title="1.4 Padding"></a>1.4 <strong>Padding</strong></h2><p>如果原始图片尺寸为n x n，filter尺寸为f x f，则卷积后的图片尺寸为(n-f+1) x (n-f+1)，注意f一般为奇数。这样会带来两个问题：</p><ul><li><strong>卷积运算后，输出图片尺寸缩小</strong></li><li><strong>原始图片边缘信息对输出贡献得少，输出图片丢失边缘信息</strong></li></ul><p>为了解决图片缩小的问题，可以使用padding方法，即把<strong>原始图片尺寸进行扩展</strong>，<strong>扩展区域补零</strong>，用p来表示每个方向扩展的宽度。</p><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E5%9B%9B%20CNN%20%E7%AC%AC1%E8%8A%82%20%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%20a07096fcfe8c4962a959f6ae51b702e6/Untitled%204.png" alt="Untitled"></p><h2 id="1-5-卷积步长"><a href="#1-5-卷积步长" class="headerlink" title="1.5 卷积步长"></a>1.5 卷积步长</h2><p>Stride表示filter在原图片中水平方向和垂直方向每次的步进长度。之前我们默认stride=1。若stride=2，则表示filter每次步进长度为2，即隔一点移动一次。</p><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E5%9B%9B%20CNN%20%E7%AC%AC1%E8%8A%82%20%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%20a07096fcfe8c4962a959f6ae51b702e6/Untitled%205.png" alt="Untitled"></p><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E5%9B%9B%20CNN%20%E7%AC%AC1%E8%8A%82%20%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%20a07096fcfe8c4962a959f6ae51b702e6/Untitled%206.png" alt="Untitled"></p><p>其实，目前为止我们介绍的CNN卷积实际上计算的是相关系数，而<strong>不是数学意义上的卷积</strong>。但是，<strong>为了简化计算</strong>，我们一般把CNN中的<strong>这种“相关系数”就称作卷积运算。</strong></p><h2 id="1-6-Convolutions-Over-Volume"><a href="#1-6-Convolutions-Over-Volume" class="headerlink" title="1.6 Convolutions Over Volume"></a>1.6 <strong>Convolutions Over Volume</strong></h2><p>对于3通道的RGB图片，其对应的滤波器算子同样也是3通道的。例如一个图片是6 x 6 x 3，分别表示图片的高度（height）、宽度（weight）和通道（#channel）。</p><p><strong>3通道图片的卷积运算与单通道图片的卷积运算基本一致。</strong>过程是将<strong>每个单通道（R，G，B）与对应的filter进行卷积运算求和</strong>，然后再<strong>将3通道的和相加</strong>，得到<strong>输出图片的一个像素值。</strong></p><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E5%9B%9B%20CNN%20%E7%AC%AC1%E8%8A%82%20%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%20a07096fcfe8c4962a959f6ae51b702e6/Untitled%207.png" alt="Untitled"></p><p>不同通道的滤波算子可以不相同。例如R通道filter实现垂直边缘检测，G和B通道不进行边缘检测，全部置零，或者将R，G，B三通道filter全部设置为水平边缘检测。</p><p>为了进行多个卷积运算，实现更多边缘检测，可以增加更多的滤波器组。例如设置第一个滤波器组实现垂直边缘检测，第二个滤波器组实现水平边缘检测。这样，不同滤波器组卷积得到不同的输出，个数由滤波器组决定。</p><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E5%9B%9B%20CNN%20%E7%AC%AC1%E8%8A%82%20%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%20a07096fcfe8c4962a959f6ae51b702e6/Untitled%208.png" alt="Untitled"></p><h2 id="1-7-单层CNN"><a href="#1-7-单层CNN" class="headerlink" title="1.7 单层CNN"></a>1.7 单层CNN</h2><p>卷积神经网络的单层结构如下所示：</p><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E5%9B%9B%20CNN%20%E7%AC%AC1%E8%8A%82%20%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%20a07096fcfe8c4962a959f6ae51b702e6/Untitled%209.png" alt="Untitled"></p><p>我们发现，选定滤波器组后，参数数目与输入图片尺寸无关。所以，就<strong>不存在</strong>由于图片尺寸过大，<strong>造成参数过多的情况</strong>。</p><p><strong>例如</strong>一张1000x1000x3的图片，标准神经网络输入层的维度将达到3百万，而在CNN中，参数数目只由滤波器组决定，数目相对来说要少得多，这是CNN的优势之一。</p><h2 id="1-8-举例：简单CNN"><a href="#1-8-举例：简单CNN" class="headerlink" title="1.8 举例：简单CNN"></a>1.8 举例：简单CNN</h2><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E5%9B%9B%20CNN%20%E7%AC%AC1%E8%8A%82%20%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%20a07096fcfe8c4962a959f6ae51b702e6/Untitled%2010.png" alt="Untitled"></p><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E5%9B%9B%20CNN%20%E7%AC%AC1%E8%8A%82%20%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%20a07096fcfe8c4962a959f6ae51b702e6/Untitled%2011.png" alt="Untitled"></p><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E5%9B%9B%20CNN%20%E7%AC%AC1%E8%8A%82%20%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%20a07096fcfe8c4962a959f6ae51b702e6/Untitled%2012.png" alt="Untitled"></p><h2 id="1-9-Pooling-Layers"><a href="#1-9-Pooling-Layers" class="headerlink" title="1.9 Pooling Layers"></a>1.9 <strong>Pooling Layers</strong></h2><p>Pooling layers是CNN中用来减小尺寸，提高运算速度的，同样能减小noise影响，让各特征更具有健壮性。</p><p>Pooling layers的做法比convolution layers简单许多，没有卷积运算，仅仅是在滤波器算子滑动区域内取最大值，即max pooling，这是最常用的做法。注意，超参数p很少在pooling layers中使用。</p><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E5%9B%9B%20CNN%20%E7%AC%AC1%E8%8A%82%20%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%20a07096fcfe8c4962a959f6ae51b702e6/Untitled%2013.png" alt="Untitled"></p><p><strong>Max pooling的好处是只保留区域内的最大值（特征），忽略其它值，降低noise影响</strong>，提高模型健壮性。而且，max pooling需要的超参数仅为滤波器尺寸f和滤波器步进长度s，没有其他参数需要模型训练得到，计算量很小。</p><p>如果是<strong>多个通道</strong>，那么就<strong>每个通道单独进行max pooling操作。</strong></p><p>除了max pooling之外，还有一种做法：<strong>average pooling</strong>。顾名思义，average pooling就是在滤波器算子滑动区域计算平均值。</p><p><strong>实际应用中，max pooling比average pooling更为常用。</strong></p><h2 id="1-10-CNN-Example"><a href="#1-10-CNN-Example" class="headerlink" title="1.10 CNN Example"></a>1.10 <strong>CNN Example</strong></h2><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E5%9B%9B%20CNN%20%E7%AC%AC1%E8%8A%82%20%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%20a07096fcfe8c4962a959f6ae51b702e6/Untitled%2014.png" alt="Untitled"></p><h2 id="1-11-卷积的好处"><a href="#1-11-卷积的好处" class="headerlink" title="1.11 卷积的好处"></a>1.11 卷积的好处</h2><p>相比标准神经网络，CNN的优势之一就是参数数目要少得多。参数数目少的原因有两个：</p><ul><li><strong>参数共享：一个特征检测器（例如垂直边缘检测）对图片某块区域有用，同时也可能作用在图片其它区域。</strong></li><li><strong>连接的稀疏性：因为滤波器算子尺寸限制，每一层的每个输出只与输入部分区域内有关。</strong></li></ul><p><strong>除此之外，由于CNN参数数目较小，所需的训练样本就相对较少，从而一定程度上不容易发生过拟合现象。</strong>而且，<strong>CNN比较擅长捕捉区域位置偏移</strong>。也就是说CNN进行物体检测时，<strong>不太受物体所处图片位置的影响</strong>，增加检测的准确性和系统的健壮性。</p>]]></content>
      
      
      <categories>
          
          <category> AI </category>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 《深度学习》吴恩达 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《深度学习》 章三 结构化机器学习项目 第2节 机器学习（ML）策略（2）</title>
      <link href="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%B8%89%20%E7%BB%93%E6%9E%84%E5%8C%96%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A1%B9%E7%9B%AE%20%E7%AC%AC2%E8%8A%82%20%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88ML%EF%BC%89%E7%AD%96%E7%95%A5%EF%BC%882%EF%BC%89%20b6e6f76024bd4963a786f06eb751b95b/"/>
      <url>/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%B8%89%20%E7%BB%93%E6%9E%84%E5%8C%96%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A1%B9%E7%9B%AE%20%E7%AC%AC2%E8%8A%82%20%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88ML%EF%BC%89%E7%AD%96%E7%95%A5%EF%BC%882%EF%BC%89%20b6e6f76024bd4963a786f06eb751b95b/</url>
      
        <content type="html"><![CDATA[<h1 id="章三-结构化机器学习项目-第2节-机器学习（ML）策略（2）"><a href="#章三-结构化机器学习项目-第2节-机器学习（ML）策略（2）" class="headerlink" title="章三 结构化机器学习项目 第2节 机器学习（ML）策略（2）"></a>章三 结构化机器学习项目 第2节 机器学习（ML）策略（2）</h1><h1 id="第2节-机器学习（ML）策略（2）"><a href="#第2节-机器学习（ML）策略（2）" class="headerlink" title="第2节 机器学习（ML）策略（2）"></a>第2节 机器学习（ML）策略（2）</h1><h2 id="2-1-进行误差分析"><a href="#2-1-进行误差分析" class="headerlink" title="2.1 进行误差分析"></a>2.1 <strong>进行误差分析</strong></h2><p>举个例子，猫类识别问题，已经建立的模型的错误率为10%。为了提高正确率，<strong>我们发现该模型会将一些狗类图片错误分类成猫。一种常规解决办法是扩大狗类样本，增强模型对够类（负样本）的训练。</strong>但是，这一过程可能会<strong>花费几个月的时间，耗费这么大的时间成本到底是否值得呢？</strong>也就是说扩大狗类样本，重新训练模型，对提高模型准确率到底有多大作用？这时候我们就需要进行<strong>error analysis</strong>，帮助我们做出判断。</p><p>方法很简单，我们可以从<strong>分类错误的样本中统计出狗类的样本数量</strong>。根据狗类样本所占的比重，判断这一问题的重要性。假如狗类样本所占<strong>比重仅为5%</strong>，即时我们花费几个月的时间扩大狗类样本，<strong>提升模型对其识别率</strong>，改进后的模型错误率最多只会降低到<strong>9.5%。相比之前的10%，并没有显著改善。</strong>我们把这种性能限制称为<strong>ceiling on performance</strong>。相反，假如错误样本中狗类所占<strong>比重为50%</strong>，那么改进后的模型错误率<strong>有望降低到5%，性能改善很大</strong>。因此，<strong>值得去</strong>花费更多的时间扩大狗类样本。</p><p>这种<strong>error analysis虽然简单，但是能够避免花费大量的时间精力去做一些对提高模型性能收效甚微的工作</strong>，让我们专注解决影响模型正确率的主要问题，十分必要。</p><p>这种error analysis可以同时评估多个影响模型性能的因素，通过各自在错误样本中所占的比例来判断其重要性。例如，猫类识别模型中，可能有以下几个影响因素：</p><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%B8%89%20%E7%BB%93%E6%9E%84%E5%8C%96%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A1%B9%E7%9B%AE%20%E7%AC%AC2%E8%8A%82%20%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88ML%EF%BC%89%E7%AD%96%E7%95%A5%EF%BC%882%EF%BC%89%20b6e6f76024bd4963a786f06eb751b95b/Untitled.png" alt="Untitled"></p><p>通常来说，<strong>比例越大，影响越大，越应该花费时间和精力着重解决这一问题</strong>。这种error analysis让我们改进模型更加有针对性，从而提高效率。</p><h2 id="2-2-清楚标注错误的数据"><a href="#2-2-清楚标注错误的数据" class="headerlink" title="2.2 清楚标注错误的数据"></a>2.2 <strong>清楚标注错误的数据</strong></h2><p>监督式学习中，训练样本有时候会出现输出y标注错误的情况，即<strong>incorrectly labeled examples。</strong></p><p>如果这些label标错的情况是随机性的，一般可以直接忽略，无需修复。然而，如果是<strong>系统错误（一直有人标错了）</strong>，这将降低模型性能。</p><p><strong>处理方法</strong></p><p>忽略或者处理</p><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%B8%89%20%E7%BB%93%E6%9E%84%E5%8C%96%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A1%B9%E7%9B%AE%20%E7%AC%AC2%E8%8A%82%20%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88ML%EF%BC%89%E7%AD%96%E7%95%A5%EF%BC%882%EF%BC%89%20b6e6f76024bd4963a786f06eb751b95b/Untitled%201.png" alt="Untitled"></p><h2 id="2-3-快速搭建你的第一个系统，并进行迭代"><a href="#2-3-快速搭建你的第一个系统，并进行迭代" class="headerlink" title="2.3 快速搭建你的第一个系统，并进行迭代"></a>2.3 <strong>快速搭建你的第一个系统，并进行迭代</strong></h2><p>对于如何构建一个机器学习应用模型，Andrew给出的建议是先快速构建第一个简单模型，然后再反复迭代优化。</p><h2 id="2-4-在不同的划分上进行训练并测试"><a href="#2-4-在不同的划分上进行训练并测试" class="headerlink" title="2.4 在不同的划分上进行训练并测试"></a>2.4 <strong>在不同的划分上进行训练并测试</strong></h2><p>以猫类识别为例，train set来自于网络下载（webpages），图片比较清晰；dev/test set来自用户手机拍摄（mobile app），图片比较模糊。假如train set的大小为200000，而dev/test set的大小为10000，显然train set要远远大于dev/test set。</p><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%B8%89%20%E7%BB%93%E6%9E%84%E5%8C%96%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A1%B9%E7%9B%AE%20%E7%AC%AC2%E8%8A%82%20%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88ML%EF%BC%89%E7%AD%96%E7%95%A5%EF%BC%882%EF%BC%89%20b6e6f76024bd4963a786f06eb751b95b/Untitled%202.png" alt="Untitled"></p><p><strong>第一种方法</strong>是将train set和dev/test set完全混合，然后在随机选择一部分作为train set，另一部分作为dev/test set。</p><p><strong>第二种方法</strong>是将原来的train set和一部分dev/test set组合当成train set，剩下的dev/test set分别作为dev set和test set。</p><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%B8%89%20%E7%BB%93%E6%9E%84%E5%8C%96%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A1%B9%E7%9B%AE%20%E7%AC%AC2%E8%8A%82%20%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88ML%EF%BC%89%E7%AD%96%E7%95%A5%EF%BC%882%EF%BC%89%20b6e6f76024bd4963a786f06eb751b95b/Untitled%203.png" alt="Untitled"></p><h2 id="2-5-不匹配数据划分的偏差和方差"><a href="#2-5-不匹配数据划分的偏差和方差" class="headerlink" title="2.5 不匹配数据划分的偏差和方差"></a>2.5 <strong>不匹配数据划分的偏差和方差</strong></h2><p>根据<strong>human-level error、training error和dev error的相对值可以判定是否出现了bias或者variance。</strong>但是，<strong>如果train set和dev/test set来源于不同分布，则无法直接根据相对值大小来判断</strong>。例如某个模型<strong>human-level error为0%，training error为1%，dev error为10%。</strong>根据我们之前的理解，显然该模型出现了variance。但是，<strong>training error与dev error之间的差值9%可能来自算法本身（variance），也可能来自于样本分布不同。</strong>比如dev set都是很模糊的图片样本，本身就难以识别，跟算法模型关系不大。因此不能简单认为出现了variance。</p><p>在可能伴有train set与dev/test set分布不一致的情况下，<strong>定位是否出现variance的方法是设置train-dev set</strong>。<strong>从原来的train set中分割出一部分作为train-dev set，train-dev set不作为训练模型使用，不进行后向传播，而是与dev set一样用于验证。</strong></p><p>这样就有<strong>training error、training-dev error和dev error三种error。</strong>其中，<strong>training error与training-dev error的差值反映了variance；training-dev error与dev error的差值反映了data mismatch problem，即样本分布不一致。</strong></p><p>举例说明，<strong>如果training error为1%，training-dev error为9%，dev error为10%，则variance问题比较突出</strong>。<strong>如果training error为1%，training-dev error为1.5%，dev error为10%，则data mismatch problem比较突出</strong>。通过引入train-dev set，能够比较<strong>准确地定位出现了variance还是data mismatch。</strong></p><p>总结一下human-level error、training error、training-dev error、dev error以及test error之间的差值关系和反映的问题：</p><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%B8%89%20%E7%BB%93%E6%9E%84%E5%8C%96%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A1%B9%E7%9B%AE%20%E7%AC%AC2%E8%8A%82%20%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88ML%EF%BC%89%E7%AD%96%E7%95%A5%EF%BC%882%EF%BC%89%20b6e6f76024bd4963a786f06eb751b95b/Untitled%204.png" alt="Untitled"></p><p>一般情况下，human-level error、training error、training-dev error、dev error以及test error的数值是递增的，但是也会出现dev error和test error下降的情况。这主要可能是因为训练样本比验证/测试样本更加复杂，难以训练。</p><h2 id="2-6-定位数据不匹配"><a href="#2-6-定位数据不匹配" class="headerlink" title="2.6 定位数据不匹配"></a>2.6 <strong>定位数据不匹配</strong></h2><p>为了让train set与dev/test set类似，我们可以使用<strong>人工数据合成</strong>的方法。例如<strong>说话人识别问题</strong>，<strong>实际应用场合（dev/test set）是包含背景噪声</strong>的，而训练样本train set很可能没有背景噪声。为了让train set与dev/test set分布一致，我们可以<strong>在train set上人工添加背景噪声</strong>，合成类似实际场景的声音。这样会让模型训练的效果更准确。但是，需要注意的是，我们<strong>不能给每段语音都增加同一段背景噪声</strong>，这样会出现对<strong>背景噪音的过拟合</strong>，效果不佳。这就是人工数据合成需要注意的地方。</p><h2 id="2-7-迁移学习"><a href="#2-7-迁移学习" class="headerlink" title="2.7 迁移学习"></a>2.7 <strong>迁移学习</strong></h2><p>深度学习非常强大的一个功能之一就是有时候你可以将<strong>已经训练好的模型的一部分知识（网络结构）直接应用到另一个类似模型中去</strong>。比如一个已经训练好的<strong>猫类识别</strong>的神经网络模型，可以直接把<strong>该模型中的一部分网络结构应用到使用X光片预测疾病</strong>的模型中去。这种学习方法被称为迁移学习</p><p>迁移学习的做法是无需重新构建新的模型，而是利用之前的神经网络模型，<strong>只改变样本输入、输出</strong>以及<strong>输出层的权重系数</strong>。也就是说对新的样本(X,Y)，重新训练输出层权重系数</p><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%B8%89%20%E7%BB%93%E6%9E%84%E5%8C%96%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A1%B9%E7%9B%AE%20%E7%AC%AC2%E8%8A%82%20%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88ML%EF%BC%89%E7%AD%96%E7%95%A5%EF%BC%882%EF%BC%89%20b6e6f76024bd4963a786f06eb751b95b/Untitled%205.png" alt="Untitled"></p><p>迁移学习需要重新训练权重系数，如果<strong>新模型的样本数量较少，那么只训练输出层的权重系数，保持其它层所有的权重系数不变</strong>。如果样本<strong>数量足够多</strong>，那么也可以<strong>只保留网络结构，重新训练所有层的权重系数</strong>。这种做法使得模型更加精确，因为毕竟样本对模型的影响最大。选<strong>择哪种方法通常由数据量决定。</strong></p><h3 id="预训练"><a href="#预训练" class="headerlink" title="预训练"></a><strong>预训练</strong></h3><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%B8%89%20%E7%BB%93%E6%9E%84%E5%8C%96%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A1%B9%E7%9B%AE%20%E7%AC%AC2%E8%8A%82%20%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88ML%EF%BC%89%E7%AD%96%E7%95%A5%EF%BC%882%EF%BC%89%20b6e6f76024bd4963a786f06eb751b95b/Untitled%206.png" alt="Untitled"></p><h3 id="为什么可以这么做"><a href="#为什么可以这么做" class="headerlink" title="为什么可以这么做"></a><strong>为什么可以这么做</strong></h3><p>迁移学习之所以能这么做的原因是，神经网络<strong>浅层部分能够检测出许多图片固有特征</strong>，例如<strong>图像边缘、曲线等</strong>。使用之前训练好的神经网络部分结果<strong>有助于我们更快更准确地提取X光片特征</strong>。二者处理的都是图片，而图片处理是有相同的地方，第一个训练好的神经网络已经帮我们实现如何提取图片有用特征了。 因此，即便是即将训练的第二个神经网络样本数目少，仍然可以根据第一个神经网络结构和权重系数得到健壮性好的模型。</p><p><strong>迁移学习可以保留原神经网络的一部分，再添加新的网络层。</strong>具体问题，具体分析，可以去掉输出层后再增加额外一些神经层。</p><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%B8%89%20%E7%BB%93%E6%9E%84%E5%8C%96%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A1%B9%E7%9B%AE%20%E7%AC%AC2%E8%8A%82%20%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88ML%EF%BC%89%E7%AD%96%E7%95%A5%EF%BC%882%EF%BC%89%20b6e6f76024bd4963a786f06eb751b95b/Untitled%207.png" alt="Untitled"></p><h2 id="2-8-多任务学习"><a href="#2-8-多任务学习" class="headerlink" title="2.8 多任务学习"></a>2.8 <strong>多任务学习</strong></h2><p>多任务学习类似将<strong>多个神经网络融合在一起</strong>，用<strong>一个网络模型来实现多种分类</strong>效果。</p><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%B8%89%20%E7%BB%93%E6%9E%84%E5%8C%96%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A1%B9%E7%9B%AE%20%E7%AC%AC2%E8%8A%82%20%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88ML%EF%BC%89%E7%AD%96%E7%95%A5%EF%BC%882%EF%BC%89%20b6e6f76024bd4963a786f06eb751b95b/Untitled%208.png" alt="Untitled"></p><h2 id="2-9-什么是端到端的深度学习"><a href="#2-9-什么是端到端的深度学习" class="headerlink" title="2.9 什么是端到端的深度学习"></a>2.9 <strong>什么是端到端的深度学习</strong></h2><p>端到端（end-to-end）深度学习就是将所有不同阶段的数据处理系统或学习系统模块组合在一起，用一个单一的神经网络模型来实现所有的功能。它将所有模块混合在一起，只关心输入和输出。</p><p>以语音识别为例，传统的算法流程和end-to-end模型的区别如下：</p><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%B8%89%20%E7%BB%93%E6%9E%84%E5%8C%96%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A1%B9%E7%9B%AE%20%E7%AC%AC2%E8%8A%82%20%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88ML%EF%BC%89%E7%AD%96%E7%95%A5%EF%BC%882%EF%BC%89%20b6e6f76024bd4963a786f06eb751b95b/Untitled%209.png" alt="Untitled"></p><p>如果<strong>训练样本足够大</strong>，<strong>神经网络模型足够复杂</strong>，<strong>那么end-to-end模型性能比传统机器学习分块模型更好。</strong>实际上，end-to-end让神经网络模<strong>型内部去自我训练模型特征</strong>，自我调节，增加了模型整体契合度。</p><h2 id="2-10-是否要使用端到端的深度学习"><a href="#2-10-是否要使用端到端的深度学习" class="headerlink" title="2.10 是否要使用端到端的深度学习"></a>2.10 <strong>是否要使用端到端的深度学习</strong></h2><p>end-to-end深度学习有优点也有缺点。</p><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%B8%89%20%E7%BB%93%E6%9E%84%E5%8C%96%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A1%B9%E7%9B%AE%20%E7%AC%AC2%E8%8A%82%20%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88ML%EF%BC%89%E7%AD%96%E7%95%A5%EF%BC%882%EF%BC%89%20b6e6f76024bd4963a786f06eb751b95b/Untitled%2010.png" alt="Untitled"></p>]]></content>
      
      
      <categories>
          
          <category> AI </category>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 《深度学习》吴恩达 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《深度学习》 章三 结构化机器学习项目 第1节 机器学习（ML）策略（1）</title>
      <link href="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%B8%89%20%E7%BB%93%E6%9E%84%E5%8C%96%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A1%B9%E7%9B%AE%20%E7%AC%AC1%E8%8A%82%20%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88ML%EF%BC%89%E7%AD%96%E7%95%A5%EF%BC%881%EF%BC%89%208e49e5fb193f4c34b987a182d58cb421/"/>
      <url>/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%B8%89%20%E7%BB%93%E6%9E%84%E5%8C%96%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A1%B9%E7%9B%AE%20%E7%AC%AC1%E8%8A%82%20%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88ML%EF%BC%89%E7%AD%96%E7%95%A5%EF%BC%881%EF%BC%89%208e49e5fb193f4c34b987a182d58cb421/</url>
      
        <content type="html"><![CDATA[<h1 id="章三-结构化机器学习项目-第1节-机器学习（ML）策略（1）"><a href="#章三-结构化机器学习项目-第1节-机器学习（ML）策略（1）" class="headerlink" title="章三 结构化机器学习项目 第1节 机器学习（ML）策略（1）"></a>章三 结构化机器学习项目 第1节 机器学习（ML）策略（1）</h1><h1 id="第1节-机器学习（ML）策略（1）"><a href="#第1节-机器学习（ML）策略（1）" class="headerlink" title="第1节 机器学习（ML）策略（1）"></a>第1节 机器学习（ML）策略（1）</h1><h2 id="1-1-Why-ML-Strategy"><a href="#1-1-Why-ML-Strategy" class="headerlink" title="1.1 Why ML Strategy"></a>1.1 <strong>Why ML Strategy</strong></h2><p>当我们最初得到一个深度神经网络模型时，我们可能希望从很多方面来对它进行优化，例如：</p><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%B8%89%20%E7%BB%93%E6%9E%84%E5%8C%96%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A1%B9%E7%9B%AE%20%E7%AC%AC1%E8%8A%82%20%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88ML%EF%BC%89%E7%AD%96%E7%95%A5%EF%BC%881%EF%BC%89%208e49e5fb193f4c34b987a182d58cb421/Untitled.png" alt="Untitled"></p><h2 id="1-2-正交化"><a href="#1-2-正交化" class="headerlink" title="1.2 正交化"></a>1.2 <strong>正交化</strong></h2><p>通过每次只调试一个参数，保持其它参数不变，使模型某一性能改变是一种最常用的调参策略，也就是正交化方法。</p><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%B8%89%20%E7%BB%93%E6%9E%84%E5%8C%96%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A1%B9%E7%9B%AE%20%E7%AC%AC1%E8%8A%82%20%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88ML%EF%BC%89%E7%AD%96%E7%95%A5%EF%BC%881%EF%BC%89%208e49e5fb193f4c34b987a182d58cb421/Untitled%201.png" alt="Untitled"></p><p>换验证集，使用新的cost function来实现。概括来说，每一种“功能”对应不同的调节方法。而这些调节方法（旋钮）只会对应一个“功能”，是正交的。</p><p>顺便提一下，<strong>early stopping在模型功能调试中并不推荐使用。</strong>因为early stopping在提升验证集性能的同时降低了训练集的性能。也就是说early stopping同时影响两个“功能”，不具有独立性、正交性。</p><h2 id="1-3-单一数字评估指标"><a href="#1-3-单一数字评估指标" class="headerlink" title="1.3 单一数字评估指标"></a>1.3 <strong>单一数字评估指标</strong></h2><p><strong>查准率Precision</strong>：如果你的分类器（猫）认为该图片是猫，有一定的概率是正确的，这个概率就是查准率。</p><p><strong>查全率Recall：</strong>在所有为猫的图片中，成功识别出多少。</p><p>不推荐使用这两个来判断模型优劣，需要一个结合二者的指标，也就是F1 score。</p><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%B8%89%20%E7%BB%93%E6%9E%84%E5%8C%96%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A1%B9%E7%9B%AE%20%E7%AC%AC1%E8%8A%82%20%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88ML%EF%BC%89%E7%AD%96%E7%95%A5%EF%BC%881%EF%BC%89%208e49e5fb193f4c34b987a182d58cb421/Untitled%202.png" alt="Untitled"></p><h2 id="1-4-满足和优化指标"><a href="#1-4-满足和优化指标" class="headerlink" title="1.4 满足和优化指标"></a>1.4 <strong>满足和优化指标</strong></h2><p>有时候，要把所有的性能指标都综合在一起，构成单值评价指标是比较困难的。解决办法是，我们可以把某些性能作为<strong>优化指标</strong>（Optimizing metic），<strong>寻求最优化值，越优越好</strong>；而某些性能作为<strong>满意指标</strong>（Satisficing metic），<strong>只要满足阈值就行了。</strong></p><h2 id="1-5-训练-开发-测试集划分"><a href="#1-5-训练-开发-测试集划分" class="headerlink" title="1.5 训练/开发/测试集划分"></a>1.5 <strong>训练/开发/测试集划分</strong></h2><p>原则上应该尽量<strong>保证dev sets和test sets来源于同一分布</strong>且<strong>都反映了实际样本的情况</strong>。如果dev sets和test sets不来自同一分布，那么我们从dev sets上选择的“最佳”模型往往不能够在test sets上表现得很好。这就好比我们在dev sets上找到最接近一个靶的靶心的箭，但是我们test sets提供的靶心却远远偏离dev sets上的靶心，结果这支肯定无法射中test sets上的靶心位置。</p><h2 id="1-6-开发集和测试集的大小"><a href="#1-6-开发集和测试集的大小" class="headerlink" title="1.6 开发集和测试集的大小"></a>1.6 <strong>开发集和测试集的大小</strong></h2><p>当样本<strong>数量不多（小于一万）的时候</strong>，通常将Train/dev/test sets的比例设为<strong>60%/20%/20%</strong>，在没有dev sets的情况下，<strong>Train/test sets的比例设为70%/30%</strong>。当样本<strong>数量很大（百万级别）的时候</strong>，通常将<strong>相应的比例设为98%/1%/1%或者99%/1%。</strong></p><p>实际应用中，可能只有train/dev sets，而没有test sets。<strong>这种情况也是允许的，只要算法模型没有对dev sets过拟合。</strong>但是，条件允许的话，最好是<strong>有test sets，实现无偏估计。</strong></p><h2 id="1-7-什么时候该改变开发-测试集和指标"><a href="#1-7-什么时候该改变开发-测试集和指标" class="headerlink" title="1.7 什么时候该改变开发/测试集和指标"></a>1.7 <strong>什么时候该改变开发/测试集和指标</strong></h2><p>举个猫类识别的例子。初始的评价标准是错误率，算法A错误率为3%，算法B错误率为5%。<strong>显然，A更好一些</strong>。<strong>但是，实际使用时发现算法A会误识别一些图片当做是猫，但是B没有出现这种情况。从用户的角度来说，他们可能更倾向选择B模型</strong>，虽然B的错误率高一些。这时候，<strong>就需要改变之前的评价标准。例如增加其他图片的权重，增加其代价。</strong></p><p><strong>机器学习的两个过程</strong></p><p>概括来说，机器学习可分为两个过程：</p><p>第一步是<strong>找靶心</strong>，第二步是<strong>通过训练，射中靶心</strong>。但是在训练的过程中可能会根据实际情况改变算法模型的评价标准，进行动态调整。</p><h2 id="1-8-为什么是人的表现"><a href="#1-8-为什么是人的表现" class="headerlink" title="1.8 为什么是人的表现"></a>1.8 <strong>为什么是人的表现</strong></h2><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%B8%89%20%E7%BB%93%E6%9E%84%E5%8C%96%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A1%B9%E7%9B%AE%20%E7%AC%AC1%E8%8A%82%20%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88ML%EF%BC%89%E7%AD%96%E7%95%A5%EF%BC%881%EF%BC%89%208e49e5fb193f4c34b987a182d58cb421/Untitled%203.png" alt="Untitled"></p><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%B8%89%20%E7%BB%93%E6%9E%84%E5%8C%96%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A1%B9%E7%9B%AE%20%E7%AC%AC1%E8%8A%82%20%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88ML%EF%BC%89%E7%AD%96%E7%95%A5%EF%BC%881%EF%BC%89%208e49e5fb193f4c34b987a182d58cb421/Untitled%204.png" alt="Untitled"></p><h2 id="1-9-可避免偏差"><a href="#1-9-可避免偏差" class="headerlink" title="1.9 可避免偏差"></a>1.9 <strong>可避免偏差</strong></h2><p>实际应用中，要看human-level error，training error和dev error的相对值。例如猫类识别的例子中，如果<strong>human-level error为1%，training error为8%，dev error为10%</strong>。由于<strong>training error与human-level error相差7%，dev error与training error只相差2%，所以目标是尽量在训练过程中减小training error，即减小偏差bias</strong>。如果图片很模糊，肉眼也看不太清，<strong>human-level error提高到7.5%。这时，由于training error与human-level error只相差0.5%，dev error与training error只相差2%，所以目标是尽量在训练过程中减小dev error，即方差variance。</strong>这是相对而言的。实际应用中，我们一般会用human-level error代表bayes optimal error。</p><p><strong>training error与human-level error之间的差值称为bias</strong>，也称作<strong>avoidable bias</strong>；把dev error与training error之间的差值称为variance。根据bias和variance值的相对大小，可以知道算法模型<strong>是否发生了欠拟合或者过拟合</strong>。增加训练时间 , 使用较大的网络结构 , 尝试更先进的优化算法(如Adam) , 或者修改网络结构(可能有效可能无效)可以<strong>减小偏差</strong>；采用更多的数据 , 其次使用正则化(Dropout, Batch Normzation , L1 , L2等等…) , 修改网络结构(可能有效可能无效 , 也可能同时减少方差和偏差)可以<strong>减小方差。</strong></p><h2 id="1-10-理解人的表现"><a href="#1-10-理解人的表现" class="headerlink" title="1.10 理解人的表现"></a>1.10 <strong>理解人的表现</strong></h2><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%B8%89%20%E7%BB%93%E6%9E%84%E5%8C%96%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A1%B9%E7%9B%AE%20%E7%AC%AC1%E8%8A%82%20%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88ML%EF%BC%89%E7%AD%96%E7%95%A5%EF%BC%881%EF%BC%89%208e49e5fb193f4c34b987a182d58cb421/Untitled%205.png" alt="Untitled"></p><h2 id="1-11-超过人的表现"><a href="#1-11-超过人的表现" class="headerlink" title="1.11 超过人的表现"></a>1.11 <strong>超过人的表现</strong></h2><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%B8%89%20%E7%BB%93%E6%9E%84%E5%8C%96%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A1%B9%E7%9B%AE%20%E7%AC%AC1%E8%8A%82%20%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88ML%EF%BC%89%E7%AD%96%E7%95%A5%EF%BC%881%EF%BC%89%208e49e5fb193f4c34b987a182d58cb421/Untitled%206.png" alt="Untitled"></p><h2 id="1-12-改善模型表现"><a href="#1-12-改善模型表现" class="headerlink" title="1.12 改善模型表现"></a>1.12 <strong>改善模型表现</strong></h2><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%B8%89%20%E7%BB%93%E6%9E%84%E5%8C%96%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A1%B9%E7%9B%AE%20%E7%AC%AC1%E8%8A%82%20%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88ML%EF%BC%89%E7%AD%96%E7%95%A5%EF%BC%881%EF%BC%89%208e49e5fb193f4c34b987a182d58cb421/Untitled%207.png" alt="Untitled"></p>]]></content>
      
      
      <categories>
          
          <category> AI </category>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 《深度学习》吴恩达 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《深度学习》 章二 优化深度学习 第3节 超参数调试，BN和程序框架（略）</title>
      <link href="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%BA%8C%20%E4%BC%98%E5%8C%96%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%20%E7%AC%AC3%E8%8A%82%20%E8%B6%85%E5%8F%82%E6%95%B0%E8%B0%83%E8%AF%95%EF%BC%8CBN%E5%92%8C%E7%A8%8B%E5%BA%8F%E6%A1%86%E6%9E%B6%20acd7f86a6c2f4d0ea0dfe7e6b81fe8f8/"/>
      <url>/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%BA%8C%20%E4%BC%98%E5%8C%96%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%20%E7%AC%AC3%E8%8A%82%20%E8%B6%85%E5%8F%82%E6%95%B0%E8%B0%83%E8%AF%95%EF%BC%8CBN%E5%92%8C%E7%A8%8B%E5%BA%8F%E6%A1%86%E6%9E%B6%20acd7f86a6c2f4d0ea0dfe7e6b81fe8f8/</url>
      
        <content type="html"><![CDATA[<h1 id="章二-优化深度学习-第3节-超参数调试，BN和程序框架"><a href="#章二-优化深度学习-第3节-超参数调试，BN和程序框架" class="headerlink" title="章二 优化深度学习 第3节 超参数调试，BN和程序框架"></a>章二 优化深度学习 第3节 超参数调试，BN和程序框架</h1><h1 id="第三节-超参数调试，BN和程序框架"><a href="#第三节-超参数调试，BN和程序框架" class="headerlink" title="第三节 超参数调试，BN和程序框架"></a>第三节 超参数调试，BN和程序框架</h1>]]></content>
      
      
      <categories>
          
          <category> AI </category>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 《深度学习》吴恩达 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《深度学习》 章二 优化深度学习 第2节 优化算法</title>
      <link href="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%BA%8C%20%E4%BC%98%E5%8C%96%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%20%E7%AC%AC2%E8%8A%82%20%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95%20a2e120fa16b74b619ae341d73009fd9d/"/>
      <url>/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%BA%8C%20%E4%BC%98%E5%8C%96%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%20%E7%AC%AC2%E8%8A%82%20%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95%20a2e120fa16b74b619ae341d73009fd9d/</url>
      
        <content type="html"><![CDATA[<h1 id="章二-优化深度学习-第2节-优化算法"><a href="#章二-优化深度学习-第2节-优化算法" class="headerlink" title="章二 优化深度学习 第2节 优化算法"></a>章二 优化深度学习 第2节 优化算法</h1><h1 id="第2节-优化算法"><a href="#第2节-优化算法" class="headerlink" title="第2节 优化算法"></a>第2节 优化算法</h1><h2 id="2-1-Mini-batch梯度下降法"><a href="#2-1-Mini-batch梯度下降法" class="headerlink" title="2.1 Mini-batch梯度下降法"></a>2.1 <strong>Mini-batch梯度下降法</strong></h2><p>深度学习（Deep Learning）就是更复杂的神经网络（Neural Network）</p><p>那么，什么是神经网络呢？下面我们将通过一个简单的例子来引入神经网络模型的概念。</p><h3 id="建立房价的预测模型："><a href="#建立房价的预测模型：" class="headerlink" title="建立房价的预测模型："></a><strong>建立房价的预测模型：</strong></h3><p><strong>神经元</strong></p><h2 id="2-2-理解Mini-batch梯度下降法"><a href="#2-2-理解Mini-batch梯度下降法" class="headerlink" title="2.2 理解Mini-batch梯度下降法"></a>2.2 <strong>理解Mini-batch梯度下降法</strong></h2><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%BA%8C%20%E4%BC%98%E5%8C%96%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%20%E7%AC%AC2%E8%8A%82%20%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95%20a2e120fa16b74b619ae341d73009fd9d/Untitled.png" alt="Untitled"></p><p>对于一般的神经网络模型，使用Batch gradient descent，随着迭代次数增加，cost是不断减小的。然而，使用Mini-batch gradient descent，随着在不同的mini-batch上迭代训练，其cost不是单调下降，而是出现<strong>振荡</strong>。<strong>但整体的趋势是下降的，最终也能得到较低的cost值。</strong></p><p>之所以出现细微振荡的原因是不同的mini-batch之间是有差异的。</p><p>Batch gradient descent会比较<strong>平稳地接近全局最小值</strong>，但是因为使用了所有m个样本，每次<strong>前进的速度有些慢</strong>。<strong>随机梯度下降每次前进速度很快</strong>，但是<strong>路线曲折，有较大的振荡，不会收敛</strong>，最终会在最小值附近来回波动，<strong>难以真正达到最小值处</strong>。虽然可以<strong>通过降低学习率来减少噪声</strong>，但在数值处理上不能使用向量化的方法来提高运算速度。</p><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%BA%8C%20%E4%BC%98%E5%8C%96%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%20%E7%AC%AC2%E8%8A%82%20%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95%20a2e120fa16b74b619ae341d73009fd9d/Untitled%201.png" alt="Untitled"></p><h2 id="2-3-指数加权平均"><a href="#2-3-指数加权平均" class="headerlink" title="2.3 指数加权平均"></a>2.3 <strong>指数加权平均</strong></h2><p><strong>举个例子</strong></p><p>记录半年内伦敦市的气温变化，并在二维平面上绘制出来，如下图所示：</p><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%BA%8C%20%E4%BC%98%E5%8C%96%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%20%E7%AC%AC2%E8%8A%82%20%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95%20a2e120fa16b74b619ae341d73009fd9d/Untitled%202.png" alt="Untitled"></p><p>看上去，温度数据似乎有noise，而且抖动较大。如果我们希望看到半年内气温的整体变化趋势，可以通过移动平均（moving average）的方法来对每天气温进行平滑处理。</p><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%BA%8C%20%E4%BC%98%E5%8C%96%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%20%E7%AC%AC2%E8%8A%82%20%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95%20a2e120fa16b74b619ae341d73009fd9d/Untitled%203.png" alt="Untitled"></p><p><strong>计算公式</strong></p><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%BA%8C%20%E4%BC%98%E5%8C%96%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%20%E7%AC%AC2%E8%8A%82%20%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95%20a2e120fa16b74b619ae341d73009fd9d/Untitled%204.png" alt="Untitled"></p><p><strong>如何得到天数</strong></p><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%BA%8C%20%E4%BC%98%E5%8C%96%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%20%E7%AC%AC2%E8%8A%82%20%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95%20a2e120fa16b74b619ae341d73009fd9d/Untitled%205.png" alt="Untitled"></p><h2 id="2-4-理解指数加权平均"><a href="#2-4-理解指数加权平均" class="headerlink" title="2.4 理解指数加权平均"></a>2.4 <strong>理解指数加权平均</strong></h2><p>将原始数据值与衰减指数点乘，相当于做了指数衰减，离得越近，影响越大，离得越远，影响越小，衰减越厉害。</p><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%BA%8C%20%E4%BC%98%E5%8C%96%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%20%E7%AC%AC2%E8%8A%82%20%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95%20a2e120fa16b74b619ae341d73009fd9d/Untitled%206.png" alt="Untitled"></p><h2 id="2-5-指数加权平均的修正"><a href="#2-5-指数加权平均的修正" class="headerlink" title="2.5 指数加权平均的修正"></a>2.5 <strong>指数加权平均的修正</strong></h2><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%BA%8C%20%E4%BC%98%E5%8C%96%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%20%E7%AC%AC2%E8%8A%82%20%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95%20a2e120fa16b74b619ae341d73009fd9d/Untitled%207.png" alt="Untitled"></p><h2 id="2-6-动量梯度下降法"><a href="#2-6-动量梯度下降法" class="headerlink" title="2.6 动量梯度下降法"></a>2.6 <strong>动量梯度下降法</strong></h2><p>动量梯度下降算法的速度要比传统的梯度下降算法快很多。</p><h3 id="做法"><a href="#做法" class="headerlink" title="做法"></a><strong>做法</strong></h3><p>是在每次训练时，<strong>对梯度进行指数加权平均处理</strong>，然后用得到的梯度值更新权重W和常数项b。</p><p><strong>原始的梯度下降算法</strong>如上图蓝色折线所示。在梯度下降过程中，梯度下降的<strong>振荡较大</strong>，尤其对于W、b之间数值范围差别较大的情况。此时每一点处的梯度只与当前方向有关，产生<strong>类似折线</strong>的效果，<strong>前进缓慢</strong>。并且<strong>不能使用较大的学习率</strong>，否则会超出函数范围，<strong>只能选择较小的学习率</strong>。如果对梯度进行<strong>指数加权平均</strong>，这样使当前梯度不仅与当<strong>前方向有关，还与之前的方向有关，这样处理让梯度前进方向更加平滑，减少振荡，能够更快地到达最小值处。</strong></p><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%BA%8C%20%E4%BC%98%E5%8C%96%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%20%E7%AC%AC2%E8%8A%82%20%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95%20a2e120fa16b74b619ae341d73009fd9d/Untitled%208.png" alt="Untitled"></p><h2 id="2-7-RMSprop"><a href="#2-7-RMSprop" class="headerlink" title="2.7 RMSprop"></a>2.7 <strong>RMSprop</strong></h2><p>RMSprop是另外一种加速梯度下降速度的算法。每次迭代训练过程中，其权重W和常数项b的更新表达式为：</p><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%BA%8C%20%E4%BC%98%E5%8C%96%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%20%E7%AC%AC2%E8%8A%82%20%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95%20a2e120fa16b74b619ae341d73009fd9d/Untitled%209.png" alt="Untitled"></p><p>也就是减小变得快的方向，加速变得慢的方向</p><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%BA%8C%20%E4%BC%98%E5%8C%96%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%20%E7%AC%AC2%E8%8A%82%20%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95%20a2e120fa16b74b619ae341d73009fd9d/Untitled%2010.png" alt="Untitled"></p><h2 id="2-8-Adam优化算法"><a href="#2-8-Adam优化算法" class="headerlink" title="2.8 Adam优化算法"></a>2.8 <strong>Adam优化算法</strong></h2><p>前两种，一种是用指数加权平均的思想，另一种是除以一个系数，使得减小震荡。</p><p>Adam算法结合了动量梯度下降算法和RMSprop算法的优点，<strong>使得神经网络训练速度大大提高</strong>，且适用于多种网络结构。</p><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%BA%8C%20%E4%BC%98%E5%8C%96%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%20%E7%AC%AC2%E8%8A%82%20%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95%20a2e120fa16b74b619ae341d73009fd9d/Untitled%2011.png" alt="Untitled"></p><p><strong>其实也就是上面的三种思路结合起来，需要调试的也就是学习率</strong></p><h2 id="2-9-学习率衰减"><a href="#2-9-学习率衰减" class="headerlink" title="2.9 学习率衰减"></a>2.9 <strong>学习率衰减</strong></h2><p>减小学习因子能有效<strong>提高神经网络训练速度</strong>，这种方法被称为learning rate decay。</p><p>Learning rate decay就是随着迭代次数增加，<strong>学习因子逐渐减小</strong>。下图中，蓝色折线表示使用恒定的学习因子，由于每次训练相同，步进长度不变，在接近最优值处的振荡也大，在最优值附近较大范围<strong>内振荡</strong>，与最优值距离就比较远。绿色折线表示使用不断减小的，随着训练次数增加，逐渐减小，步进长度减小，使得能够在最优值处较小范围内<strong>微弱振荡，不断逼近最优值。</strong>相比较恒定的来说，learning rate decay更接近最优值</p><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%BA%8C%20%E4%BC%98%E5%8C%96%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%20%E7%AC%AC2%E8%8A%82%20%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95%20a2e120fa16b74b619ae341d73009fd9d/Untitled%2012.png" alt="Untitled"></p><h2 id="2-10-局部最优的问题"><a href="#2-10-局部最优的问题" class="headerlink" title="2.10 局部最优的问题"></a>2.10 <strong>局部最优的问题</strong></h2><p>事实上，说是不太可能陷入极小值，好的优化算法都能有效解决下降慢的问题。</p><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%BA%8C%20%E4%BC%98%E5%8C%96%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%20%E7%AC%AC2%E8%8A%82%20%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95%20a2e120fa16b74b619ae341d73009fd9d/Untitled%2013.png" alt="Untitled"></p>]]></content>
      
      
      <categories>
          
          <category> AI </category>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 《深度学习》吴恩达 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《深度学习》 章二 优化深度学习 第1节 深度学习的实用层面</title>
      <link href="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%BA%8C%20%E4%BC%98%E5%8C%96%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%20%E7%AC%AC1%E8%8A%82%20%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9A%84%E5%AE%9E%E7%94%A8%E5%B1%82%E9%9D%A2%20d645ff5c464a45e094fe6d1eb9e900f3/"/>
      <url>/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%BA%8C%20%E4%BC%98%E5%8C%96%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%20%E7%AC%AC1%E8%8A%82%20%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9A%84%E5%AE%9E%E7%94%A8%E5%B1%82%E9%9D%A2%20d645ff5c464a45e094fe6d1eb9e900f3/</url>
      
        <content type="html"><![CDATA[<h1 id="章二-优化深度学习-第1节-深度学习的实用层面"><a href="#章二-优化深度学习-第1节-深度学习的实用层面" class="headerlink" title="章二 优化深度学习 第1节 深度学习的实用层面"></a>章二 优化深度学习 第1节 深度学习的实用层面</h1><h1 id="第一节-深度学习的实用层面"><a href="#第一节-深度学习的实用层面" class="headerlink" title="第一节 深度学习的实用层面"></a>第一节 深度学习的实用层面</h1><h2 id="1-1-训练-开发-测试集"><a href="#1-1-训练-开发-测试集" class="headerlink" title="1.1 训练/开发/测试集"></a>1.<strong>1 训练/开发/测试集</strong></h2><p>训练集（Training sets）、验证集（Development sets）、测试集（Test sets）的优劣对神经网络的性能有非常重要的影响。</p><h3 id="训练过程"><a href="#训练过程" class="headerlink" title="训练过程"></a><strong>训练过程</strong></h3><p>此外，构建神经网络时，还需要设置许多参数，例如神经网络的层数、每个隐藏层包含的神经元个数、学习因子（学习速率）、激活函数的选择等等。我们很难一开始就选择最佳的参数，需要通过不断地迭代更新来获得。</p><p><strong>循环迭代的过程</strong>如下：先有个想法Idea，选择初始的参数值，构建神经网络模型结构；然后通过代码Code的形式，实现这个神经网络；最后，通过实验Experiment验证这些参数对应的神经网络的表现性能。根据验证结果，对参数进行适当的调整优化，再进行下一次的Idea-&gt;Code-&gt;Experiment循环。通过很多次的循环，不断调整参数，选定最佳的参数值，从而让神经网络性能最优化。</p><h3 id="样本比例"><a href="#样本比例" class="headerlink" title="样本比例"></a><strong>样本比例</strong></h3><p>一般将所有的<strong>样本数据分成三个部分</strong>：Train/Dev/Test sets（训练集，（简单交叉）验证集，测试集） 。<strong>Train sets</strong>用来<strong>训练算法模型</strong>；<strong>Dev sets</strong>用来<strong>验证不同算法的表现情况</strong>，从中选择最好的算法模型；<strong>Test sets</strong>用来测试最好算法的实际表现，作为该算法的<strong>无偏估计。</strong></p><p>最常见的方法是将所有数据<strong>三七分</strong>，即设置Train sets和Test sets的数量比例为70%和30%。如果有Dev sets，则设置比例为<strong>60%、20%、20%</strong>，分别对应Train/Dev/Test sets。</p><p>但是如果<strong>数据量很大</strong>的时候，比如百万级的数据，这种比例分配就<strong>不太合适</strong>了。科学的做法是要将Dev sets和Test sets的比例设置得很低。因为Dev sets的目标是用来比较验证不同算法的优劣，从而选择更好的算法模型就行了。对于100万的样本，往往只需要10000个样本来做验证就够了。Test sets也是一样，目标是测试已选算法的实际表现，无偏估计。对于100万的样本，往往也只需要10000个样本就够了。对于大数据样本，Train/Dev/Test sets的比例通常可以设置为<strong>98%/1%/1%</strong>，或者<strong>99.5%/0.25%/0.25%</strong>或者<strong>99.5%/0.4%/0.1%</strong>。</p><h3 id="分布问题"><a href="#分布问题" class="headerlink" title="分布问题"></a><strong>分布问题</strong></h3><p>现代深度学习还有个重要的问题就是<strong>训练样本和测试样本分布上不匹配</strong>，意思是训练样本和测试样本<strong>来自于不同的分布</strong>。我们需要<strong>尽量保证Dev sets和Test sets来自于同一分布。</strong>通常我们可以对现有的训练样本做翻转、假如随机噪声等操作，来扩大训练样本的数量，从而让该模型更加强大。即使Train sets和Dev/Test sets不来自同一分布，使用这些技巧也能提高模型性能。</p><p>如果<strong>没有Test sets也是没有问题的。</strong>Test sets的目标主要是进行无偏估计。如果<strong>不需要无偏估计</strong>，可以不设置测试集。我们可以通过Train sets训练不同的算法模型，在Dev sets上进行验证，根据结果<strong>选择最好的算法模型</strong>，不再进行无偏估计。如果只有Train sets和Dev sets，有人会<strong>把这里的Dev sets称为Test sets。</strong></p><h2 id="1-2-偏差-方差"><a href="#1-2-偏差-方差" class="headerlink" title="1.2 偏差/方差"></a>1.<strong>2 偏差/方差</strong></h2><p>偏差（Bias）和方差（Variance）是机器学习领域非常重要的两个概念和需要解决的问题。</p><p>Bias和Variance是对立的，分别对应着欠拟合和过拟合，我们常常需要在Bias和Variance之间进行权衡。而在深度学习中，我们可以同时减小Bias和Variance，构建最佳神经网络模型。</p><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%BA%8C%20%E4%BC%98%E5%8C%96%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%20%E7%AC%AC1%E8%8A%82%20%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9A%84%E5%AE%9E%E7%94%A8%E5%B1%82%E9%9D%A2%20d645ff5c464a45e094fe6d1eb9e900f3/Untitled.png" alt="Untitled"></p><h3 id="理解"><a href="#理解" class="headerlink" title="理解"></a><strong>理解</strong></h3><p>通过两个数值Train set error（训练集误差）和Dev set error（验证集误差）来理解bias和variance。</p><p>假设Train set error为1%，而Dev set error为11%，即该算法模型对训练样本的识别很好，但是对验证集的识别却不太好。这说明了该模型对训练样本可能存在<strong>过拟合</strong>，模型泛化能力不强，导致验证集识别率低。这恰恰是high variance的表现。假设Train set error为15%，而Dev set error为16%，虽然二者error接近，即该算法模型对训练样本和验证集的识别都不是太好。这说明了该模型对训练样本存在<strong>欠拟合</strong>。这恰恰是high bias的表现。假设Train set error为15%，而Dev set error为30%，说明了该模型<strong>既存在high bias也存在high variance（深度学习中最坏的情况）</strong>。再假设Train set error为0.5%，而Dev set error为1%，即low bias和low variance，是<strong>最好的情况</strong>。</p><p>一般来说，Train set error体现了是否出现bias，Dev set error体现了是否出现variance（正确地说，应该是Dev set error与Train set error的相对差值）。</p><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%BA%8C%20%E4%BC%98%E5%8C%96%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%20%E7%AC%AC1%E8%8A%82%20%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9A%84%E5%AE%9E%E7%94%A8%E5%B1%82%E9%9D%A2%20d645ff5c464a45e094fe6d1eb9e900f3/Untitled%201.png" alt="Untitled"></p><p>模型<strong>既存在high bias也存在high variance</strong>，可以理解成<strong>某段区域是欠拟合的，某段区域是过拟合的。</strong></p><h2 id="1-3-机器学习基础"><a href="#1-3-机器学习基础" class="headerlink" title="1.3 机器学习基础"></a>1.3 <strong>机器学习基础</strong></h2><p>机器学习要避免出现high bias和high variance。</p><p><strong>减少high bias的方法</strong>通常是<strong>增加神经网络的隐藏层个数、神经元个数，训练时间延长，选择其它更复杂的NN模型等</strong>。在base error不高的情况下，一般都能通过这些方式有效降低和避免high bias，至少在训练集上表现良好。</p><p><strong>减少high variance的方法</strong>通常是<strong>增加训练样本数据</strong>，<strong>进行正则化Regularization</strong>，<strong>选择其他更复杂的NN模型等。</strong></p><p><strong>传统机器学习算法中</strong>，Bias和Variance通<strong>常是对立的</strong>，减小Bias会增加Variance，减小Variance会增加Bias。而在现在的<strong>深度学习中</strong>，通过使用更复杂的神经网络和海量的训练样本，一般能够<strong>同时有效减小</strong>Bias和Variance。这也是深度学习之所以如此强大的原因之一。</p><h2 id="1-4-正则化"><a href="#1-4-正则化" class="headerlink" title="1.4 正则化"></a>1.4 <strong>正则化</strong></h2><p><strong>（感觉中心思想都是简化网络，使得拟合函数不会过于复杂，自然就不会过拟合）</strong></p><p>如果出现了过拟合（high variance），可以采用正则化的方法来解决。减小high variance也可以采用扩大样本数的方法，但扩大训练集比较难，所以正则化更可行。</p><h3 id="L1"><a href="#L1" class="headerlink" title="L1"></a><strong>L1</strong></h3><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%BA%8C%20%E4%BC%98%E5%8C%96%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%20%E7%AC%AC1%E8%8A%82%20%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9A%84%E5%AE%9E%E7%94%A8%E5%B1%82%E9%9D%A2%20d645ff5c464a45e094fe6d1eb9e900f3/Untitled%202.png" alt="Untitled"></p><h3 id="L2"><a href="#L2" class="headerlink" title="L2"></a><strong>L2</strong></h3><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%BA%8C%20%E4%BC%98%E5%8C%96%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%20%E7%AC%AC1%E8%8A%82%20%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9A%84%E5%AE%9E%E7%94%A8%E5%B1%82%E9%9D%A2%20d645ff5c464a45e094fe6d1eb9e900f3/Untitled%203.png" alt="Untitled"></p><p><strong>只对w进行正则化而不对b进行正则化</strong>的原因如下：一般w的维度很大，而b只是一个常数。相比较来说，参数很大程度上由w决定，改变b值对整体模型影响较小。所以，一般为了简便，就忽略对b的正则化了。</p><h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a><strong>对比</strong></h3><p>L1 regularization比L2 regularization得到的w<strong>更加稀疏</strong>，即<strong>很多w为零值</strong>。其优点是<strong>节约存储空间</strong>，因为大部分w为0。</p><p>L1 regularization在解决high variance方面<strong>不如</strong>L2 regularization。而且，<strong>L1的在微分求导方面比较复杂。L2 regularization更加常用。</strong></p><p>L1、L2 regularization中的 λ 就是正则化参数（<strong>超参数</strong>的一种）。</p><h3 id="计算"><a href="#计算" class="headerlink" title="计算"></a><strong>计算</strong></h3><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%BA%8C%20%E4%BC%98%E5%8C%96%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%20%E7%AC%AC1%E8%8A%82%20%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9A%84%E5%AE%9E%E7%94%A8%E5%B1%82%E9%9D%A2%20d645ff5c464a45e094fe6d1eb9e900f3/Untitled%204.png" alt="Untitled"></p><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%BA%8C%20%E4%BC%98%E5%8C%96%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%20%E7%AC%AC1%E8%8A%82%20%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9A%84%E5%AE%9E%E7%94%A8%E5%B1%82%E9%9D%A2%20d645ff5c464a45e094fe6d1eb9e900f3/Untitled%205.png" alt="Untitled"></p><p>L2 regularization也被称做<strong>weight decay。</strong></p><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%BA%8C%20%E4%BC%98%E5%8C%96%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%20%E7%AC%AC1%E8%8A%82%20%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9A%84%E5%AE%9E%E7%94%A8%E5%B1%82%E9%9D%A2%20d645ff5c464a45e094fe6d1eb9e900f3/Untitled%206.png" alt="Untitled"></p><h2 id="1-5-为什么正则化可以减少过拟合"><a href="#1-5-为什么正则化可以减少过拟合" class="headerlink" title="1.5 为什么正则化可以减少过拟合"></a>1.5 <strong>为什么正则化可以减少过拟合</strong></h2><p>为什么正则化能够有效避免high variance，防止过拟合呢？下面我们通过几个例子说明。</p><p>还是之前那张图，从左到右，分别表示了欠拟合，刚好拟合，过拟合三种情况。</p><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%BA%8C%20%E4%BC%98%E5%8C%96%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%20%E7%AC%AC1%E8%8A%82%20%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9A%84%E5%AE%9E%E7%94%A8%E5%B1%82%E9%9D%A2%20d645ff5c464a45e094fe6d1eb9e900f3/Untitled%207.png" alt="Untitled"></p><p>假如我们选择了非常复杂的神经网络模型，如上图左上角所示。在未使用正则化的情况下，我们得到的分类超平面可能是类似上图右侧的过拟合。</p><h3 id="w近似0"><a href="#w近似0" class="headerlink" title="w近似0"></a><strong>w近似0</strong></h3><p>如果使用L2 regularization，<strong>当λ很大时，w[l]≈0。w[l]近似为零</strong>，意味着该神经网络模型中的某些神经元实际的作用很小，可以忽略。从效果上来看，<strong>其实是将某些神经元给忽略掉了。</strong>这样原本过于<strong>复杂的神经网络模型就变得不那么复杂了</strong>，而变得非常简单化了。如下图所示，整个简化的神经网络模型变成了一个逻辑回归模型。问题就从high variance变成了high bias了。</p><p><strong>因此，选择合适大小的λ值，就能够同时避免high bias和high variance，得到最佳模型。</strong></p><h3 id="另外一个直观的例子"><a href="#另外一个直观的例子" class="headerlink" title="另外一个直观的例子"></a><strong>另外一个直观的例子</strong></h3><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%BA%8C%20%E4%BC%98%E5%8C%96%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%20%E7%AC%AC1%E8%8A%82%20%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9A%84%E5%AE%9E%E7%94%A8%E5%B1%82%E9%9D%A2%20d645ff5c464a45e094fe6d1eb9e900f3/Untitled%208.png" alt="Untitled"></p><p>惩罚参数，也就是简化了网络，使得网络更简单。</p><h2 id="1-6-Dropout正则化"><a href="#1-6-Dropout正则化" class="headerlink" title="1.6 Dropout正则化"></a>1.6 <strong>Dropout正则化</strong></h2><p>除了L2 regularization之外，还有另外一种防止过拟合的有效方法：Dropout（随机失活）。</p><p>Dropout是指在深度学习网络的训练过程中，对于每层的神经元，<strong>按照一定的概率将其暂时从网络中丢弃。</strong>也就是说，每次训练时，<strong>每一层都有部分神经元不工作，起到简化复杂网络模型的效果，从而避免发生过拟合。</strong></p><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%BA%8C%20%E4%BC%98%E5%8C%96%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%20%E7%AC%AC1%E8%8A%82%20%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9A%84%E5%AE%9E%E7%94%A8%E5%B1%82%E9%9D%A2%20d645ff5c464a45e094fe6d1eb9e900f3/Untitled%209.png" alt="Untitled"></p><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a><strong>方法</strong></h3><p>Dropout有不同的实现方法，接下来介绍一种常用的方法：<strong>Inverted dropout</strong>。假设对于第l层神经元，设定保留神经元比例概率keep_prob=0.8，即该层有20%的神经元停止工作。dl为dropout向量，设置dl为随机vector，其中80%的元素为1，20%的元素为0。在python中可以使用如下语句生成dropout vector：</p><p>dl = np.random.rand(al.shape[0],al.shape[1]) &lt; keep_prob</p><p>然后，第l层经过dropout，随机删减20%的神经元，只保留80%的神经元，其输出为：</p><p>al = np.multiply(al,dl)</p><p>最后，还要对al进行scale up处理，即：</p><p>al /= keep_prob</p><p>scale up后，能够尽可能保持al的期望值相比之前没有大的变化。</p><p><strong>也就是放大了一些，期望还是不变的。</strong></p><h2 id="1-7-理解Dropout"><a href="#1-7-理解Dropout" class="headerlink" title="1.7 理解Dropout"></a>1.7 <strong>理解Dropout</strong></h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a><strong>原理</strong></h3><p>Dropout通过每次迭代训练时，随机选择不同的神经元，相当于每次都在不同的神经网络上进行训练，能够防止过拟合。</p><p>除此之外，对于某个神经元来说，某次训练时，它的某些输入被删除了。而在下一次训练时，又有不同的某些输入被删除。经过多次训练后，某些输入被删除，某些输入被保留。这样，该神经元不会受某个特定输入非常大的影响，<strong>影响被均匀化了</strong>。<strong>也就是说，每个输入对应的权重w不会很大。与L2 regularization类似，都是减小w。</strong></p><p>Dropout每次丢掉一定数量的隐藏层神经元，相当于在不同的神经网络上进行训练，这样就减少了神经元之间的依赖性，即每<strong>个神经元不能依赖于某几个其他的神经元</strong>（指层与层之间相连接的神经元），使神经网络更加能学习到与其他神经元之间的<strong>更加健壮robust</strong>的特征。</p><h3 id="设置方法"><a href="#设置方法" class="headerlink" title="设置方法"></a><strong>设置方法</strong></h3><p><strong>不同隐藏层的dropout系数keep_prob可以不同。</strong>一般来说，<strong>神经元越多</strong>的隐藏层，keep_out可以<strong>设置得小</strong>一些.，例如0.5；<strong>神经元越少的隐藏层</strong>，keep_out可以设置的<strong>大</strong>一些，例如0.7，如果不担心过拟合问题，可以设置为1。另外，实际应用中，<strong>不建议对输入层进行dropout</strong>，如果输入层<strong>维度很大</strong>，例如图片，那么<strong>可以设置dropout，但keep_out应设置的大一些</strong>，例如0.8，0.9。</p><p>总体来说，就是<strong>越容易出现overfitting的隐藏层，其keep_prob就设置的相对小</strong>一些。没有准确固定的做法，通常可以根据validation进行选择。</p><p>Dropout在电脑视觉CV领域应用比较广泛，因为<strong>输入层维度较大，而且没有足够多的样本数量。</strong>值得注意的是<strong>dropout是一种regularization技巧，用来防止过拟合的，最好只在需要regularization的时候使用dropout。</strong></p><h3 id="Debug"><a href="#Debug" class="headerlink" title="Debug"></a><strong>Debug</strong></h3><p>使用dropout的时候，可以通过绘制cost function来进行debug，看看dropout是否正确执行。一般做法是，将所有层的keep_prob全设置为1，再绘制cost function，即涵盖所有神经元，看J是否单调下降。下一次迭代训练时，再将keep_prob设置为其它值。</p><h2 id="1-8-其他正则化方法"><a href="#1-8-其他正则化方法" class="headerlink" title="1.8 其他正则化方法"></a>1.8 <strong>其他正则化方法</strong></h2><h3 id="data-augmentation"><a href="#data-augmentation" class="headerlink" title="data augmentation"></a><strong>data augmentation</strong></h3><p>一种方法是<strong>增加训练样本数量</strong>。但是<strong>通常成本较高</strong>，<strong>难以获得额外的训练样本</strong>。但是，我们可以对已有的训练样本进行一些处理来“<strong>制造”</strong>出更多的样本，称为<strong>data augmentation</strong>。例如图片识别问题中，可以对已有的图片进行<strong>水平翻转（训练集可以增大一倍）、垂直翻转、任意角度旋转、缩放或扩大、旋转缩放裁剪</strong>等等。在光学字符识别中，也可以将原有的数字图片进行任意旋转或者扭曲，或者增加一些noise。 通过人工合成数据的话，需要通过算法验证原图的含义没有变（例如经过水平翻转猫还是猫）</p><h3 id="early-stopping"><a href="#early-stopping" class="headerlink" title="early stopping"></a><strong>early stopping</strong></h3><p>还有另外一种防止过拟合的方法：early stopping。一个神经网络模型随着迭代训练次数增加，<strong>train set error和代价函数J一般是单调减小的，而dev set error 先减小，之后又增大。</strong>也就是说训练次数过多时，模型会对<strong>训练样本拟合的越来越好</strong>，但是对<strong>验证集拟合效果逐渐变差</strong>，即发生了<strong>过拟合</strong>。因此，迭代训练次数不是越多越好，可以通过train set error和dev set error随着迭代次数的变化趋势，选择合适的迭代次数，即early stopping。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>机器学习训练模型有<strong>两个目标</strong>：一是<strong>优化cost function</strong>，尽量<strong>减小代价函数J</strong>；二是防止<strong>过拟合（减小方差）</strong>。</p><p><strong>L2 regularization的缺点</strong>之一是最优的<strong>正则化参数λ的选择比较复杂</strong>，需要尝试许多不同的值。<strong>early stopping比较简单</strong>，只需要<strong>运行一次梯度下降</strong>，就可以<strong>找出w的较小值，中间值和较大值，</strong>无需尝试那么多次。但<strong>L2 regularization还是更常用一些。</strong></p><h2 id="1-9-正则化输入"><a href="#1-9-正则化输入" class="headerlink" title="1.9 正则化输入"></a>1.9 <strong>正则化输入</strong></h2><p>训练神经网络时，标准化输入能够加速神经网络训练。标准化输入就是对训练数据集进行归一化的操作，即将原始数据减去其均值后，再除以其方差。</p><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%BA%8C%20%E4%BC%98%E5%8C%96%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%20%E7%AC%AC1%E8%8A%82%20%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9A%84%E5%AE%9E%E7%94%A8%E5%B1%82%E9%9D%A2%20d645ff5c464a45e094fe6d1eb9e900f3/Untitled%2010.png" alt="Untitled"></p><p>由于训练集进行了标准化处理，那么测试集或在实际应用时，应该使用同样的和对其进行标准化处理。<strong>保证训练集和测试集的标准化操作一致。</strong></p><p>之所以要对输入进行标准化操作，主要是为了让所有输入<strong>归一化同样的尺度上</strong>，方便<strong>进行梯度下降算法时能够更快更准确地找到全局最优解</strong>。假如输入特征是二维的，且x1的范围是[1,1000]，x2的范围是[0,1]。如果<strong>不进行标准化处理，x1与x2之间分布极不平衡，训练得到的w1和w2也会在数量级上差别很大。</strong>这样<strong>导致的结果是cost function与w和b的关系可能是一个非常细长的椭圆形碗。</strong>对其进行梯度下降算法时，由于w1和w2数值差异很大，<strong>只能选择很小的学习因子αα，来避免J发生振荡。一旦α较大，必然发生振荡，J不再单调下降。</strong>如下左图所示。</p><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%BA%8C%20%E4%BC%98%E5%8C%96%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%20%E7%AC%AC1%E8%8A%82%20%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9A%84%E5%AE%9E%E7%94%A8%E5%B1%82%E9%9D%A2%20d645ff5c464a45e094fe6d1eb9e900f3/Untitled%2011.png" alt="Untitled"></p><h2 id="1-10-梯度消失与梯度爆炸"><a href="#1-10-梯度消失与梯度爆炸" class="headerlink" title="1.10 梯度消失与梯度爆炸"></a>1.10 <strong>梯度消失与梯度爆炸</strong></h2><p>梯度消失和梯度爆炸是指当训练一个层数非常多的神经网络时，计算得到的梯度可能非常小或非常大，甚至是指数级别的减小或增大。这样会让训练过程变得非常困难。</p><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%BA%8C%20%E4%BC%98%E5%8C%96%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%20%E7%AC%AC1%E8%8A%82%20%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9A%84%E5%AE%9E%E7%94%A8%E5%B1%82%E9%9D%A2%20d645ff5c464a45e094fe6d1eb9e900f3/Untitled%2012.png" alt="Untitled"></p><h2 id="1-11-神经网络的权重初始化"><a href="#1-11-神经网络的权重初始化" class="headerlink" title="1.11 神经网络的权重初始化"></a>1.11 <strong>神经网络的权重初始化</strong></h2><p>改善梯度爆炸或梯度消失问题<strong>（不能彻底解决）</strong>，可以通过权重初始化的方式。</p><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%BA%8C%20%E4%BC%98%E5%8C%96%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%20%E7%AC%AC1%E8%8A%82%20%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9A%84%E5%AE%9E%E7%94%A8%E5%B1%82%E9%9D%A2%20d645ff5c464a45e094fe6d1eb9e900f3/Untitled%2013.png" alt="Untitled"></p><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%BA%8C%20%E4%BC%98%E5%8C%96%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%20%E7%AC%AC1%E8%8A%82%20%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9A%84%E5%AE%9E%E7%94%A8%E5%B1%82%E9%9D%A2%20d645ff5c464a45e094fe6d1eb9e900f3/Untitled%2014.png" alt="Untitled"></p><h2 id="1-12-梯度的数值逼近"><a href="#1-12-梯度的数值逼近" class="headerlink" title="1.12 梯度的数值逼近"></a>1.12 <strong>梯度的数值逼近</strong></h2><p><strong>（下面两块内容之前都没有考虑过，而且这个似乎只要包没有问题，那就没有必要检查了把）</strong></p><p>Back Propagation神经网络有一项重要的测试是梯度检查。其目的是检查验证反向传播过程中梯度下降算法是否正确。下面是近似求出梯度的方法：</p><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%BA%8C%20%E4%BC%98%E5%8C%96%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%20%E7%AC%AC1%E8%8A%82%20%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9A%84%E5%AE%9E%E7%94%A8%E5%B1%82%E9%9D%A2%20d645ff5c464a45e094fe6d1eb9e900f3/Untitled%2015.png" alt="Untitled"></p><h2 id="1-13-梯度检验"><a href="#1-13-梯度检验" class="headerlink" title="1.13 梯度检验"></a>1.13 <strong>梯度检验</strong></h2><p>利用损失函数计算的梯度和反向传播之后参数变化曲线计算的梯度进行比较</p><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%BA%8C%20%E4%BC%98%E5%8C%96%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%20%E7%AC%AC1%E8%8A%82%20%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9A%84%E5%AE%9E%E7%94%A8%E5%B1%82%E9%9D%A2%20d645ff5c464a45e094fe6d1eb9e900f3/Untitled%2016.png" alt="Untitled"></p><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%BA%8C%20%E4%BC%98%E5%8C%96%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%20%E7%AC%AC1%E8%8A%82%20%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9A%84%E5%AE%9E%E7%94%A8%E5%B1%82%E9%9D%A2%20d645ff5c464a45e094fe6d1eb9e900f3/Untitled%2017.png" alt="Untitled"></p><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%BA%8C%20%E4%BC%98%E5%8C%96%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%20%E7%AC%AC1%E8%8A%82%20%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9A%84%E5%AE%9E%E7%94%A8%E5%B1%82%E9%9D%A2%20d645ff5c464a45e094fe6d1eb9e900f3/Untitled%2018.png" alt="Untitled"></p><h2 id="1-14-关于梯度检验实验的注记"><a href="#1-14-关于梯度检验实验的注记" class="headerlink" title="1.14 关于梯度检验实验的注记"></a>1.14 <strong>关于梯度检验实验的注记</strong></h2><p>在进行梯度检查的过程中有几点需要注意的地方：</p><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%BA%8C%20%E4%BC%98%E5%8C%96%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%20%E7%AC%AC1%E8%8A%82%20%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9A%84%E5%AE%9E%E7%94%A8%E5%B1%82%E9%9D%A2%20d645ff5c464a45e094fe6d1eb9e900f3/Untitled%2019.png" alt="Untitled"></p>]]></content>
      
      
      <categories>
          
          <category> AI </category>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 《深度学习》吴恩达 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《深度学习》 章一 神经网络与深度学习</title>
      <link href="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%B8%80%20%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%20e2b37696f2cf4267b32cb45a9e7e25fe/"/>
      <url>/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%B8%80%20%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%20e2b37696f2cf4267b32cb45a9e7e25fe/</url>
      
        <content type="html"><![CDATA[<h1 id="章一-神经网络与深度学习"><a href="#章一-神经网络与深度学习" class="headerlink" title="章一 神经网络与深度学习"></a>章一 神经网络与深度学习</h1><h1 id="第一节-深度学习概论"><a href="#第一节-深度学习概论" class="headerlink" title="第一节 深度学习概论"></a>第一节 深度学习概论</h1><h2 id="1-1-什么是神经网络"><a href="#1-1-什么是神经网络" class="headerlink" title="1.1 什么是神经网络"></a>1.1 什么是神经网络</h2><p>深度学习（Deep Learning）就是更复杂的神经网络（Neural Network）</p><p>那么，什么是神经网络呢？下面我们将通过一个简单的例子来引入神经网络模型的概念。</p><h3 id="建立房价的预测模型："><a href="#建立房价的预测模型：" class="headerlink" title="建立房价的预测模型："></a><strong>建立房价的预测模型：</strong></h3><p><strong>神经元</strong></p><p>一共有六个房子。我们已知输入x即每个房子的面积（多少尺或者多少平方米），还知道其对应的输出y即每个房子的价格。根据这些输入输出，我们要建立一个函数模型，来预测房价：y=f(x)。</p><p>我们会一条直线来拟合图中这些离散点，即建立房价与面积的线性模型。但是从实际考虑，我们知道价格永远不会是负数。所以，我们对该直线做一点点修正，让它变成折线的形状，当面积小于某个值时，价格始终为零。</p><p>几乎是一个最简单的神经网络。我们把该房价预测用一个最简单的神经网络模型来表示</p><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%B8%80%20%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%20e2b37696f2cf4267b32cb45a9e7e25fe/Untitled.png" alt="Untitled"></p><p>该神经网络的输入x是房屋面积，输出y是房屋价格，中间包含了一个<strong>神经元</strong>（neuron），即房价预测函数（蓝色折线）。该神经元的功能就是实现函数f(x)的功能。</p><p>上图神经元的预测函数（蓝色折线）在神经网络应用中比较常见。我们把这个函数称为ReLU函数，即线性整流函数（Rectified Linear Unit）</p><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%B8%80%20%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%20e2b37696f2cf4267b32cb45a9e7e25fe/Untitled%201.png" alt="Untitled"></p><p>上面讲的只是由单个神经元（输入x仅仅是房屋面积一个因素）组成的神经网络，而通常一个大型的神经网络往往由许多神经元组成，就像通过乐高积木搭建复杂物体（例如火车）一样。</p><p><strong>神经网络</strong></p><p>现在，我们把上面举的房价预测的例子变得复杂一些，而不是仅仅使用房屋面积一个判断因素。</p><p>例如，除了考虑房屋面积（size）之外，我们还考虑卧室数目（#bedrooms）。这两点实际上与家庭成员的个数（family size）有关。还有，房屋的邮政编码（zip code/postal code），代表了该房屋位置的交通便利性，是否需要步行还是开车？即决定了可步行性（walkability）。另外，还有可能邮政编码和地区财富水平（wealth）共同影响了房屋所在地区的学校质量（school quality）。</p><p>如下图所示，该神经网络共有三个神经元，分别代表了family size，walkability和school quality。每一个神经元都包含了一个ReLU函数（或者其它非线性函数）。那么，根据这个模型，我们可以根据房屋的面积和卧室个数来估计family size，根据邮政编码来估计walkability，根据邮政编码和财富水平来估计school quality。</p><p>最后，由family size，walkability和school quality等这些人们比较关心的因素来预测最终的房屋价格。</p><p>实际上，上面这个例子真正的神经网络模型结构如下所示。它有四个输入，分别是size，#bedrooms，zip code和wealth。在给定这四个输入后，神经网络所做的就是输出房屋的预测价格y。图中，三个神经元所在的位置称之为中间层或者隐藏层（x所在的称之为输入层，y所在的称之为输出层），每个神经元与所有的输入x都有关联（直线相连）。</p><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%B8%80%20%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%20e2b37696f2cf4267b32cb45a9e7e25fe/Untitled%202.png" alt="Untitled"></p><p>这就是基本的神经网络模型结构。在训练的过程中，<strong>只要有足够的输入x和输出y，就能训练出较好的神经网络模型</strong>，该模型在此类房价预测问题中，能够得到比较准确的结果。</p><h2 id="1-2-使用神经网络进行监督学习"><a href="#1-2-使用神经网络进行监督学习" class="headerlink" title="1.2 使用神经网络进行监督学习"></a>1.2 使用神经网络进行监督学习</h2><p>目前为止，由神经网络模型创造的价值基本上都是基于监督式学习（Supervised Learning）的。监督式学习与非监督式学习本质区别就是是否已知训练样本的输出y。</p><h3 id="举例："><a href="#举例：" class="headerlink" title="举例："></a><strong>举例：</strong></h3><p>第一个例子还是房屋价格预测。根据训练样本的输入x和输出y，训练神经网络模型，预测房价。</p><p>第二个例子是线上广告，这是深度学习最广泛、最赚钱的应用之一。其中，输入x是广告和用户个人信息，输出y是用户是否对广告进行点击。神经网络模型经过训练，能够根据广告类型和用户信息对用户的点击行为进行预测，从而向用户提供用户自己可能感兴趣的广告。</p><p>第三个例子是电脑视觉（computer vision）。电脑视觉是近些年来越来越火的课题，而电脑视觉发展迅速的原因很大程度上是得益于深度学习。其中，输入x是图片像素值，输出是图片所属的不同类别。</p><p>第四个例子是语音识别（speech recognition）。深度学习可以将一段语音信号辨识为相应的文字信息。</p><p>第五个例子是智能翻译，例如通过神经网络输入英文，然后直接输出中文。</p><p>除此之外，第六个例子是自动驾驶。通过输入一张图片或者汽车雷达信息，神经网络通过训练来告诉你相应的路况信息并作出相应的决策。至此，神经网络配合监督式学习，其应用是非常广泛的。</p><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%B8%80%20%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%20e2b37696f2cf4267b32cb45a9e7e25fe/Untitled%203.png" alt="Untitled"></p><p>根据不同的问题和应用场合，应该使用不同类型的神经网络模型。</p><p>例如上面介绍的几个例子中，对于一般的监督式学习（房价预测和线上广告问题），我们只要使用标准的神经网络模型就可以了。而对于图像识别处理问题，我们则要使用卷积神经网络（Convolution Neural Network），即CNN。而对于处理类似语音这样的序列信号时，则要使用循环神经网络（Recurrent Neural Network），即RNN。还有其它的例如自动驾驶这样的复杂问题则需要更加复杂的混合神经网络模型。</p><p>CNN和RNN是比较常用的神经网络模型。下图给出了Standard NN，Convolutional NN和Recurrent NN的神经网络结构图。</p><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%B8%80%20%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%20e2b37696f2cf4267b32cb45a9e7e25fe/Untitled%204.png" alt="Untitled"></p><h3 id="数据类型："><a href="#数据类型：" class="headerlink" title="数据类型："></a><strong>数据类型：</strong></h3><p><code>Structured Data</code>和<code>Unstructured Data</code>。</p><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%B8%80%20%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%20e2b37696f2cf4267b32cb45a9e7e25fe/Untitled%205.png" alt="Untitled"></p><p>Structured Data通常指的是有实际意义的数据。例如房价预测中的size，#bedrooms，price等；例如在线广告中的User Age，Ad ID等。</p><p>而Unstructured Data通常指的是比较抽象的数据，例如Audio，Image或者Text。</p><p>总的来说，神经网络与深度学习无论对Structured Data还是Unstructured Data都能处理得越来越好，并逐渐创造出巨大的实用价值。</p><h2 id="1-3-为什么深度学习这么强大"><a href="#1-3-为什么深度学习这么强大" class="headerlink" title="1.3 为什么深度学习这么强大"></a>1.3 为什么深度学习这么强大</h2><p>横坐标x表示数据量（Amount of data），纵坐标y表示机器学习模型的性能表现（Performance）</p><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%B8%80%20%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%20e2b37696f2cf4267b32cb45a9e7e25fe/Untitled%206.png" alt="Untitled"></p><p><code>传统机器学习算法</code>在数据量较大的时候，性能一般，很难再有提升。然而，深度学习模型由于网络复杂，对大数据的处理和分析非常有效。</p><p>在处理<code>海量数据</code>和建立<code>复杂准确的学习模型</code>方面，<code>深度学习</code>有着非常不错的表现。然而，在数据量不大的时候，例如上图中左边区域，深度学习模型不一定优于传统机器学习算法，性能差异可能并不大。</p><h3 id="强大的原因：三驾马车"><a href="#强大的原因：三驾马车" class="headerlink" title="强大的原因：三驾马车"></a><strong>强大的原因：三驾马车</strong></h3><ul><li><strong>Data</strong></li></ul><p>数据量的几何级数增加</p><ul><li><strong>Computation</strong></li></ul><p>加上<code>GPU</code>出现、计算机运算能力的大大提升，使得深度学习能够应用得更加广泛。</p><ul><li><strong>Algorithms</strong></li></ul><p>另外，<code>算法</code>上的创新和改进让深度学习的性能和速度也大大提升。</p><p>（举例：之前神经网络神经元的激活函数是Sigmoid函数，后来改成了ReLU函数。Sigmoid函数，在远离零点的位置，函数曲线非常平缓，其梯度趋于0，所以造成神经网络模型<strong>学习速度变得很慢</strong>。然而，ReLU函数在x大于零的区域，其梯度始终为1，尽管在x小于零的区域梯度为0，但是在实际应用中采用ReLU函数确实要比Sigmoid函数快很多。）</p><h3 id="深度学习构建流程"><a href="#深度学习构建流程" class="headerlink" title="深度学习构建流程"></a><strong>深度学习构建流程</strong></h3><p>首先产生Idea，然后将Idea转化为Code，最后进行Experiment。</p><p>接着根据结果修改Idea，继续这种Idea-&gt;Code-&gt;Experiment的循环，直到最终训练得到表现不错的深度学习网络模型。</p><p>如果<strong>计算速度越快，每一步骤耗时越少，那么上述循环越能高效进行</strong>。</p><h1 id="第二节-神经网络基础之逻辑回归"><a href="#第二节-神经网络基础之逻辑回归" class="headerlink" title="第二节 神经网络基础之逻辑回归"></a>第二节 神经网络基础之逻辑回归</h1><h2 id="2-1-二分类"><a href="#2-1-二分类" class="headerlink" title="2.1 二分类"></a>2.1 二分类</h2><p>逻辑回归模型一般用来解决<code>二分类（Binary Classification）</code>问题。</p><p>二分类就是输出y只有{0,1}两个离散值（也有{-1,1}的情况）。我们以一个图像识别问题为例，判断图片中是否有猫存在，0代表noncat，1代表cat。</p><p>通过这个例子简要介绍神经网络模型中一些<strong>标准化的、有效率的处理方法和notations。</strong></p><h3 id="notations："><a href="#notations：" class="headerlink" title="notations："></a><strong>notations：</strong></h3><p>cat图片的尺寸为<code>（64，64，3）</code>,将图片输入x（维度是（64，64，3））转化为一维的特征向量（feature vector）.。</p><p>方法是每个通道一行一行取，再连接起来。由于64x64x3=12288，则转化后的输入特征向量维度为<code>（12288，1）</code>。此特征向量x是列向量，维度一般记为nx。</p><p>如果训练样本共有m张图片，那么整个训练样本X组成了矩阵，维度是<code>（nx，m）</code>。</p><p>注意，这里矩阵X的<code>行nx代表了每个样本x(i)特征个数</code>，<code>列m代表了样本个数</code>。这里，Andrew解释了X的维度之所以是<code>（nx，m）</code>而不是（m，nx）的原因是为了之后矩阵运算的方便。</p><blockquote><p>这里有一个注意的点：一列表示一个样本，行数是样本特征数</p></blockquote><p>所有训练样本的输出Y也组成了一维的行向量，写成矩阵的形式后，它的维度就是<code>（1，m）</code>。</p><h2 id="2-1-Logistic-Regression"><a href="#2-1-Logistic-Regression" class="headerlink" title="2.1 Logistic Regression"></a>2.1 <strong>Logistic Regression</strong></h2><p>逻辑回归中，预测值<code>h^=P(y=1 | x)</code>表示为1的概率，取值范围在[0,1]之间。</p><p>使用线性模型，引入参数w和b。权重w的维度是（nx，1），b是一个常数项。</p><p>这样，逻辑回归的线性预测输出可以写成：<code>y^=wTx+b</code></p><p>值得注意的是，很多其它机器学习资料中，可能把常数b当做w0处理，并引入x0=1。但在本课程中，为了简化计算和便于理解，建议使用上式这种形式将w和b分开比较好。</p><p><strong>Sigmoid</strong></p><p>上式的线性输出区间为整个实数范围，而逻辑回归要求输出范围在[0,1]之间，所以还需要对上式的线性函数输出进行处理。方法是引入Sigmoid函数，让输出限定在[0,1]之间。</p><p><code>y^=Sigmoid(wTx+b)=σ(wTx+b)</code></p><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%B8%80%20%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%20e2b37696f2cf4267b32cb45a9e7e25fe/Untitled%207.png" alt="Untitled"></p><p>还有一点值得注意的是，Sigmoid函数的一阶导数可以用其自身表示：</p><p><code>σ′(z)=σ(z)(1−σ(z))</code></p><h2 id="2-3-逻辑回归的损失函数"><a href="#2-3-逻辑回归的损失函数" class="headerlink" title="2.3 逻辑回归的损失函数"></a>2.3 逻辑回归的损失函数</h2><p>逻辑回归中，w和b都是未知参数，需要反复训练优化得到。因此，我们需要定义一个cost function，包含了参数w和b。通过优化cost function，当cost function取值最小时，得到对应的w和b。</p><p><strong>过去</strong></p><p>平方错误（squared error）来衡量</p><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%B8%80%20%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%20e2b37696f2cf4267b32cb45a9e7e25fe/Untitled%208.png" alt="Untitled"></p><p><strong>但</strong></p><p>我们一般不使用平方错误来作为Loss function。原因是这种Loss function一般是non-convex的（非凸）。non-convex函数在使用梯度下降算法时，<strong>容易得到局部最小值</strong>（local minumum），即局部最优化。而我们最优化的目标是计算得到<strong>全局最优化</strong>（Global optimization）。因此，我们一般选择的Loss function应该是convex的。</p><blockquote><p>交叉熵损失函数</p></blockquote><p>Loss function的原则和目的就是要衡量预测输出y^与真实样本输出y的接近程度。平方错误其实也可以，只是它是non-convex的，不利于使用梯度下降算法来进行全局优化。</p><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%B8%80%20%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%20e2b37696f2cf4267b32cb45a9e7e25fe/Untitled%209.png" alt="Untitled"></p><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%B8%80%20%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%20e2b37696f2cf4267b32cb45a9e7e25fe/Untitled%2010.png" alt="Untitled"></p><p>后面的课程中，我们将详细推导该Loss function是如何得到的。并不是凭空捏造的哦。。。</p><p><strong>m个样本</strong></p><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%B8%80%20%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%20e2b37696f2cf4267b32cb45a9e7e25fe/Untitled%2011.png" alt="Untitled"></p><p>其实逻辑回归问题可以看成是一个简单的神经网络，只包含一个神经元。这也是我们这里先介绍逻辑回归的原因。</p><h2 id="2-4-梯度下降"><a href="#2-4-梯度下降" class="headerlink" title="2.4 梯度下降"></a>2.4 梯度下降</h2><p>接下来将使用梯度下降<code>（Gradient Descent）</code>算法来计算出合适的w和b值，从而最小化m个训练样本的Cost function，即J(w,b)。</p><p>梯度下降算法是先随机选择一组参数w和b值，然后每次迭代的过程中分别沿着w和b的梯度（偏导数）的反方向前进一小步，不断修正w和b。每次迭代更新w和b后，都能让J(w,b)更接近全局最小值。梯度下降的过程如下图所示。</p><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%B8%80%20%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%20e2b37696f2cf4267b32cb45a9e7e25fe/Untitled%2012.png" alt="Untitled"></p><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%B8%80%20%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%20e2b37696f2cf4267b32cb45a9e7e25fe/Untitled%2013.png" alt="Untitled"></p><p>α是学习因子（learning rate），表示梯度下降的步进长度。α越大，w和b每次更新的“步伐”更大一些；α越小，w和b每次更新的“步伐”更小一些。</p><p>梯度下降算法能够保证每次迭代w和b都能向着J(w,b)全局最小化的方向进行。（如下图所示：）</p><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%B8%80%20%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%20e2b37696f2cf4267b32cb45a9e7e25fe/Untitled%2014.png" alt="Untitled"></p><p>右边斜率会是正的，而左边会是负的。</p><h2 id="2-5-amp-6-导数、更多导数的例子（略）"><a href="#2-5-amp-6-导数、更多导数的例子（略）" class="headerlink" title="2.5&amp;6 导数、更多导数的例子（略）"></a>2.5&amp;6 导数、更多导数的例子（略）</h2><h2 id="2-7-amp-8-计算图-、计算图的导数计算（略）"><a href="#2-7-amp-8-计算图-、计算图的导数计算（略）" class="headerlink" title="2.7&amp;8 计算图 、计算图的导数计算（略）"></a>2.<strong>7&amp;8 计算图 、计算图的导数计算</strong>（略）</h2><h2 id="2-9-逻辑回归中的梯度下降"><a href="#2-9-逻辑回归中的梯度下降" class="headerlink" title="2.9 逻辑回归中的梯度下降"></a>2.9 <strong>逻辑回归中的梯度下降</strong></h2><h3 id="单个样本："><a href="#单个样本：" class="headerlink" title="单个样本："></a>单个样本<strong>：</strong></h3><p>对单个样本而言，逻辑回归Loss function表达式如下</p><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%B8%80%20%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%20e2b37696f2cf4267b32cb45a9e7e25fe/Untitled%2015.png" alt="Untitled"></p><p>该逻辑回归的正向传播过程非常简单。</p><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%B8%80%20%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%20e2b37696f2cf4267b32cb45a9e7e25fe/Untitled%2016.png" alt="Untitled"></p><p>计算该逻辑回归的反向传播过程，即由Loss function计算参数w和b的偏导数。</p><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%B8%80%20%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%20e2b37696f2cf4267b32cb45a9e7e25fe/Untitled%2017.png" alt="Untitled"></p><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%B8%80%20%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%20e2b37696f2cf4267b32cb45a9e7e25fe/Untitled%2018.png" alt="Untitled"></p><h3 id="m个样本上的梯度下降："><a href="#m个样本上的梯度下降：" class="headerlink" title="m个样本上的梯度下降："></a><strong>m个样本上的梯度下降：</strong></h3><p>上一部分讲的是对单个样本求偏导和梯度下降。如果有m个样本，其Cost function表达式如下：</p><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%B8%80%20%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%20e2b37696f2cf4267b32cb45a9e7e25fe/Untitled%2019.png" alt="Untitled"></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">J=<span class="number">0</span>; dw1=<span class="number">0</span>; dw2=<span class="number">0</span>; db=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> i = <span class="number">1</span> to m</span><br><span class="line">    <span class="title function_">z</span>(i) = <span class="title function_">wx</span>(i)+b;</span><br><span class="line">    <span class="title function_">a</span>(i) = <span class="title function_">sigmoid</span>(<span class="title function_">z</span>(i));</span><br><span class="line">    J += -[<span class="title function_">y</span>(i)<span class="title function_">log</span>(<span class="title function_">a</span>(i))+(<span class="number">1</span>-<span class="title function_">y</span>(i)）<span class="title function_">log</span>(<span class="number">1</span>-<span class="title function_">a</span>(i));</span><br><span class="line">    <span class="title function_">dz</span>(i) = <span class="title function_">a</span>(i)-<span class="title function_">y</span>(i);</span><br><span class="line">    dw1 += <span class="title function_">x1</span>(i)<span class="title function_">dz</span>(i);</span><br><span class="line">    dw2 += <span class="title function_">x2</span>(i)<span class="title function_">dz</span>(i);</span><br><span class="line">    db += <span class="title function_">dz</span>(i);</span><br><span class="line">J /= m;</span><br><span class="line">dw1 /= m;</span><br><span class="line">dw2 /= m;</span><br><span class="line">db /= m;</span><br></pre></td></tr></table></figure><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%B8%80%20%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%20e2b37696f2cf4267b32cb45a9e7e25fe/Untitled%2020.png" alt="Untitled"></p><h1 id="第三节-Python与向量化"><a href="#第三节-Python与向量化" class="headerlink" title="第三节 Python与向量化"></a>第三节 Python与向量化</h1><h2 id="3-1-向量化"><a href="#3-1-向量化" class="headerlink" title="3.1 向量化"></a>3.1 向量化</h2><p>深度学习算法中，数据量很大，在程序中应该尽量减少使用loop循环语句，而可以使用向量运算来提高程序运行速度。</p><p>向量化（Vectorization）就是利用矩阵运算的思想，大大提高运算速度。</p><p>为了加快深度学习神经网络运算速度，可以使用比CPU运算能力更强大的GPU。事实上，GPU和CPU都有并行指令（parallelization instructions），称为Single Instruction Multiple Data（SIMD）。SIMD是单指令多数据流，能够复制多个操作数，并把它们打包在大型寄存器的一组指令集。SIMD能够大大提高程序运行速度，例如python的numpy库中的内建函数（built-in function）就是使用了SIMD指令。相比而言，GPU的SIMD要比CPU更强大一些。</p><h2 id="3-2-向量化logistic回归及其梯度输出"><a href="#3-2-向量化logistic回归及其梯度输出" class="headerlink" title="3.2 向量化logistic回归及其梯度输出"></a>3.<strong>2 向量化logistic回归及其梯度输出</strong></h2><h3 id="逻辑回归："><a href="#逻辑回归：" class="headerlink" title="逻辑回归："></a><strong>逻辑回归：</strong></h3><p>利用向量化的思想，所有m个样本的线性输出Z可以用矩阵表示：</p><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%B8%80%20%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%20e2b37696f2cf4267b32cb45a9e7e25fe/Untitled%2021.png" alt="Untitled"></p><p>在python的numpy库中可以表示为：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Z = np.<span class="title function_">dot</span>(w.<span class="property">T</span>,X) + b</span><br><span class="line">A = <span class="title function_">sigmoid</span>(Z)</span><br></pre></td></tr></table></figure><h3 id="梯度输出："><a href="#梯度输出：" class="headerlink" title="梯度输出："></a><strong>梯度输出：</strong></h3><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%B8%80%20%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%20e2b37696f2cf4267b32cb45a9e7e25fe/Untitled%2022.png" alt="Untitled"></p><p>db = 1/m*np.sum(dZ)</p><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%B8%80%20%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%20e2b37696f2cf4267b32cb45a9e7e25fe/Untitled%2023.png" alt="Untitled"></p><p>dw = 1/m*np.dot(X,dZ.T)</p><p>这样，整个逻辑回归中的for循环尽可能用矩阵运算代替，对于单次迭代，梯度下降算法流程如下所示：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Z = np.<span class="title function_">dot</span>(w.<span class="property">T</span>,X) + b</span><br><span class="line">A = <span class="title function_">sigmoid</span>(Z)</span><br><span class="line">dZ = A-Y</span><br><span class="line">dw = <span class="number">1</span>/m*np.<span class="title function_">dot</span>(X,dZ.<span class="property">T</span>)</span><br><span class="line">db = <span class="number">1</span>/m*np.<span class="title function_">sum</span>(dZ)</span><br><span class="line"> </span><br><span class="line">w = w - alpha*dw</span><br><span class="line">b = b - alpha*db</span><br></pre></td></tr></table></figure><p>其中，alpha是学习因子，决定w和b的更新速度。上述代码只是对单次训练更新而言的，外层还需要一个for循环，表示迭代次数</p><h2 id="3-3-Python中的广播"><a href="#3-3-Python中的广播" class="headerlink" title="3.3 Python中的广播"></a>3.<strong>3 Python中的广播</strong></h2><p>python中的广播机制可由下面四条表示：</p><ul><li>让所有输入数组都向其中shape最长的数组看齐，shape中不足的部分都通过在前面加1补齐</li><li>输出数组的shape是输入数组shape的各个轴上的最大值</li><li>如果输入数组的某个轴和输出数组的对应轴的长度相同或者其长度为1时，这个数组能够用来计算，否则出错</li><li>当输入数组的某个轴的长度为1时，沿着此轴运算时都用此轴上的第一组值</li></ul><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%B8%80%20%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%20e2b37696f2cf4267b32cb45a9e7e25fe/Untitled%2024.png" alt="Untitled"></p><h3 id="单个样本：-1"><a href="#单个样本：-1" class="headerlink" title="单个样本："></a>单个样本<strong>：</strong></h3><h2 id="3-4-关于python-numpy向量的说明"><a href="#3-4-关于python-numpy向量的说明" class="headerlink" title="3.4 关于python/numpy向量的说明"></a>3.<strong>4 关于python/numpy向量的说明</strong></h2><p>python中，如果我们用下列语句来定义一个向量：</p><p><code>a = np.random.randn(5)</code></p><p>这条语句生成的a的维度是（5，）。它既不是行向量也不是列向量，它是rank 1 array。如果对a进行转置，会得到a本身。所以，如果要定义（5，1）的列向量或者（1，5）的行向量，最好使用下面的标准语句。</p><p><code>a = np.random.randn(5,1)b = np.random.randn(1,5)</code></p><p>还可以使用assert语句对向量或数组的维度进行判断：<br><code>assert(a.shape == (5,1))</code></p><p>assert会对内嵌语句进行判断，即判断a的维度是不是（5，1）的。如果不是，则程序在此处停止。使用assert语句是一种能够及时检查、判断语句是否正确的好习惯。<br>此外，还可以使用reshape函数对数组设定所需的维度：<br><code>a.reshape((5,1))</code></p><h2 id="3-5-Explanation-of-logistic-regression-cost-function-optional"><a href="#3-5-Explanation-of-logistic-regression-cost-function-optional" class="headerlink" title="3.5 Explanation of logistic regression cost function(optional)"></a>3.<strong>5 Explanation of logistic regression cost function(optional)</strong></h2><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%B8%80%20%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%20e2b37696f2cf4267b32cb45a9e7e25fe/Untitled%2025.png" alt="Untitled"></p><p><strong>注意问题：独立同分布和连乘</strong></p><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%B8%80%20%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%20e2b37696f2cf4267b32cb45a9e7e25fe/Untitled%2026.png" alt="Untitled"></p><h1 id="第四节-浅层神经网络"><a href="#第四节-浅层神经网络" class="headerlink" title="第四节 浅层神经网络"></a>第四节 浅层神经网络</h1><h2 id="4-1-神经网络概览"><a href="#4-1-神经网络概览" class="headerlink" title="4.1 神经网络概览"></a>4.1 <strong>神经网络概览</strong></h2><p>神经网络的结构与逻辑回归类似，只是神经网络的层数比逻辑回归多一层，多出来的中间那层称为隐藏层或中间层。从计算上来说，神经网络的正向传播和反向传播过程只是比逻辑回归多了一次重复的计算。正向传播过程分成两层，第一层是输入层到隐藏层，用上标[1]来表示；第二层是隐藏层到输出层，用上标[2]来表示。方括号上标[i]表示当前所处的层数；圆括号上标(i)表示第i个样本。</p><p>同样，反向传播过程也分成两层。第一层是输出层到隐藏层，第二层是隐藏层到输入层。</p><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%B8%80%20%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%20e2b37696f2cf4267b32cb45a9e7e25fe/Untitled%2027.png" alt="Untitled"></p><h2 id="4-2-神经网络表示"><a href="#4-2-神经网络表示" class="headerlink" title="4.2 神经网络表示"></a>4.2 <strong>神经网络表示</strong></h2><p>下面我们以图示的方式来介绍单隐藏层的神经网络结构。如下图所示，单隐藏层神经网络就是典型的浅层（shallow）神经网络。</p><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%B8%80%20%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%20e2b37696f2cf4267b32cb45a9e7e25fe/Untitled%2028.png" alt="Untitled"></p><p>结构上，从左到右，可以分成三层：输入层（Input layer），隐藏层（Hidden layer）和输出层（Output layer）。输入层和输出层，顾名思义，对应着训练样本的输入和输出，很好理解。隐藏层是抽象的非线性的中间层，这也是其被命名为隐藏层的原因。</p><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%B8%80%20%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%20e2b37696f2cf4267b32cb45a9e7e25fe/Untitled%2029.png" alt="Untitled"></p><p>最后，相应的输出层记为a[2]，即y^。</p><p>这种单隐藏层神经网络也被称为<code>两层神经网络</code>（2 layer NN）。之所以叫两层神经网络是因为，通常我们<code>只会计算隐藏层输出和输出层的输出</code>，输入层是不用计算的。这也是我们把输入层层数上标记为0的原因（a[0]）。</p><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%B8%80%20%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%20e2b37696f2cf4267b32cb45a9e7e25fe/Untitled%2030.png" alt="Untitled"></p><h2 id="4-3-计算神经网络的输出"><a href="#4-3-计算神经网络的输出" class="headerlink" title="4.3 计算神经网络的输出"></a>4.3 <strong>计算神经网络的输出</strong></h2><h3 id="计算输出："><a href="#计算输出：" class="headerlink" title="计算输出："></a><strong>计算输出：</strong></h3><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%B8%80%20%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%20e2b37696f2cf4267b32cb45a9e7e25fe/Untitled%2031.png" alt="Untitled"></p><p>对于两层神经网络，从输入层到隐藏层对应一次逻辑回归运算；从隐藏层到输出层对应一次逻辑回归运算。每层计算时，要注意对应的上标和下标，一般我们记上标方括号表示第几层，下标表示第几个神经元。下标从1开始，上标从0开始。</p><p>从输入层到隐藏层的计算公式：</p><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%B8%80%20%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%20e2b37696f2cf4267b32cb45a9e7e25fe/Untitled%2032.png" alt="Untitled"></p><p>从隐藏层到输出层的计算公式</p><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%B8%80%20%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%20e2b37696f2cf4267b32cb45a9e7e25fe/Untitled%2033.png" alt="Untitled"></p><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%B8%80%20%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%20e2b37696f2cf4267b32cb45a9e7e25fe/Untitled%2034.png" alt="Untitled"></p><p>上述每个节点的计算都对应着一次逻辑运算的过程，分别由计算z和a两部分组成。</p><p>为了提高程序运算速度，我们引入向量化和矩阵运算的思想，将上述表达式转换成矩阵运算的形式：</p><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%B8%80%20%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%20e2b37696f2cf4267b32cb45a9e7e25fe/Untitled%2035.png" alt="Untitled"></p><h3 id="矩阵维度："><a href="#矩阵维度：" class="headerlink" title="矩阵维度："></a><strong>矩阵维度：</strong></h3><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%B8%80%20%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%20e2b37696f2cf4267b32cb45a9e7e25fe/Untitled%2036.png" alt="Untitled"></p><h2 id="4-4-多个例子中的向量化"><a href="#4-4-多个例子中的向量化" class="headerlink" title="4.4 多个例子中的向量化"></a>4.4 <strong>多个例子中的向量化</strong></h2><p>对于m个训练样本，我们也可以使用矩阵相乘的形式来提高计算效率。</p><p>对于每个样本i，可以使用for循环来求解其正向输出：</p><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%B8%80%20%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%20e2b37696f2cf4267b32cb45a9e7e25fe/Untitled%2037.png" alt="Untitled"></p><p>不使用for循环，利用矩阵运算的思想，输入矩阵X的维度为（nx,m）。这样，我们可以把上面的for循环写成矩阵运算的形式：</p><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%B8%80%20%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%20e2b37696f2cf4267b32cb45a9e7e25fe/Untitled%2038.png" alt="Untitled"></p><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%B8%80%20%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%20e2b37696f2cf4267b32cb45a9e7e25fe/Untitled%2039.png" alt="Untitled"></p><h3 id="维度理解："><a href="#维度理解：" class="headerlink" title="维度理解："></a><strong>维度理解：</strong></h3><p>行表示神经元个数，列表是样本数</p><h2 id="4-5-激活函数"><a href="#4-5-激活函数" class="headerlink" title="4.5 激活函数"></a>4.5 <strong>激活函数</strong></h2><p>神经网络隐藏层和输出层都需要激活函数（activation function）。之前我们使用的是Sigmoid函数作为激活函数，下面是几个不同的激活函数：</p><p>sigmoid函数</p><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%B8%80%20%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%20e2b37696f2cf4267b32cb45a9e7e25fe/Untitled%2040.png" alt="Untitled"></p><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%B8%80%20%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%20e2b37696f2cf4267b32cb45a9e7e25fe/Untitled%2041.png" alt="Untitled"></p><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%B8%80%20%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%20e2b37696f2cf4267b32cb45a9e7e25fe/Untitled%2042.png" alt="Untitled"></p><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%B8%80%20%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%20e2b37696f2cf4267b32cb45a9e7e25fe/Untitled%2043.png" alt="Untitled"></p><h3 id="如何选择合适的激活函数呢？"><a href="#如何选择合适的激活函数呢？" class="headerlink" title="如何选择合适的激活函数呢？"></a><strong>如何选择合适的激活函数呢？</strong></h3><p>首先我们来比较sigmoid函数和tanh函数。对于隐藏层的激活函数，一般来说，tanh函数要比sigmoid函数表现更好一些。因为tanh函数的取值范围在[-1,+1]之间，隐藏层的输出被限定在[-1,+1]之间，可以看成是在0值附近分布，均值为0。这样从隐藏层到输出层，数据起到了归一化（均值为0）的效果。因此，隐藏层的激活函数，tanh比sigmoid更好一些。而对于输出层的激活函数，因为二分类问题的输出取值为{0,+1}，所以一般会选择sigmoid作为激活函数。</p><p>观察sigmoid函数和tanh函数，我们发现有这样一个问题，就是当|z|很大的时候，激活函数的斜率（梯度）很小。因此，在这个区域内，梯度下降算法会运行得比较慢。在实际应用中，应尽量避免使z落在这个区域，使|z|尽可能限定在零值附近，从而<strong>提高梯度下降算法运算速度。</strong></p><p>为了弥补sigmoid函数和tanh函数的这个缺陷，就出现了ReLU激活函数。ReLU激活函数在z大于零时梯度始终为1；在z小于零时梯度始终为0；z等于零时的梯度可以当成1也可以当成0，实际应用中并不影响。对于隐藏层，选择ReLU作为激活函数能够保证z大于零时梯度始终为1，从而提高神经网络梯度下降算法运算速度。<strong>但当z小于零时，存在梯度为0的缺点</strong>，<strong>实际应用中，这个缺点影响不是很大</strong>。为了弥补这个缺点，出现了Leaky ReLU激活函数，能够保证z小于零是梯度不为0。</p><p>最后<strong>总结一下</strong>，如果是<strong>分类问题</strong>，输出层的激活函数<strong>一般会选择sigmoid函数</strong>。但是<strong>隐藏层</strong>的激活函数通常<strong>不会选择sigmoid函数</strong>，<strong>tanh函数的表现会比sigmoid函数好一些</strong>。实际应用中，<strong>通常会会选择使用ReLU或者Leaky ReLU函数</strong>，保证梯度下降速度不会太小。其实，具体选择哪个函数作为激活函数<strong>没有一个固定的准确的答案</strong>，应该要根据具体实际问题进行验证（validation）。</p><h2 id="4-6-为什么需要非线性激活函数？"><a href="#4-6-为什么需要非线性激活函数？" class="headerlink" title="4.6 为什么需要非线性激活函数？"></a>4.6 <strong>为什么需要非线性激活函数？</strong></h2><p>如果使用线性激活函数，最终得到的结果仍然是输入变量x的线性组合，即使用神经网络与直接使用线性模型的效果并没有什么两样。即便是包含多层隐藏层的神经网络，如果使用线性函数作为激活函数，最终的输出仍然是输入x的线性模型。这样的话神经网络就没有任何作用了。因此，隐藏层的激活函数必须要是非线性的。</p><p>但如果是预测问题而不是分类问题，输出y是连续的情况下，输出层的激活函数可以使用线性函数。如果输出y恒为正值，也可以使用ReLU激活函数，这里需要具体问题具体分析。</p><h2 id="4-7-激活函数的导数"><a href="#4-7-激活函数的导数" class="headerlink" title="4.7 激活函数的导数"></a>4.7 <strong>激活函数的导数</strong></h2><p>在梯度下降反向计算过程中少不了计算激活函数的导数即梯度。</p><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%B8%80%20%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%20e2b37696f2cf4267b32cb45a9e7e25fe/Untitled%2044.png" alt="Untitled"></p><h2 id="4-8-神经网络的梯度下降法"><a href="#4-8-神经网络的梯度下降法" class="headerlink" title="4.8 神经网络的梯度下降法"></a>4.8 <strong>神经网络的梯度下降法</strong></h2><h3 id="正向传播"><a href="#正向传播" class="headerlink" title="正向传播"></a><strong>正向传播</strong></h3><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%B8%80%20%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%20e2b37696f2cf4267b32cb45a9e7e25fe/Untitled%2045.png" alt="Untitled"></p><h3 id="反向传播"><a href="#反向传播" class="headerlink" title="反向传播"></a><strong>反向传播</strong></h3><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%B8%80%20%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%20e2b37696f2cf4267b32cb45a9e7e25fe/Untitled%2046.png" alt="Untitled"></p><h3 id="直观表示"><a href="#直观表示" class="headerlink" title="直观表示"></a><strong>直观表示</strong></h3><p>对于单个训练样本</p><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%B8%80%20%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%20e2b37696f2cf4267b32cb45a9e7e25fe/Untitled%2047.png" alt="Untitled"></p><p>总结一下，浅层神经网络（包含一个隐藏层），m个训练样本的正向传播过程和反向传播过程分别包含了6个表达式，其<strong>向量化矩阵</strong>形式如下图所示：</p><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%B8%80%20%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%20e2b37696f2cf4267b32cb45a9e7e25fe/Untitled%2048.png" alt="Untitled"></p><h2 id="4-9-随机初始化"><a href="#4-9-随机初始化" class="headerlink" title="4.9 随机初始化"></a>4.9 <strong>随机初始化</strong></h2><p><strong>神经网络模型中的参数权重W是不能全部初始化为零的，会导致隐藏层设置的多个神经元没有意义。但参数b可以初始化为0，并不会影响神经网络训练效果。</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">W_1</span> = np.<span class="property">random</span>.<span class="title function_">randn</span>((<span class="number">2</span>,<span class="number">2</span>))*<span class="number">0.01</span></span><br><span class="line">b_1 = np.<span class="title function_">zero</span>((<span class="number">2</span>,<span class="number">1</span>))</span><br><span class="line"><span class="variable constant_">W_2</span> = np.<span class="property">random</span>.<span class="title function_">randn</span>((<span class="number">1</span>,<span class="number">2</span>))*<span class="number">0.01</span></span><br><span class="line">b_2 = <span class="number">0</span></span><br></pre></td></tr></table></figure><p><strong>乘以0.01的目的是希望初始化得到的W值尽量小，使用sigmoid函数或者tanh函数时能使z也比较小，提高梯度下降算法的运算速度。</strong>如果激活函数是ReLU或者Leaky ReLU函数，不需要考虑这个问题。但是，如果输出层是sigmoid函数，则对应的权重W最好初始化到比较小的值。</p><h1 id="第五节-深层神经网络"><a href="#第五节-深层神经网络" class="headerlink" title="第五节 深层神经网络"></a>第五节 深层神经网络</h1><h2 id="5-1-深层神经网络"><a href="#5-1-深层神经网络" class="headerlink" title="5.1 深层神经网络"></a>5.1 <strong>深层神经网络</strong></h2><p>深层神经网络其实就是包含更多的隐藏层神经网络。下图分别列举了逻辑回归、1个隐藏层的神经网络、2个隐藏层的神经网络和5个隐藏层的神经网络它们的模型结构。</p><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%B8%80%20%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%20e2b37696f2cf4267b32cb45a9e7e25fe/Untitled%2049.png" alt="Untitled"></p><p>命名规则上，<strong>一般只参考隐藏层个数和输出层。</strong>例如，上图中的逻辑回归又叫1 layer NN，1个隐藏层的神经网络叫做2 layer NN，2个隐藏层的神经网络叫做3 layer NN，以此类推。如果是L-layer NN，则<strong>包含了L-1个隐藏层</strong>，<strong>最后的L层是输出层。</strong></p><h3 id="标记写法"><a href="#标记写法" class="headerlink" title="标记写法"></a><strong>标记写法</strong></h3><p>首先，总层数用L表示，L=4。输入层是第0层，输出层是第L层。</p><p>n[l]表示第l层包含的单元个数，l=0,1,⋯,L。这个模型中，n[0]=nx=3，</p><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%B8%80%20%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%20e2b37696f2cf4267b32cb45a9e7e25fe/Untitled%2050.png" alt="Untitled"></p><h2 id="5-2-深层网络中的前向传播"><a href="#5-2-深层网络中的前向传播" class="headerlink" title="5.2 深层网络中的前向传播"></a>5.2 <strong>深层网络中的前向传播</strong></h2><h3 id="单个样本：-2"><a href="#单个样本：-2" class="headerlink" title="单个样本："></a><strong>单个样本：</strong></h3><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%B8%80%20%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%20e2b37696f2cf4267b32cb45a9e7e25fe/Untitled%2051.png" alt="Untitled"></p><h3 id="m个样本"><a href="#m个样本" class="headerlink" title="m个样本"></a><strong>m个样本</strong></h3><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%B8%80%20%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%20e2b37696f2cf4267b32cb45a9e7e25fe/Untitled%2052.png" alt="Untitled"></p><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%B8%80%20%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%20e2b37696f2cf4267b32cb45a9e7e25fe/Untitled%2053.png" alt="Untitled"></p><h2 id="5-3-核对矩阵的维数"><a href="#5-3-核对矩阵的维数" class="headerlink" title="5.3 核对矩阵的维数"></a>5.3 <strong>核对矩阵的维数</strong></h2><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%B8%80%20%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%20e2b37696f2cf4267b32cb45a9e7e25fe/Untitled%2054.png" alt="Untitled"></p><p>n[l]和n[l−1]分别表示第l层和l−1层的所含单元个数。n[0]=nx，表示输入层特征数目。</p><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%B8%80%20%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%20e2b37696f2cf4267b32cb45a9e7e25fe/Untitled%2055.png" alt="Untitled"></p><p>注意到，W[l]与dW[l]维度相同，b[l]与db[l]维度相同。这很容易理解。</p><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%B8%80%20%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%20e2b37696f2cf4267b32cb45a9e7e25fe/Untitled%2056.png" alt="Untitled"></p><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%B8%80%20%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%20e2b37696f2cf4267b32cb45a9e7e25fe/Untitled%2057.png" alt="Untitled"></p><h2 id="5-4-为什么使用深层表示"><a href="#5-4-为什么使用深层表示" class="headerlink" title="5.4 为什么使用深层表示"></a>5.4 <strong>为什么使用深层表示</strong></h2><h3 id="更准确"><a href="#更准确" class="headerlink" title="更准确"></a><strong>更准确</strong></h3><p>多，神经网络就更加复杂和深入，学习也更加准确。</p><p>先来看人脸识别的例子，如下图所示。经过训练，神经网络第一层所做的事就是从原始图片中提取出人脸的轮廓与边缘，即边缘检测。这样每个神经元得到的是一些边缘信息。神经网络第二层所做的事情就是将前一层的边缘进行组合，组合成人脸一些局部特征，比如眼睛、鼻子、嘴巴等。再往后面，就将这些局部特征组合起来，融合成人脸的模样。可以看出，随着层数由浅到深，神经网络提取的特征也是从边缘到局部特征到整体，由简单到复杂。可见，如果隐藏层足够多，那么能够提取的特征就越丰富、越复杂，模型的准确率就会越高。</p><p>语音识别模型也是这个道理。<strong>浅层的神经元能够检测一些简单的音调</strong>，然后<strong>较深的神经元能够检测出基本的音素</strong>，<strong>更深的神经元就能够检测出单词信息</strong>。如果网络够深，还能对短语、句子进行检测。记住一点，神经网络<strong>从左到右</strong>，神经元提取的<strong>特征从简单到复杂</strong>。特征复杂度与神经网络层数成正相关。<strong>特征越来越复杂，功能也越来越强大。</strong></p><h3 id="减少神经元个数、减少计算量"><a href="#减少神经元个数、减少计算量" class="headerlink" title="减少神经元个数、减少计算量"></a><strong>减少神经元个数、减少计算量</strong></h3><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%B8%80%20%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%20e2b37696f2cf4267b32cb45a9e7e25fe/Untitled%2058.png" alt="Untitled"></p><p>如果不用深层网络，仅仅使用单个隐藏层，那么需要的神经元个数将是指数级别那么大。</p><p>尽管深度学习有着非常显著的优势，Andrew还是建议对实际问题进行建模时，尽量先选择层数少的神经网络模型，这也符合奥卡姆剃刀定律（Occam’s Razor）。对于比较复杂的问题，再使用较深的神经网络模型。</p><h2 id="5-5-搭建深层神经网络块"><a href="#5-5-搭建深层神经网络块" class="headerlink" title="5.5 搭建深层神经网络块"></a>5.5 <strong>搭建深层神经网络块</strong></h2><p>如下图所示，对于第l层来说，正向传播过程中：</p><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%B8%80%20%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%20e2b37696f2cf4267b32cb45a9e7e25fe/Untitled%2059.png" alt="Untitled"></p><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%B8%80%20%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%20e2b37696f2cf4267b32cb45a9e7e25fe/Untitled%2060.png" alt="Untitled"></p><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%B8%80%20%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%20e2b37696f2cf4267b32cb45a9e7e25fe/Untitled%2061.png" alt="Untitled"></p><h2 id="5-6-前向和反向传播"><a href="#5-6-前向和反向传播" class="headerlink" title="5.6 前向和反向传播"></a>5.6 <strong>前向和反向传播</strong></h2><h3 id="正向传播过程"><a href="#正向传播过程" class="headerlink" title="正向传播过程"></a><strong>正向传播过程</strong></h3><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%B8%80%20%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%20e2b37696f2cf4267b32cb45a9e7e25fe/Untitled%2062.png" alt="Untitled"></p><h3 id="反向传播过程"><a href="#反向传播过程" class="headerlink" title="反向传播过程"></a><strong>反向传播过程</strong></h3><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%B8%80%20%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%20e2b37696f2cf4267b32cb45a9e7e25fe/Untitled%2063.png" alt="Untitled"></p><p><img src="/2022/05/20/AI/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%90%B4%E6%81%A9%E8%BE%BE/%E7%AB%A0%E4%B8%80%20%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%20e2b37696f2cf4267b32cb45a9e7e25fe/Untitled%2064.png" alt="Untitled"></p><h2 id="5-7-参数VS超参数"><a href="#5-7-参数VS超参数" class="headerlink" title="5.7 参数VS超参数"></a>5.7 <strong>参数VS超参数</strong></h2><p>该部分介绍神经网络中的<strong>参数（parameters）</strong>和<strong>超参数（hyper parameters）</strong>的概念。</p><p>神经网络中的参数就是我们熟悉的W[l]W[l]和b[l]b[l]。而超参数则是例如学习速率αα，训练迭代次数N，神经网络层数L，各层神经元个数n[l]n[l]，激活函数g(z)g(z)等。之所以叫做超参数的原因是它们决定了参数W[l]W[l]和b[l]b[l]的值。</p><p>如何设置最优的超参数是一个比较困难的、需要经验知识的问题。通常的做法是选择超参数一定范围内的值，分别代入神经网络进行训练，测试cost function随着迭代次数增加的变化，根据结果选择cost function最小时对应的超参数值。</p><h2 id="5-8-这和大脑有什么关系-（略）"><a href="#5-8-这和大脑有什么关系-（略）" class="headerlink" title="5.8 这和大脑有什么关系?（略）"></a>5.8 <strong>这和大脑有什么关系?（略）</strong></h2>]]></content>
      
      
      <categories>
          
          <category> AI </category>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 《深度学习》吴恩达 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux下Anaconda3整体迁移至其他磁盘</title>
      <link href="/2022/02/16/%E5%B7%A5%E5%85%B7/Linux%E4%B8%8BAnaconda3%E6%95%B4%E4%BD%93%E8%BF%81%E7%A7%BB%E8%87%B3%E5%85%B6%E4%BB%96%E7%A3%81%E7%9B%98/"/>
      <url>/2022/02/16/%E5%B7%A5%E5%85%B7/Linux%E4%B8%8BAnaconda3%E6%95%B4%E4%BD%93%E8%BF%81%E7%A7%BB%E8%87%B3%E5%85%B6%E4%BB%96%E7%A3%81%E7%9B%98/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux-下-Anaconda3-整体迁移至其他磁盘"><a href="#Linux-下-Anaconda3-整体迁移至其他磁盘" class="headerlink" title="Linux 下 Anaconda3 整体迁移至其他磁盘"></a>Linux 下 Anaconda3 整体迁移至其他磁盘</h1><blockquote><p>  问题描述：</p><p>  Anaconda3安装好之后，创建了一些环境并且安装了许多包，整个Anaconda3文件夹占空间很大。比如我的文件夹就达到了18G，如果home目录还比较小，可能导致服务器无法使用。</p><p>  又因为不想删除原有软件/环境，再在其他位置安装；最好是直接迁移至其他盘。</p></blockquote><p>查看<code>anaconda</code>占用空间<code>du -h --max-depth=1</code></p><p><img src="/2022/02/16/%E5%B7%A5%E5%85%B7/Linux%E4%B8%8BAnaconda3%E6%95%B4%E4%BD%93%E8%BF%81%E7%A7%BB%E8%87%B3%E5%85%B6%E4%BB%96%E7%A3%81%E7%9B%98/image-20220216173912160.png" alt="image-20220216173912160"></p><p>可以看到足足占用了有18G。</p><h2 id="一、（失败）直接迁移-修改环境变量"><a href="#一、（失败）直接迁移-修改环境变量" class="headerlink" title="一、（失败）直接迁移+修改环境变量"></a>一、（失败）直接迁移+修改环境变量</h2><blockquote><p>  本来是没有找到linux下的，查到的资料都是在window下的；win下的方法是迁移目录，然后修改环境变量。</p><p>  所以感觉linux下思路大致也是如此，就是怕安装的时候conda有一些配置在某些地方写死了，这么直接修改环境变量可能行不通。</p></blockquote><p>反正直接开始尝试了，想着反正先是拷贝，出错了再拷回来就完了，实在不行只好重装了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cp -a ~/anaconda3 /extended_disk# 拷贝到大容量的磁盘 cp -a 可以拷贝更多信息</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">这里具体修改的内容 就是 有一段 conda init 里面的内容</span></span><br><span class="line">vim ~/.zshrc# 修改里面的 环境变量，相关的路径都替换了</span><br><span class="line">vim ~/.bashrc# 后来不成功把这个也改了</span><br><span class="line"></span><br><span class="line">rm -rf ~/anaconda3# 删除原有的，其实合并起来用 mv 也行</span><br></pre></td></tr></table></figure><p>修改完了之后，删除原有conda，重新连接服务器。（删除了原有的再测试）</p><p>然后发现行不通。问题1：报的错包括找不到<code>conda</code>，也就是环境变量没配置成功，后来尝试反复修改环境变量（包括其他位置），走不通。</p><p>问题2：再试手动指出<code>conda</code>的位置，执行<code>/ext.../conda activate base</code>发现提示找不到<code>python</code>可执行程序。（也就说明不是环境变量的问题）到这里就感觉其实在conda安装过程中肯定是把某些配置写死在某个地方了。</p><p>单纯迁移和修改环境变量行不通。</p><blockquote><p>  这里灵机一动，不如创建一个同名软连接，但是不知道会不会导致一些操作出错，比如创环境什么的。</p></blockquote><h2 id="二、（修复）添加软连接"><a href="#二、（修复）添加软连接" class="headerlink" title="二、（修复）添加软连接"></a>二、（修复）添加软连接</h2><p>在前面的基础上（迁移<code>conda</code>文件夹），在<code>home</code>目录直接新建一个同名软链接指向新目录即可。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -s /extended_disk/anaconda3 ~/anaconda3  # 添加软连接，注意修改自己的目录</span><br></pre></td></tr></table></figure><p><img src="/2022/02/16/%E5%B7%A5%E5%85%B7/Linux%E4%B8%8BAnaconda3%E6%95%B4%E4%BD%93%E8%BF%81%E7%A7%BB%E8%87%B3%E5%85%B6%E4%BB%96%E7%A3%81%E7%9B%98/image-20220216174550210.png" alt="image-20220216174550210"></p><p>再进行各种测试（python、创环境、删除等等操作），完美。</p><blockquote><p>  注意：</p><p>  可能有的问题，删除原有文件夹的时候可能会删不干净，导致创建软连接的时候不成功，还是个文件夹，导致失败。</p><p>  当时打开软连接的时候发现里面竟然有一两个奇奇怪怪的文件夹，肯定是搞错了。所以删除的地方要 <code>rm -rf</code></p></blockquote><h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p>就两步：</p><p>1、完整迁移目录</p><p>2、添加软链接，无需改环境变量</p><p>当然，最好是一开始就安装在其他地方或者使用<code>miniconda</code></p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VSCode远程开发</title>
      <link href="/2022/01/11/%E5%B7%A5%E5%85%B7/VSCode%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
      <url>/2022/01/11/%E5%B7%A5%E5%85%B7/VSCode%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="VSCode远程开发"><a href="#VSCode远程开发" class="headerlink" title="VSCode远程开发"></a>VSCode远程开发</h1><h2 id="一、配置免密远程登录服务器"><a href="#一、配置免密远程登录服务器" class="headerlink" title="一、配置免密远程登录服务器"></a>一、配置免密远程登录服务器</h2><blockquote><p>  ssh 公钥认证是一种方便、高安全性的身份验证方法，它将本地“私有”密钥与远程主机上与用户关联的“公共”密钥进行匹配，从而实现免密登录。</p><p>  密钥对：在非对称加密技术中，有两种密钥，分为私钥和公钥，私钥是密钥对所有者持有，不可公布，公钥是密钥对持有者公布给他人的。</p><p>  公钥：公钥用来给数据加密，用公钥加密的数据只能使用私钥解密</p><p>  私钥：用来解密公钥加密的数据</p></blockquote><p>简而言之，就是ssh远程连接的时候无需输入密码。</p><p>第一步，需要创建密钥对</p><h3 id="1、生成密钥对"><a href="#1、生成密钥对" class="headerlink" title="1、生成密钥对"></a>1、生成密钥对</h3><blockquote><p>  <code>Win</code>下可以安装<code>git</code>，或者<code>OpenSSH</code>，会带有<code>ssh-keygen.exe</code>，用于生成密钥对</p><p>  <code>Linux</code>下应该环境自带</p></blockquote><p>在已有生成密钥程序<code>ssh-keygen.exe</code>后</p><p>首先，运行下述命令生成密钥对，将会以你的邮箱作为标签创建一个新的SSH密钥</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">&quot;example@qq.com&quot;</span></span><br></pre></td></tr></table></figure><p>之后便会提示正在生成，并询问存储位置，直接回车选择保存到默认位置</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Generating public/private rsa key pair.</span><br><span class="line">Enter a file <span class="keyword">in</span> <span class="built_in">which</span> to save the key (/Users/you/.ssh/id_rsa): [Press enter]</span><br></pre></td></tr></table></figure><p>在提示符下，输入安全密码，即可生成一个新的ssh密钥。这里的安全密码用于使用此密钥时需要输入此时的密码来解锁。（这里不解释为什么还需要设置一重密码）</p><p>直接回车为空</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; Enter passphrase (empty for no passphrase): [Type a passphrase]</span><br><span class="line">&gt; Enter same passphrase again: [Type passphrase again]</span><br></pre></td></tr></table></figure><p>到这里就生成好了，会提示你生成的密钥对的位置，通常位于：</p><blockquote><p>  <code>Win</code>:<code>C\Users\Name\.ssh</code></p><p>  <code>Linux</code>:<code>~/.ssh/</code></p></blockquote><p>这里面有几个文件比较重要：</p><blockquote><p>  <code>id_rsa</code>：私钥<code>【这个千万不能泄露】</code></p><p>  <code>id_rsa.pub</code>：公钥</p><p>  <code>known_hosts</code>：一些服务器的记录</p><p>  【<code>authorized_keys</code>：通常是服务器上的文件，记录客户端的公钥】</p><p>  【<code>config</code>：VSCode生成的配置文件（之后才有的）】</p></blockquote><h3 id="2、使用密钥对"><a href="#2、使用密钥对" class="headerlink" title="2、使用密钥对"></a>2、使用密钥对</h3><blockquote><p>  注意，这里说的都是使用公钥</p></blockquote><p>拷贝公钥到服务器实现免密登录</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-copy-id -i /mnt/c/Users/name/.ssh/id_rsa.pub -p 22 root@122.112.xxx.xxx</span><br></pre></td></tr></table></figure><p>之后再尝试远程连接便会发现无需输入密码了。</p><p>当然，这里还有其他的用处，比如用到<code>github</code>上</p><h2 id="二、VSCode远程开发"><a href="#二、VSCode远程开发" class="headerlink" title="二、VSCode远程开发"></a>二、VSCode远程开发</h2><blockquote><p>  <code>VScode</code>发布了远程编程与调试的插件<code>Remote Development</code>，使用这个插件可以在很多情况下代替vim直接远程修改与调试服务器上的代码，同时具备代码高亮与补全功能，就和在本地使用<code>VScode</code>一样。终于不用在服务器端翻来覆去的配置vim插件了。</p><p>  其中的<code>Remote Containers</code>，<code>Remote SSH</code>都是非常Nice的。</p></blockquote><h3 id="1、下载插件"><a href="#1、下载插件" class="headerlink" title="1、下载插件"></a>1、下载插件</h3><p><img src="/2022/01/11/%E5%B7%A5%E5%85%B7/VSCode%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5%E6%9C%8D%E5%8A%A1%E5%99%A8/image-20220111220225815.png" alt="image-20220111220225815"></p><p>下载安装即可，之后便会多出一个标签页</p><p><img src="/2022/01/11/%E5%B7%A5%E5%85%B7/VSCode%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5%E6%9C%8D%E5%8A%A1%E5%99%A8/image-20220111220327965.png" alt="image-20220111220327965"></p><h3 id="2、配置插件"><a href="#2、配置插件" class="headerlink" title="2、配置插件"></a>2、配置插件</h3><p>打开标签页，如下所示</p><p><img src="/2022/01/11/%E5%B7%A5%E5%85%B7/VSCode%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5%E6%9C%8D%E5%8A%A1%E5%99%A8/image-20220111221515764.png" alt="image-20220111221515764"></p><p>先点击 <code>+</code>号，新建一个连接，按照提示输入远程连接命令：<code>ssh name@ip</code></p><p>之后会提示输入密码，登录。这样我们便连接上了服务器，可以看到用户目录了，与本地使用VScode一致。</p><blockquote><p>  那么怎么用上我们之前配置的公钥呢？</p></blockquote><p><img src="/2022/01/11/%E5%B7%A5%E5%85%B7/VSCode%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5%E6%9C%8D%E5%8A%A1%E5%99%A8/image-20220111221745781.png" alt="image-20220111221745781"></p><p>点开加号旁边的设置按钮，会弹出<code>config</code>文件的列表，比如我们打开<code>C盘</code>底下的<code>config</code>文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Host ServerName</span><br><span class="line">HostName 10.xx.xx.xxx</span><br><span class="line">User username</span><br><span class="line">Port 22</span><br><span class="line">IdentityFile C:\\Users\\name\\.ssh\\id_rsa</span><br></pre></td></tr></table></figure><blockquote><p>  说明：</p><p>  <code>Host</code>：服务器的一个别称</p><p>  <code>HostName</code>：服务器<code>ip</code></p><p>  <code>User</code>：用户名</p><p>  <code>Port</code>：服务器端口，默认<code>22</code></p><p>  <code>IdentityFile</code>：本机私钥位置</p></blockquote><p>保存文件后，左边的<code>SSH TARGETS</code>列表中就会看到刚添加的服务器（指定的服务器别称）</p><p><img src="/2022/01/11/%E5%B7%A5%E5%85%B7/VSCode%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5%E6%9C%8D%E5%8A%A1%E5%99%A8/image-20220111222623313.png" alt="image-20220111222623313"></p><p>之后再连接服务器只需要在此页面免密连接服务器即可。</p><h2 id="三、参考"><a href="#三、参考" class="headerlink" title="三、参考"></a>三、参考</h2><blockquote><p>  <a href="https://zhuanlan.zhihu.com/p/134349361">SSH 公钥 私钥的理解 - 知乎 (zhihu.com)</a></p><p>  <a href="https://zhuanlan.zhihu.com/p/95678121">VScode 的远程开发，体验后爽翻 - 知乎 (zhihu.com)</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 服务器 </tag>
            
            <tag> 远程连接 </tag>
            
            <tag> VSCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker+nginx部署SpringBoot+vue前后端分离项目</title>
      <link href="/2022/01/09/%E5%89%8D%E5%90%8E%E7%AB%AF/Docker-nginx%E9%83%A8%E7%BD%B2SpringBoot-vue%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E9%A1%B9%E7%9B%AE/"/>
      <url>/2022/01/09/%E5%89%8D%E5%90%8E%E7%AB%AF/Docker-nginx%E9%83%A8%E7%BD%B2SpringBoot-vue%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E9%A1%B9%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="Docker-nginx部署SpringBoot-vue前后端分离项目"><a href="#Docker-nginx部署SpringBoot-vue前后端分离项目" class="headerlink" title="Docker+nginx部署SpringBoot+vue前后端分离项目"></a>Docker+nginx部署SpringBoot+vue前后端分离项目</h1><h2 id="一、配置环境"><a href="#一、配置环境" class="headerlink" title="一、配置环境"></a>一、配置环境</h2><h3 id="1、Docker安装"><a href="#1、Docker安装" class="headerlink" title="1、Docker安装"></a>1、Docker安装</h3><p>从Ubuntu的仓库直接下载安装。安装比较简单，但是这种安装的Docker不是最新版本。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装</span></span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt install docker.io</span><br><span class="line"><span class="comment"># 启动服务</span></span><br><span class="line">sudo systemctl start docker</span><br><span class="line">sudo systemctl <span class="built_in">enable</span> docker</span><br></pre></td></tr></table></figure><p>查看是否成功，输出</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; docker -v</span><br><span class="line"></span><br><span class="line">Docker version 20.10.7, build 20.10.7-0ubuntu5~18.04.3</span><br></pre></td></tr></table></figure><h3 id="2、安装Docker-compose"><a href="#2、安装Docker-compose" class="headerlink" title="2、安装Docker-compose"></a>2、安装Docker-compose</h3><blockquote><p>  <a href="https://docs.docker.com/compose/install/">Install Docker Compose | Docker Documentation</a></p></blockquote><p>进入<a href="https://github.com/docker/compose/releases">https://github.com/docker/compose/releases</a> 查看最新版本</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo curl -L https://github.com/docker/compose/releases/download/1.23.1/docker-compose-`<span class="built_in">uname</span> -s`-`<span class="built_in">uname</span> -m` -o /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure><p>设置权限</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">chmod</span> +x /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure><p>查看是否安装成功</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; docker-compose --version</span><br><span class="line"></span><br><span class="line">docker-compose version 1.23.1, build b02f1306</span><br></pre></td></tr></table></figure><h2 id="二、编排容器，打包部署"><a href="#二、编排容器，打包部署" class="headerlink" title="二、编排容器，打包部署"></a>二、编排容器，打包部署</h2><h3 id="1、打包JAVA应用容器镜像"><a href="#1、打包JAVA应用容器镜像" class="headerlink" title="1、打包JAVA应用容器镜像"></a>1、打包JAVA应用容器镜像</h3><p>先将java项目打包成jar包，这里不过多说明。如我们的jar包名为：<code>myapp.jar</code></p><p>编写<code>Dockerfile</code>，负责打包java应用</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> java:<span class="number">8</span><span class="comment"># 基于java8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8081</span><span class="comment"># 暴露端口</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> myapp-0.0.1-SNAPSHOT.jar app.jar<span class="comment"># 重命名</span></span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> bash -c <span class="string">&#x27;touch /app.jar&#x27;</span><span class="comment"># </span></span></span><br><span class="line"><span class="comment"># 这里的命令和我们运行jar包的命令是一样的</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;java&quot;</span>, <span class="string">&quot;-jar&quot;</span>, <span class="string">&quot;/app.jar&quot;</span>, <span class="string">&quot;--spring.profiles.active=docker&quot;</span>]</span></span><br></pre></td></tr></table></figure><p>注意：这里暂时这么写就行，打包的工作交给<code>docker-compose</code>自动完成</p><h3 id="2、编写docker-compose-yml文件，编排容器"><a href="#2、编写docker-compose-yml文件，编排容器" class="headerlink" title="2、编写docker-compose.yml文件，编排容器"></a>2、编写<code>docker-compose.yml</code>文件，编排容器</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">nginx:</span>                  <span class="comment"># 服务名称</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:latest</span>   <span class="comment"># 镜像最新的nginx</span></span><br><span class="line">    <span class="attr">ports:</span>                <span class="comment"># 暴露端口</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">80</span><span class="string">:80</span>             <span class="comment"># 宿主机端口：容器端口</span></span><br><span class="line">    <span class="attr">volumes:</span>              <span class="comment"># 挂载      格式：宿主文件夹:容器内部文件夹</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/root/nginx/html:/usr/share/nginx/html</span>        <span class="comment"># vue前端页面</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/root/nginx/nginx.conf:/etc/nginx/nginx.conf</span>  <span class="comment"># nginx 配置文件</span></span><br><span class="line">    <span class="attr">privileged:</span> <span class="literal">true</span>      <span class="comment"># nginx内部文件调用权限问题，不然可以无法使用上述文件</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">mysql:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql:5.7.27</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">3306</span><span class="string">:3306</span>  <span class="comment"># mysql可以选择不暴露的，也更安全</span></span><br><span class="line">    <span class="attr">environment:</span>  <span class="comment"># 配置mysql root用户密码</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">MYSQL_ROOT_PASSWORD=root</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">redis:latest</span></span><br><span class="line">  <span class="comment"># 这个就是自己打包的java应用，需要自己构建</span></span><br><span class="line">  <span class="attr">myapp:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">myapp:latest</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">.</span>    <span class="comment"># 指定这个需要构建的Dockerfile文件所在目录，如果dockerfile和conpose放在一起就 .</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">8081</span><span class="string">:8081</span></span><br><span class="line">    <span class="attr">depends_on:</span> <span class="comment"># 依赖其他容器，但是默认已经是相互依赖的，写不写无所谓</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">mysql</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">redis</span></span><br></pre></td></tr></table></figure><p>当我们按照这个配置编排好容器，运行起来时，即可以理解为，我们已经安装好了需要的服务，如<code>mysql</code>，<code>redis</code>等</p><h3 id="3、更改java项目中的配置文件"><a href="#3、更改java项目中的配置文件" class="headerlink" title="3、更改java项目中的配置文件"></a>3、更改java项目中的配置文件</h3><p>具体来说就是我们之前单独写<code>java</code>项目时，用的可能是本地或者远程的数据库等服务，现在部署的时候需要将这些服务替换成我们编排好的<code>docker</code>服务</p><blockquote><p>  小提示：这里可以新建一个<code>application-docker.yml</code>文件，我们在运行程序时，指定配置文件即可</p><p>  如：<code>JAVA -jar /app.jar --spring.profiles.active=docker</code></p></blockquote><p>这一步执行起来也较为简单，用第二步中的服务名称，如<code>mysql</code>，<code>redis</code>等，替换java项目配置文件中的<code>localhost</code>，<code>服务器ip</code>等即可。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://mysql:3306/...</span></span><br><span class="line"></span><br><span class="line"><span class="string">...</span></span><br><span class="line"></span><br><span class="line"><span class="attr">shiro-redis:</span></span><br><span class="line">  <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">redis-manager:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">redis:6379</span></span><br></pre></td></tr></table></figure><p>这样配置之后，当应用访问<code>mysql</code>等服务时，会自动找到相应容器</p><h3 id="4、部署前端Vue项目"><a href="#4、部署前端Vue项目" class="headerlink" title="4、部署前端Vue项目"></a>4、部署前端Vue项目</h3><h4 id="4-1-打包vue项目"><a href="#4-1-打包vue项目" class="headerlink" title="4.1 打包vue项目"></a>4.1 打包vue项目</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure><p>之后在项目根目录会多出一个<code>dist</code>文件夹，里面的内容就是我们要的，直接将里面的所有内容打包发送至服务器指定的<code>nginx</code>设置的位置<code>/root/nginx/html</code>即可。例如：</p><p><img src="/2022/01/09/%E5%89%8D%E5%90%8E%E7%AB%AF/Docker-nginx%E9%83%A8%E7%BD%B2SpringBoot-vue%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E9%A1%B9%E7%9B%AE/image-20220112185020221.png" alt="image-20220112185020221"></p><h4 id="4-2-编写nginx-conf文件"><a href="#4-2-编写nginx-conf文件" class="headerlink" title="4.2 编写nginx.conf文件"></a>4.2 编写<code>nginx.conf</code>文件</h4><p>有两点需要注意：</p><p>1、删除了注释，加上一句话<code>try_files</code>，针对<code>vue</code>打包的项目的</p><p>2、指定根目录为<code>/usr/share/nginx/html</code>，这里和<code>compose</code>中的配置是对应的，指的是<code>nginx</code>容器中映射的位置。</p><p>详细<code>nginx.conf</code>配置文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#user   root;</span><br><span class="line">worker_processes    1;</span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections    1024;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    include         mime.types;</span><br><span class="line">    default_type    application/octet-stream;</span><br><span class="line"></span><br><span class="line">    sendfile        on;</span><br><span class="line">    keepalive_timeout   65;</span><br><span class="line"></span><br><span class="line">    server  &#123;</span><br><span class="line">        listen      80;</span><br><span class="line">        server_name localhost;</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">            root    /usr/share/nginx/html; # 注意这里是 容器中的位置，不是宿主机的位置</span><br><span class="line">            try_files   $uri $uri/ /index.html last;        # 主要就是加上这一行了</span><br><span class="line">            index   index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line">        error_page  500 502 503 504     /50x.html;</span><br><span class="line">        location = /50x.html &#123;</span><br><span class="line">            root    html;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后呢，我们需要把打包的文件放入宿主机的<code>/root/nginx/html</code>中，容器就可以在<code>/usr/share/nginx/html</code>中找到文件啦(这里的两个文件夹在前文中<code>docker-compose.yaml</code>设置过了)</p><p>将<code>nginx.conf</code>文件放入<code>/root/nginx/nginx.conf</code>（这个位置也是前文设置的）</p><h3 id="5、一切就绪，部署"><a href="#5、一切就绪，部署" class="headerlink" title="5、一切就绪，部署"></a>5、一切就绪，部署</h3><p>将<code>jar包</code>，<code>Dockerfile</code>，<code>docker-compose.yml</code>一起上传至服务器，准备打包，这里最好是同一位置（其他位置也行，compose文件里面配置了自己要打包的镜像的位置，只要能找到就行）</p><p><img src="/2022/01/09/%E5%89%8D%E5%90%8E%E7%AB%AF/Docker-nginx%E9%83%A8%E7%BD%B2SpringBoot-vue%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E9%A1%B9%E7%9B%AE/image-20220112192820674.png" alt="image-20220112192820674"></p><p>详细文件目录为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── docker-compose.yml# 编排配置文件</span><br><span class="line">├── Dockerfile# 构建镜像</span><br><span class="line">├── myapp-0.0.1-SNAPSHOT.jar# 后端应用</span><br><span class="line">└── nginx# 前端目录</span><br><span class="line">    ├── html # VUE打包项目</span><br><span class="line">    │   ├── css</span><br><span class="line">    │   ├── favicon.ico</span><br><span class="line">    │   ├── fonts</span><br><span class="line">    │   ├── img</span><br><span class="line">    │   ├── index.html</span><br><span class="line">    │   └── js</span><br><span class="line">    └── nginx.conf# nginx 配置文件           </span><br></pre></td></tr></table></figure><h4 id="拉取、构建镜像，以服务形式运行"><a href="#拉取、构建镜像，以服务形式运行" class="headerlink" title="拉取、构建镜像，以服务形式运行"></a>拉取、构建镜像，以服务形式运行</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up -d  <span class="comment"># -d 以服务形式运行</span></span><br></pre></td></tr></table></figure><p>运行结果：</p><p>先是拉取<code>nginx</code>，<code>mysql</code>，<code>redis</code>镜像</p><p><img src="/2022/01/09/%E5%89%8D%E5%90%8E%E7%AB%AF/Docker-nginx%E9%83%A8%E7%BD%B2SpringBoot-vue%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E9%A1%B9%E7%9B%AE/image-20220112200255925.png" alt="image-20220112200255925"></p><p>构建我们的app：</p><p><img src="/2022/01/09/%E5%89%8D%E5%90%8E%E7%AB%AF/Docker-nginx%E9%83%A8%E7%BD%B2SpringBoot-vue%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E9%A1%B9%E7%9B%AE/image-20220112200350070.png" alt="image-20220112200350070"></p><p><img src="/2022/01/09/%E5%89%8D%E5%90%8E%E7%AB%AF/Docker-nginx%E9%83%A8%E7%BD%B2SpringBoot-vue%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E9%A1%B9%E7%9B%AE/image-20220112200432153.png" alt="image-20220112200432153"></p><p>运行完成</p><blockquote><p>  注意：期间如果遇到构建镜像错误，可能需要删除错误的镜像，停止相应容器等。否则可能一直运行的都是旧的镜像</p><p>  再次注意：这里的mysql仍然没有配置好数据库，需要进入容器，导入数据库</p></blockquote><h2 id="三、参考"><a href="#三、参考" class="headerlink" title="三、参考"></a>三、参考</h2><blockquote><p>  <a href="https://www.bilibili.com/video/BV17A411E7aE?p=5&amp;spm_id_from=333.1007.top_right_bar_window_history.content.click">教你Docker+nginx部署SpringBoot+vue前后端分离项目_哔哩哔哩_bilibili</a></p><p>  <a href="https://www.cnblogs.com/Rcsec/p/10714979.html">Ubuntu18.04安装docker、docker－compose、 - 软刺sec - 博客园 (cnblogs.com)</a></p><p>  <a href="https://blog.csdn.net/winy_lm/article/details/77980529">Docker 删除镜像_点滴记录，积流成河！-CSDN博客_docker 删除镜像</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 前后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> Vue </tag>
            
            <tag> Nginx </tag>
            
            <tag> 前后端 </tag>
            
            <tag> 部署 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PowerShell美化</title>
      <link href="/2020/11/20/%E5%B7%A5%E5%85%B7/PowerShell%E7%BE%8E%E5%8C%96/"/>
      <url>/2020/11/20/%E5%B7%A5%E5%85%B7/PowerShell%E7%BE%8E%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h2 id="PowerShell美化"><a href="#PowerShell美化" class="headerlink" title="PowerShell美化"></a>PowerShell美化</h2><p>先上最终效果图</p><p><img src="/2020/11/20/%E5%B7%A5%E5%85%B7/PowerShell%E7%BE%8E%E5%8C%96/image-20220419135827677.png" alt="image-20220419135827677"></p><p><img src="/2020/11/20/%E5%B7%A5%E5%85%B7/PowerShell%E7%BE%8E%E5%8C%96/image-20220419141105906.png" alt="image-20220419141105906"></p><h3 id="1-安装-windows-terminal"><a href="#1-安装-windows-terminal" class="headerlink" title="1 安装 windows terminal"></a>1 安装 windows terminal</h3><p>有两种方式，一种是微软商店，搜索安装即可。</p><p>另一种是github仓库下载安装，可以安装预览版，也很稳定，就是不用再用微软商店更新了。</p><blockquote><p><a href="https://github.com/Microsoft/Terminal">microsoft/terminal: The new Windows Terminal and the original Windows console host, all in the same place! (github.com)</a></p></blockquote><h3 id="2-安装字体"><a href="#2-安装字体" class="headerlink" title="2 安装字体"></a>2 安装字体</h3><p>因为后面安装的主题可能很多字符显示不了，所以需要安装的新字体。</p><p>推荐的字体的名字是：<code>FiraCode NF</code>。</p><p>先下载字体</p><blockquote><p><a href="https://github.com/ryanoasis/nerd-fonts/releases">Releases · ryanoasis/nerd-fonts (github.com)</a></p></blockquote><p><img src="/2020/11/20/%E5%B7%A5%E5%85%B7/PowerShell%E7%BE%8E%E5%8C%96/image-20220419134021286.png" alt="image-20220419134021286"></p><p>然后安装压缩包里的字体，可以全部安装也可以安装某一个，之后就可以在设置里修改字体了，比如<code>windows terminal</code>或<code>vscode终端</code>字体</p><h3 id="3-安装-powershell-7"><a href="#3-安装-powershell-7" class="headerlink" title="3 安装 powershell 7"></a>3 安装 powershell 7</h3><blockquote><p><a href="https://github.com/PowerShell/PowerShell/releases">Releases · PowerShell/PowerShell (github.com)</a></p></blockquote><h3 id="4-安装Powershell插件"><a href="#4-安装Powershell插件" class="headerlink" title="4 安装Powershell插件"></a>4 安装Powershell插件</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置权限</span></span><br><span class="line"><span class="built_in">Set-ExecutionPolicy</span> RemoteSigned <span class="literal">-Scope</span> CurrentUser</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 安装 PSReadline 包，该插件可以让命令行很好用，类似 zsh</span></span><br><span class="line"><span class="built_in">Install-Module</span> <span class="literal">-Name</span> PSReadLine  <span class="literal">-Scope</span> CurrentUser</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 安装 posh-git 包，让你的 git 更好用</span></span><br><span class="line"><span class="built_in">Install-Module</span> posh<span class="literal">-git</span>  <span class="literal">-Scope</span> CurrentUser</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 安装 oh-my-posh 包，让你的命令行更酷炫、优雅</span></span><br><span class="line"><span class="built_in">Install-Module</span> <span class="built_in">oh</span><span class="literal">-my-posh</span> <span class="literal">-Scope</span> CurrentUser</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 安装 PSColor 包</span></span><br><span class="line"><span class="built_in">Install-Module</span> PSColor <span class="literal">-Scope</span> CurrentUser</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="5-terminal-配置"><a href="#5-terminal-配置" class="headerlink" title="5 terminal 配置"></a>5 terminal 配置</h3><p>有时terminal不能自动识别已经安装了新的powershell，需要手动添加，设置启动位置和图标</p><p><img src="/2020/11/20/%E5%B7%A5%E5%85%B7/PowerShell%E7%BE%8E%E5%8C%96/image-20220419140109816.png" alt="image-20220419140109816"></p><p>更改字体大小，字体、配色方案等等</p><p><img src="/2020/11/20/%E5%B7%A5%E5%85%B7/PowerShell%E7%BE%8E%E5%8C%96/image-20220419140218149.png" alt="image-20220419140218149"></p><p>之后可在json文件中修改其他高级设置，如背景，透明度等等</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;profiles&quot;</span><span class="punctuation">:</span> </span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;defaults&quot;</span><span class="punctuation">:</span> </span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;backgroundImage&quot;</span><span class="punctuation">:</span> <span class="string">&quot;C:\\Users\\xxx\\Pictures\\壁纸\\xxx.png&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;backgroundImageOpacity&quot;</span><span class="punctuation">:</span> <span class="number">0.22</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;backgroundImageStretchMode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;uniformToFill&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;colorScheme&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Flat UI Palette v1 Modified&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;cursorColor&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#FFFFFF&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;cursorShape&quot;</span><span class="punctuation">:</span> <span class="string">&quot;bar&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;font&quot;</span><span class="punctuation">:</span> </span><br><span class="line">            <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;face&quot;</span><span class="punctuation">:</span> <span class="string">&quot;FiraCode NF&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">12</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;opacity&quot;</span><span class="punctuation">:</span> <span class="number">80</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;startingDirectory&quot;</span><span class="punctuation">:</span> <span class="string">&quot;C:\\Users\\xxx\\Desktop&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;useAcrylic&quot;</span><span class="punctuation">:</span> <span class="keyword">false</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;list&quot;</span><span class="punctuation">:</span></span><br><span class="line">        ...</span><br></pre></td></tr></table></figure><p>提供一个配色方案：<code>Flat UI Palette v1 Modified</code>，放到<code>schemes</code>里面</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">           <span class="attr">&quot;background&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#1C2024&quot;</span><span class="punctuation">,</span></span><br><span class="line">           <span class="attr">&quot;black&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#000000&quot;</span><span class="punctuation">,</span></span><br><span class="line">           <span class="attr">&quot;blue&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#2980B9&quot;</span><span class="punctuation">,</span></span><br><span class="line">           <span class="attr">&quot;brightBlack&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#52677C&quot;</span><span class="punctuation">,</span></span><br><span class="line">           <span class="attr">&quot;brightBlue&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#3498DB&quot;</span><span class="punctuation">,</span></span><br><span class="line">           <span class="attr">&quot;brightCyan&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#1ABC9C&quot;</span><span class="punctuation">,</span></span><br><span class="line">           <span class="attr">&quot;brightGreen&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#2ECC71&quot;</span><span class="punctuation">,</span></span><br><span class="line">           <span class="attr">&quot;brightPurple&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#9B59B6&quot;</span><span class="punctuation">,</span></span><br><span class="line">           <span class="attr">&quot;brightRed&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#E67E22&quot;</span><span class="punctuation">,</span></span><br><span class="line">           <span class="attr">&quot;brightWhite&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#ECF0F1&quot;</span><span class="punctuation">,</span></span><br><span class="line">           <span class="attr">&quot;brightYellow&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#F1C40F&quot;</span><span class="punctuation">,</span></span><br><span class="line">           <span class="attr">&quot;cursorColor&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#FFFFFF&quot;</span><span class="punctuation">,</span></span><br><span class="line">           <span class="attr">&quot;cyan&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#16A085&quot;</span><span class="punctuation">,</span></span><br><span class="line">           <span class="attr">&quot;foreground&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#ECF0F1&quot;</span><span class="punctuation">,</span></span><br><span class="line">           <span class="attr">&quot;green&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#27AE60&quot;</span><span class="punctuation">,</span></span><br><span class="line">           <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Flat UI Palette v1 Modified&quot;</span><span class="punctuation">,</span></span><br><span class="line">           <span class="attr">&quot;purple&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#8E44AD&quot;</span><span class="punctuation">,</span></span><br><span class="line">           <span class="attr">&quot;red&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#E74C3C&quot;</span><span class="punctuation">,</span></span><br><span class="line">           <span class="attr">&quot;selectionBackground&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#FFFFFF&quot;</span><span class="punctuation">,</span></span><br><span class="line">           <span class="attr">&quot;white&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#FFFFFF&quot;</span><span class="punctuation">,</span></span><br><span class="line">           <span class="attr">&quot;yellow&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#F1C40F&quot;</span></span><br><span class="line">       <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure><h3 id="6-ps配置启动参数"><a href="#6-ps配置启动参数" class="headerlink" title="6 ps配置启动参数"></a>6 ps配置启动参数</h3><p>在用户文档中新建一个 <code>ps1</code>文件，位置：</p><p><code>C:\Users\xxx\Documents\PowerShell\Microsoft.PowerShell_profile.ps1</code></p><p>这里面主要修改的主题和用户的一些小功能，如开启代理</p><p>通过<code>Get-PoshThemes</code>或者<code>Get-Theme</code>查看可选主题以及样式</p><p><img src="/2020/11/20/%E5%B7%A5%E5%85%B7/PowerShell%E7%BE%8E%E5%8C%96/image-20220419141113769.png" alt="image-20220419141113769"></p><h4 id="详细配置"><a href="#详细配置" class="headerlink" title="详细配置"></a>详细配置</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#------------------------------- Import Modules BEGIN -------------------------------</span></span><br><span class="line"><span class="comment"># 引入 posh-git</span></span><br><span class="line"><span class="built_in">Import-Module</span> posh<span class="literal">-git</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 引入 oh-my-posh</span></span><br><span class="line"><span class="built_in">Import-Module</span> <span class="built_in">oh</span><span class="literal">-my-posh</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 引入 ps-read-line</span></span><br><span class="line"><span class="built_in">Import-Module</span> PSReadLine</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置 PowerShell 主题</span></span><br><span class="line"><span class="comment"># Set-PoshPrompt ys</span></span><br><span class="line"><span class="built_in">Set-PoshPrompt</span> velvet</span><br><span class="line"></span><br><span class="line"><span class="built_in">Import-Module</span> PSColor</span><br><span class="line"><span class="comment">#------------------------------- Import Modules END   -------------------------------</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#-------------------------------  Set Hot-keys BEGIN  -------------------------------</span></span><br><span class="line"><span class="comment"># 设置预测文本来源为历史记录</span></span><br><span class="line"><span class="built_in">Set-PSReadLineOption</span> <span class="literal">-PredictionSource</span> <span class="built_in">History</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 每次回溯输入历史，光标定位于输入内容末尾</span></span><br><span class="line"><span class="built_in">Set-PSReadLineOption</span> <span class="literal">-HistorySearchCursorMovesToEnd</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置 Tab 为菜单补全和 Intellisense</span></span><br><span class="line"><span class="built_in">Set-PSReadLineKeyHandler</span> <span class="literal">-Key</span> <span class="string">&quot;Tab&quot;</span> <span class="literal">-Function</span> MenuComplete</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置 Ctrl+d 为退出 PowerShell</span></span><br><span class="line"><span class="built_in">Set-PSReadlineKeyHandler</span> <span class="literal">-Key</span> <span class="string">&quot;Ctrl+d&quot;</span> <span class="literal">-Function</span> ViExit</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置 Ctrl+z 为撤销</span></span><br><span class="line"><span class="built_in">Set-PSReadLineKeyHandler</span> <span class="literal">-Key</span> <span class="string">&quot;Ctrl+z&quot;</span> <span class="literal">-Function</span> Undo</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置向上键为后向搜索历史记录</span></span><br><span class="line"><span class="built_in">Set-PSReadLineKeyHandler</span> <span class="literal">-Key</span> UpArrow <span class="literal">-Function</span> HistorySearchBackward</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置向下键为前向搜索历史纪录</span></span><br><span class="line"><span class="built_in">Set-PSReadLineKeyHandler</span> <span class="literal">-Key</span> DownArrow <span class="literal">-Function</span> HistorySearchForward</span><br><span class="line"><span class="comment">#-------------------------------  Set Hot-keys END    -------------------------------</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#region conda initialize</span></span><br><span class="line"><span class="comment"># !! Contents within this block are managed by &#x27;conda init&#x27; !!</span></span><br><span class="line">(&amp; <span class="string">&quot;D:\Anaconda3\Scripts\conda.exe&quot;</span> <span class="string">&quot;shell.powershell&quot;</span> <span class="string">&quot;hook&quot;</span>) | <span class="built_in">Out-String</span> | <span class="built_in">Invoke-Expression</span></span><br><span class="line"><span class="comment">#endregion</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">set_proxy_variable</span></span> &#123;</span><br><span class="line"><span class="variable">$env:http_proxy</span> = <span class="string">&quot;127.0.0.1:1080&quot;</span></span><br><span class="line"><span class="variable">$env:https_proxy</span> = <span class="string">&quot;127.0.0.1:1080&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unset_proxy_variable</span></span> &#123;</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;close proxy&quot;</span></span><br><span class="line"><span class="variable">$env:http_proxy</span> = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="variable">$env:https_proxy</span> = <span class="string">&quot;&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">print_proxy_variable</span></span> &#123;</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$env:http_proxy</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$env:https_proxy</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">New-Alias</span> <span class="literal">-Name</span> spp <span class="literal">-Value</span> set_proxy_variable</span><br><span class="line"><span class="built_in">New-Alias</span> <span class="literal">-Name</span> upp <span class="literal">-Value</span> unset_proxy_variable</span><br><span class="line"><span class="built_in">New-Alias</span> <span class="literal">-Name</span> ppp <span class="literal">-Value</span> print_proxy_variable </span><br><span class="line"></span><br><span class="line"><span class="built_in">New-Alias</span> <span class="literal">-Name</span> ll <span class="literal">-Value</span> <span class="built_in">ls</span> </span><br></pre></td></tr></table></figure><p>有时候第一部分需要改成下面：oh-my-posh不支持</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#------------------------------- Import Modules BEGIN -----------------------------</span></span><br><span class="line"><span class="comment"># 引入 posh-git</span></span><br><span class="line"><span class="built_in">Import-Module</span> posh<span class="literal">-git</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 引入 oh-my-posh</span></span><br><span class="line"><span class="comment"># Import-Module oh-my-posh</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 引入 ps-read-line</span></span><br><span class="line"><span class="built_in">Import-Module</span> PSReadLine</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置 PowerShell 主题</span></span><br><span class="line"><span class="comment"># Set-PoshPrompt ys</span></span><br><span class="line"><span class="comment"># Set-PoshPrompt velvet</span></span><br><span class="line"><span class="built_in">oh</span><span class="literal">-my-posh</span> init pwsh <span class="literal">--config</span> C:\\Users\\<span class="number">299</span>\\AppData\\Local\\Programs\\oh<span class="literal">-my-posh</span>\\themes\\velvet.omp.json | <span class="built_in">Invoke-Expression</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Import-Module</span> PSColor</span><br><span class="line"><span class="comment">#------------------------------- Import Modules END   -----------------------------</span></span><br></pre></td></tr></table></figure><h3 id="7-右键菜单启动"><a href="#7-右键菜单启动" class="headerlink" title="7 右键菜单启动"></a>7 右键菜单启动</h3><blockquote><p>有时不用这一步，因为 windows terminal可能自带了</p></blockquote><p>安装</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Requires -RunAsAdministrator</span></span><br><span class="line"><span class="comment">#Requires -Version 6</span></span><br><span class="line"></span><br><span class="line"><span class="function">[<span class="type">CmdletBinding</span>()]</span></span><br><span class="line"><span class="keyword">param</span>(</span><br><span class="line">[<span class="type">Parameter</span>(<span class="type">Position</span> = <span class="number">0</span>)]</span><br><span class="line">[<span class="type">ValidateSet</span>(<span class="string">&#x27;Default&#x27;</span>, <span class="string">&#x27;Flat&#x27;</span>, <span class="string">&#x27;Mini&#x27;</span>)]</span><br><span class="line">[<span class="built_in">string</span>] <span class="variable">$Layout</span> = <span class="string">&#x27;Mini&#x27;</span>,</span><br><span class="line">[<span class="type">Parameter</span>()]</span><br><span class="line">[<span class="type">switch</span>] <span class="variable">$PreRelease</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成帮助脚本</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Generate-HelperScript</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function"># The cache folder</span></span></span><br><span class="line"><span class="params"><span class="function">[Parameter(Mandatory=<span class="variable">$true</span>)</span>]</span></span><br><span class="line">[<span class="built_in">string</span>]<span class="variable">$cache</span>) &#123;</span><br><span class="line"><span class="variable">$content</span> = </span><br><span class="line"><span class="string">&quot;Set shell = WScript.CreateObject(`&quot;Shell.Application`&quot;)</span></span><br><span class="line"><span class="string"> executable = WSCript.Arguments(0)</span></span><br><span class="line"><span class="string"> folder = WScript.Arguments(1)</span></span><br><span class="line"><span class="string"> If Wscript.Arguments.Count &gt; 2 Then</span></span><br><span class="line"><span class="string"> profile = WScript.Arguments(2)</span></span><br><span class="line"><span class="string"> &#x27; 0 at the end means to run this command silently</span></span><br><span class="line"><span class="string"> shell.ShellExecute `&quot;powershell`&quot;, `&quot;Start-Process \`&quot;`&quot;`&quot; &amp; executable &amp; `&quot;\`&quot;`&quot; -ArgumentList \`&quot;`&quot;-p \`&quot;`&quot;\`&quot;`&quot;`&quot; &amp; profile &amp; `&quot;\`&quot;`&quot;\`&quot;`&quot; -d \`&quot;`&quot;\`&quot;`&quot;`&quot; &amp; folder &amp; `&quot;\`&quot;`&quot;\`&quot;`&quot; \`&quot;`&quot; `&quot;, `&quot;`&quot;, `&quot;runas`&quot;, 0</span></span><br><span class="line"><span class="string"> Else</span></span><br><span class="line"><span class="string"> &#x27; 0 at the end means to run this command silently</span></span><br><span class="line"><span class="string"> shell.ShellExecute `&quot;powershell`&quot;, `&quot;Start-Process \`&quot;`&quot;`&quot; &amp; executable &amp; `&quot;\`&quot;`&quot; -ArgumentList \`&quot;`&quot;-d \`&quot;`&quot;\`&quot;`&quot;`&quot; &amp; folder &amp; `&quot;\`&quot;`&quot;\`&quot;`&quot; \`&quot;`&quot; `&quot;, `&quot;`&quot;, `&quot;runas`&quot;, 0</span></span><br><span class="line"><span class="string"> End If</span></span><br><span class="line"><span class="string">&quot;</span></span><br><span class="line"><span class="built_in">Set-Content</span> <span class="literal">-Path</span> <span class="string">&quot;<span class="variable">$cache</span>/helper.vbs&quot;</span> <span class="literal">-Value</span> <span class="variable">$content</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取 icon</span></span><br><span class="line"><span class="comment"># 源地址：https://github.com/Duffney/PowerShell/blob/master/FileSystems/Get-Icon.ps1</span></span><br><span class="line"><span class="function"><span class="keyword">Function</span> <span class="title">Get-Icon</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="function">[<span class="type">CmdletBinding</span>()]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">Param</span> ( </span><br><span class="line">[<span class="type">Parameter</span>(<span class="type">Mandatory</span>=<span class="variable">$True</span>, <span class="type">Position</span>=<span class="number">1</span>, <span class="type">HelpMessage</span>=<span class="string">&quot;Enter the location of the .EXE file&quot;</span>)]</span><br><span class="line">[<span class="built_in">string</span>]<span class="variable">$File</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment"># If provided, will output the icon to a location</span></span><br><span class="line">[<span class="type">Parameter</span>(<span class="type">Position</span>=<span class="number">1</span>, <span class="type">ValueFromPipelineByPropertyName</span>=<span class="variable">$true</span>)]</span><br><span class="line">[<span class="built_in">string</span>]<span class="variable">$OutputFile</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">[<span class="type">System.Reflection.Assembly</span>]::LoadWithPartialName(<span class="string">&#x27;System.Drawing&#x27;</span>)  | <span class="built_in">Out-Null</span></span><br><span class="line"></span><br><span class="line">[<span class="type">System.Drawing.Icon</span>]::ExtractAssociatedIcon(<span class="variable">$File</span>).ToBitmap().Save(<span class="variable">$OutputFile</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 转换为 icon</span></span><br><span class="line"><span class="comment"># https://gist.github.com/darkfall/1656050</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ConvertTo-Icon</span></span> &#123;</span><br><span class="line"><span class="comment">&lt;#</span></span><br><span class="line"><span class="comment"><span class="doctag">.Synopsis</span></span></span><br><span class="line"><span class="comment">Converts image to icons</span></span><br><span class="line"><span class="comment"><span class="doctag">.Description</span></span></span><br><span class="line"><span class="comment">Converts an image to an icon</span></span><br><span class="line"><span class="comment"><span class="doctag">.Example</span></span></span><br><span class="line"><span class="comment">ConvertTo-Icon -File .\Logo.png -OutputFile .\Favicon.ico</span></span><br><span class="line"><span class="comment">#&gt;</span></span><br><span class="line"><span class="function">[<span class="type">CmdletBinding</span>()]</span></span><br><span class="line"><span class="keyword">param</span>(</span><br><span class="line"><span class="comment"># The file</span></span><br><span class="line">[<span class="type">Parameter</span>(<span class="type">Mandatory</span>=<span class="variable">$true</span>, <span class="type">Position</span>=<span class="number">0</span>, <span class="type">ValueFromPipelineByPropertyName</span>=<span class="variable">$true</span>)]</span><br><span class="line">[<span class="type">Alias</span>(<span class="string">&#x27;Fullname&#x27;</span>)]</span><br><span class="line">[<span class="built_in">string</span>]<span class="variable">$File</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment"># If provided, will output the icon to a location</span></span><br><span class="line">[<span class="type">Parameter</span>(<span class="type">Position</span>=<span class="number">1</span>, <span class="type">ValueFromPipelineByPropertyName</span>=<span class="variable">$true</span>)]</span><br><span class="line">[<span class="built_in">string</span>]<span class="variable">$OutputFile</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">begin</span> &#123;</span><br><span class="line"><span class="built_in">Add-Type</span> <span class="literal">-AssemblyName</span> System.Drawing</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">process</span> &#123;</span><br><span class="line"><span class="comment">#region Load Icon</span></span><br><span class="line"><span class="variable">$resolvedFile</span> = <span class="variable">$ExecutionContext</span>.SessionState.Path.GetResolvedPSPathFromPSPath(<span class="variable">$file</span>)</span><br><span class="line"><span class="keyword">if</span> (<span class="operator">-not</span> <span class="variable">$resolvedFile</span>) &#123; <span class="keyword">return</span> &#125;</span><br><span class="line"><span class="variable">$inputBitmap</span> = [<span class="type">Drawing.Image</span>]::FromFile(<span class="variable">$resolvedFile</span>)</span><br><span class="line"><span class="variable">$width</span> = <span class="variable">$inputBitmap</span>.Width</span><br><span class="line"><span class="variable">$height</span> = <span class="variable">$inputBitmap</span>.Height</span><br><span class="line"><span class="variable">$size</span> = <span class="built_in">New-Object</span> Drawing.Size <span class="variable">$width</span>, <span class="variable">$height</span></span><br><span class="line"><span class="variable">$newBitmap</span> = <span class="built_in">New-Object</span> Drawing.Bitmap <span class="variable">$inputBitmap</span>, <span class="variable">$size</span></span><br><span class="line"><span class="comment">#endregion Load Icon</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#region Save Icon</span></span><br><span class="line"><span class="variable">$memoryStream</span> = <span class="built_in">New-Object</span> System.IO.MemoryStream</span><br><span class="line"><span class="variable">$newBitmap</span>.Save(<span class="variable">$memoryStream</span>, [<span class="type">System.Drawing.Imaging.ImageFormat</span>]::Png)</span><br><span class="line"></span><br><span class="line"><span class="variable">$resolvedOutputFile</span> = <span class="variable">$ExecutionContext</span>.SessionState.Path.GetUnresolvedProviderPathFromPSPath(<span class="variable">$outputFile</span>)</span><br><span class="line"><span class="variable">$output</span> = [<span class="type">IO.File</span>]::Create(<span class="string">&quot;<span class="variable">$resolvedOutputFile</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable">$iconWriter</span> = <span class="built_in">New-Object</span> System.IO.BinaryWriter(<span class="variable">$output</span>)</span><br><span class="line"><span class="comment"># 0-1 reserved, 0</span></span><br><span class="line"><span class="variable">$iconWriter</span>.Write([<span class="built_in">byte</span>]<span class="number">0</span>)</span><br><span class="line"><span class="variable">$iconWriter</span>.Write([<span class="built_in">byte</span>]<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2-3 image type, 1 = icon, 2 = cursor</span></span><br><span class="line"><span class="variable">$iconWriter</span>.Write([<span class="type">short</span>]<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4-5 number of images</span></span><br><span class="line"><span class="variable">$iconWriter</span>.Write([<span class="type">short</span>]<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment"># image entry 1</span></span><br><span class="line"><span class="comment"># 0 image width</span></span><br><span class="line"><span class="variable">$iconWriter</span>.Write([<span class="built_in">byte</span>]<span class="variable">$width</span>);</span><br><span class="line"><span class="comment"># 1 image height</span></span><br><span class="line"><span class="variable">$iconWriter</span>.Write([<span class="built_in">byte</span>]<span class="variable">$height</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2 number of colors</span></span><br><span class="line"><span class="variable">$iconWriter</span>.Write([<span class="built_in">byte</span>]<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3 reserved</span></span><br><span class="line"><span class="variable">$iconWriter</span>.Write([<span class="built_in">byte</span>]<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4-5 color planes</span></span><br><span class="line"><span class="variable">$iconWriter</span>.Write([<span class="type">short</span>]<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment"># 6-7 bits per pixel</span></span><br><span class="line"><span class="variable">$iconWriter</span>.Write([<span class="type">short</span>]<span class="number">32</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment"># 8-11 size of image data</span></span><br><span class="line"><span class="variable">$iconWriter</span>.Write([<span class="built_in">int</span>]<span class="variable">$memoryStream</span>.Length);</span><br><span class="line"></span><br><span class="line"><span class="comment"># 12-15 offset of image data</span></span><br><span class="line"><span class="variable">$iconWriter</span>.Write([<span class="built_in">int</span>](<span class="number">6</span> + <span class="number">16</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment"># write image data</span></span><br><span class="line"><span class="comment"># png data must contain the whole png data file</span></span><br><span class="line"><span class="variable">$iconWriter</span>.Write(<span class="variable">$memoryStream</span>.ToArray());</span><br><span class="line"></span><br><span class="line"><span class="variable">$iconWriter</span>.Flush();</span><br><span class="line"><span class="variable">$output</span>.Close()</span><br><span class="line"><span class="comment">#endregion Save Icon</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#region Cleanup</span></span><br><span class="line"><span class="variable">$memoryStream</span>.Dispose()</span><br><span class="line"><span class="variable">$newBitmap</span>.Dispose()</span><br><span class="line"><span class="variable">$inputBitmap</span>.Dispose()</span><br><span class="line"><span class="comment">#endregion Cleanup</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取 Program Files 文件夹</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">GetProgramFilesFolder</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">[Parameter(Mandatory=<span class="variable">$true</span>)</span>]</span></span><br><span class="line">[<span class="built_in">bool</span>]<span class="variable">$includePreview</span>) &#123;</span><br><span class="line"><span class="variable">$versionFolders</span> = (<span class="built_in">Get-ChildItem</span> <span class="string">&quot;<span class="variable">$Env:ProgramFiles</span>\WindowsApps&quot;</span> | <span class="built_in">Where-Object</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="variable">$includePreview</span>) &#123;</span><br><span class="line"><span class="variable">$_</span>.Name <span class="operator">-like</span> <span class="string">&quot;Microsoft.WindowsTerminal_*__*&quot;</span> <span class="operator">-or</span></span><br><span class="line"><span class="variable">$_</span>.Name <span class="operator">-like</span> <span class="string">&quot;Microsoft.WindowsTerminalPreview_*__*&quot;</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="variable">$_</span>.Name <span class="operator">-like</span> <span class="string">&quot;Microsoft.WindowsTerminal_*__*&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable">$foundVersion</span> = <span class="variable">$null</span></span><br><span class="line"><span class="variable">$result</span> = <span class="variable">$null</span></span><br><span class="line"><span class="keyword">foreach</span> (<span class="variable">$versionFolder</span> <span class="keyword">in</span> <span class="variable">$versionFolders</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="variable">$versionFolder</span>.Name <span class="operator">-match</span> <span class="string">&quot;[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+&quot;</span>) &#123;</span><br><span class="line"><span class="variable">$version</span> = [<span class="type">version</span>]<span class="variable">$Matches</span>.<span class="number">0</span></span><br><span class="line"><span class="built_in">Write-Host</span> <span class="string">&quot;Found Windows Terminal version <span class="variable">$version</span>.&quot;</span></span><br><span class="line"><span class="keyword">if</span> (<span class="variable">$null</span> <span class="operator">-eq</span> <span class="variable">$foundVersion</span> <span class="operator">-or</span> <span class="variable">$version</span> <span class="operator">-gt</span> <span class="variable">$foundVersion</span>) &#123;</span><br><span class="line"><span class="variable">$foundVersion</span> = <span class="variable">$version</span></span><br><span class="line"><span class="variable">$result</span> = <span class="variable">$versionFolder</span>.FullName</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">Write-Warning</span> <span class="string">&quot;Found Windows Terminal unsupported version in <span class="variable">$versionFolder</span>.&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="variable">$foundVersion</span> <span class="operator">-lt</span> [<span class="type">version</span>]<span class="string">&quot;0.11&quot;</span>) &#123;</span><br><span class="line"><span class="built_in">Write-Warning</span> <span class="string">&quot;The latest version found is less than 0.11, which is not tested. The install script might fail in certain way.&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="variable">$null</span> <span class="operator">-eq</span> <span class="variable">$result</span>) &#123;</span><br><span class="line"><span class="built_in">Write-Error</span> <span class="string">&quot;Failed to find Windows Terminal actual folder. The install script might fail in certain way.&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="variable">$result</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取 Windows Terminal 的 icon</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">GetWindowsTerminalIcon</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">[Parameter(Mandatory=<span class="variable">$true</span>)</span>]</span></span><br><span class="line">[<span class="built_in">string</span>]<span class="variable">$folder</span>,</span><br><span class="line">[<span class="type">Parameter</span>(<span class="type">Mandatory</span>=<span class="variable">$true</span>)]</span><br><span class="line">[<span class="built_in">string</span>]<span class="variable">$localCache</span>) &#123;</span><br><span class="line"><span class="variable">$icon</span> = <span class="string">&quot;<span class="variable">$localCache</span>\wt.ico&quot;</span></span><br><span class="line"><span class="variable">$actual</span> = <span class="variable">$folder</span> + <span class="string">&quot;\WindowsTerminal.exe&quot;</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">Test-Path</span> <span class="variable">$actual</span>) &#123;</span><br><span class="line"><span class="comment"># use app icon directly.</span></span><br><span class="line"><span class="built_in">Write-Host</span> <span class="string">&quot;Found actual executable <span class="variable">$actual</span>.&quot;</span></span><br><span class="line"><span class="variable">$temp</span> = <span class="string">&quot;<span class="variable">$localCache</span>\wt.png&quot;</span></span><br><span class="line"><span class="built_in">Get-Icon</span> <span class="operator">-File</span> <span class="variable">$actual</span> <span class="literal">-OutputFile</span> <span class="variable">$temp</span></span><br><span class="line"><span class="built_in">ConvertTo-Icon</span> <span class="operator">-File</span> <span class="variable">$temp</span> <span class="literal">-OutputFile</span> <span class="variable">$icon</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment"># download from GitHub</span></span><br><span class="line"><span class="built_in">Write-Warning</span> <span class="string">&quot;Didn&#x27;t find actual executable <span class="variable">$actual</span> so download icon from GitHub.&quot;</span></span><br><span class="line"><span class="built_in">Invoke-WebRequest</span> <span class="literal">-UseBasicParsing</span> <span class="string">&quot;https://raw.githubusercontent.com/microsoft/terminal/master/res/terminal.ico&quot;</span> <span class="literal">-OutFile</span> <span class="variable">$icon</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="variable">$icon</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取 Windows Terminal 的配置文件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">GetActiveProfiles</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">[Parameter(Mandatory=<span class="variable">$true</span>)</span>]</span></span><br><span class="line">[<span class="built_in">bool</span>]<span class="variable">$isPreview</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="variable">$isPreview</span>) &#123;</span><br><span class="line"><span class="variable">$file</span> = <span class="string">&quot;<span class="variable">$env:LocalAppData</span>\Packages\Microsoft.WindowsTerminalPreview_8wekyb3d8bbwe\LocalState\settings.json&quot;</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="variable">$file</span> = <span class="string">&quot;<span class="variable">$env:LocalAppData</span>\Packages\Microsoft.WindowsTerminal_8wekyb3d8bbwe\LocalState\settings.json&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="operator">-not</span> (<span class="built_in">Test-Path</span> <span class="variable">$file</span>)) &#123;</span><br><span class="line"><span class="built_in">Write-Error</span> <span class="string">&quot;Couldn&#x27;t find profiles. Please run Windows Terminal at least once after installing it. Exit.&quot;</span></span><br><span class="line"><span class="keyword">exit</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$settings</span> = <span class="built_in">Get-Content</span> <span class="variable">$file</span> | <span class="built_in">Out-String</span> | <span class="built_in">ConvertFrom-Json</span></span><br><span class="line"><span class="keyword">if</span> (<span class="variable">$settings</span>.profiles.PSObject.Properties.name <span class="operator">-match</span> <span class="string">&quot;list&quot;</span>) &#123;</span><br><span class="line"><span class="variable">$list</span> = <span class="variable">$settings</span>.profiles.list</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="variable">$list</span> = <span class="variable">$settings</span>.profiles </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="variable">$list</span> | <span class="built_in">Where-Object</span> &#123; <span class="operator">-not</span> <span class="variable">$_</span>.hidden&#125; | <span class="built_in">Where-Object</span> &#123; (<span class="variable">$null</span> <span class="operator">-eq</span> <span class="variable">$_</span>.source) <span class="operator">-or</span> <span class="operator">-not</span> (<span class="variable">$settings</span>.disabledProfileSources <span class="operator">-contains</span> <span class="variable">$_</span>.source) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">GetProfileIcon</span> <span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">[Parameter(Mandatory=<span class="variable">$true</span>)</span>]</span></span><br><span class="line"><span class="variable">$profile</span>,</span><br><span class="line">[<span class="type">Parameter</span>(<span class="type">Mandatory</span>=<span class="variable">$true</span>)]</span><br><span class="line">[<span class="built_in">string</span>]<span class="variable">$folder</span>,</span><br><span class="line">[<span class="type">Parameter</span>(<span class="type">Mandatory</span>=<span class="variable">$true</span>)]</span><br><span class="line">[<span class="built_in">string</span>]<span class="variable">$localCache</span>,</span><br><span class="line">[<span class="type">Parameter</span>(<span class="type">Mandatory</span>=<span class="variable">$true</span>)]</span><br><span class="line">[<span class="built_in">string</span>]<span class="variable">$defaultIcon</span>,</span><br><span class="line">[<span class="type">Parameter</span>(<span class="type">Mandatory</span>=<span class="variable">$true</span>)]</span><br><span class="line">[<span class="built_in">bool</span>]<span class="variable">$isPreview</span>) &#123;</span><br><span class="line"><span class="variable">$guid</span> = <span class="variable">$profile</span>.guid</span><br><span class="line"><span class="variable">$name</span> = <span class="variable">$profile</span>.name</span><br><span class="line"><span class="variable">$result</span> = <span class="variable">$null</span></span><br><span class="line"><span class="variable">$profilePng</span> = <span class="variable">$null</span></span><br><span class="line"><span class="variable">$icon</span> = <span class="variable">$profile</span>.icon</span><br><span class="line"><span class="keyword">if</span> (<span class="variable">$null</span> <span class="operator">-ne</span> <span class="variable">$icon</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">Test-Path</span> <span class="variable">$icon</span>) &#123;</span><br><span class="line"><span class="comment"># use user setting</span></span><br><span class="line"><span class="variable">$profilePng</span> = <span class="variable">$icon</span>  </span><br><span class="line">&#125; <span class="keyword">elseif</span> (<span class="variable">$profile</span>.icon <span class="operator">-like</span> <span class="string">&quot;ms-appdata:///Roaming/*&quot;</span>) &#123;</span><br><span class="line"><span class="comment">#resolve roaming cache</span></span><br><span class="line"><span class="keyword">if</span> (<span class="variable">$isPreview</span>) &#123;</span><br><span class="line"><span class="variable">$profilePng</span> = <span class="variable">$icon</span> <span class="operator">-replace</span> <span class="string">&quot;ms-appdata:///Roaming&quot;</span>, <span class="string">&quot;<span class="variable">$Env:LOCALAPPDATA</span>\Packages\Microsoft.WindowsTerminalPreview_8wekyb3d8bbwe\RoamingState&quot;</span> <span class="operator">-replace</span> <span class="string">&quot;/&quot;</span>, <span class="string">&quot;\&quot;</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="variable">$profilePng</span> = <span class="variable">$icon</span> <span class="operator">-replace</span> <span class="string">&quot;ms-appdata:///Roaming&quot;</span>, <span class="string">&quot;<span class="variable">$Env:LOCALAPPDATA</span>\Packages\Microsoft.WindowsTerminal_8wekyb3d8bbwe\RoamingState&quot;</span> <span class="operator">-replace</span> <span class="string">&quot;/&quot;</span>, <span class="string">&quot;\&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">elseif</span> (<span class="variable">$profile</span>.icon <span class="operator">-like</span> <span class="string">&quot;ms-appdata:///Local/*&quot;</span>) &#123;</span><br><span class="line"><span class="comment">#resolve local cache</span></span><br><span class="line"><span class="keyword">if</span> (<span class="variable">$isPreview</span>) &#123;</span><br><span class="line"><span class="variable">$profilePng</span> = <span class="variable">$icon</span> <span class="operator">-replace</span> <span class="string">&quot;ms-appdata:///Local&quot;</span>, <span class="string">&quot;<span class="variable">$Env:LOCALAPPDATA</span>\Packages\Microsoft.WindowsTerminalPreview_8wekyb3d8bbwe\LocalState&quot;</span> <span class="operator">-replace</span> <span class="string">&quot;/&quot;</span>, <span class="string">&quot;\&quot;</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="variable">$profilePng</span> = <span class="variable">$icon</span> <span class="operator">-replace</span> <span class="string">&quot;ms-appdata:///Local&quot;</span>, <span class="string">&quot;<span class="variable">$Env:LOCALAPPDATA</span>\Packages\Microsoft.WindowsTerminal_8wekyb3d8bbwe\LocalState&quot;</span> <span class="operator">-replace</span> <span class="string">&quot;/&quot;</span>, <span class="string">&quot;\&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">elseif</span> (<span class="variable">$profile</span>.icon <span class="operator">-like</span> <span class="string">&quot;ms-appx:///*&quot;</span>) &#123;</span><br><span class="line"><span class="comment"># resolve app cache</span></span><br><span class="line"><span class="variable">$profilePng</span> = <span class="variable">$icon</span> <span class="operator">-replace</span> <span class="string">&quot;ms-appx://&quot;</span>, <span class="variable">$folder</span> <span class="operator">-replace</span> <span class="string">&quot;/&quot;</span>, <span class="string">&quot;\&quot;</span></span><br><span class="line">&#125; <span class="keyword">elseif</span> (<span class="variable">$profile</span>.icon <span class="operator">-like</span> <span class="string">&quot;*%*&quot;</span>) &#123;</span><br><span class="line"><span class="variable">$profilePng</span> = [<span class="type">System.Environment</span>]::ExpandEnvironmentVariables(<span class="variable">$icon</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">Write-Host</span> <span class="string">&quot;Invalid profile icon found <span class="variable">$icon</span>. Please report an issue at https://github.com/lextm/windowsterminal-shell/issues .&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((<span class="variable">$null</span> <span class="operator">-eq</span> <span class="variable">$profilePng</span>) <span class="operator">-or</span> <span class="operator">-not</span> (<span class="built_in">Test-Path</span> <span class="variable">$profilePng</span>)) &#123;</span><br><span class="line"><span class="comment"># fallback to profile PNG</span></span><br><span class="line"><span class="variable">$profilePng</span> = <span class="string">&quot;<span class="variable">$folder</span>\ProfileIcons\<span class="variable">$guid</span>.scale-200.png&quot;</span></span><br><span class="line"><span class="keyword">if</span> (<span class="operator">-not</span> (<span class="built_in">Test-Path</span>(<span class="variable">$profilePng</span>))) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="variable">$profile</span>.source <span class="operator">-eq</span> <span class="string">&quot;Windows.Terminal.Wsl&quot;</span>) &#123;</span><br><span class="line"><span class="variable">$profilePng</span> = <span class="string">&quot;<span class="variable">$folder</span>\ProfileIcons\&#123;9acb9455-ca41-5af7-950f-6bca1bc9722f&#125;.scale-200.png&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">Test-Path</span> <span class="variable">$profilePng</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="variable">$profilePng</span> <span class="operator">-like</span> <span class="string">&quot;*.png&quot;</span>) &#123;</span><br><span class="line"><span class="comment"># found PNG, convert to ICO</span></span><br><span class="line"><span class="variable">$result</span> = <span class="string">&quot;<span class="variable">$localCache</span>\<span class="variable">$guid</span>.ico&quot;</span></span><br><span class="line"><span class="built_in">ConvertTo-Icon</span> <span class="operator">-File</span> <span class="variable">$profilePng</span> <span class="literal">-OutputFile</span> <span class="variable">$result</span></span><br><span class="line">&#125; <span class="keyword">elseif</span> (<span class="variable">$profilePng</span> <span class="operator">-like</span> <span class="string">&quot;*.ico&quot;</span>) &#123;</span><br><span class="line"><span class="variable">$result</span> = <span class="variable">$profilePng</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">Write-Warning</span> <span class="string">&quot;Icon format is not supported by this script <span class="variable">$profilePng</span>. Please use PNG or ICO format.&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">Write-Warning</span> <span class="string">&quot;Didn&#x27;t find icon for profile <span class="variable">$name</span>.&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="variable">$null</span> <span class="operator">-eq</span> <span class="variable">$result</span>) &#123;</span><br><span class="line"><span class="comment"># final fallback</span></span><br><span class="line"><span class="variable">$result</span> = <span class="variable">$defaultIcon</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="variable">$result</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CreateMenuItem</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">[Parameter(Mandatory=<span class="variable">$true</span>)</span>]</span></span><br><span class="line">[<span class="built_in">string</span>]<span class="variable">$rootKey</span>,</span><br><span class="line">[<span class="type">Parameter</span>(<span class="type">Mandatory</span>=<span class="variable">$true</span>)]</span><br><span class="line">[<span class="built_in">string</span>]<span class="variable">$name</span>,</span><br><span class="line">[<span class="type">Parameter</span>(<span class="type">Mandatory</span>=<span class="variable">$true</span>)]</span><br><span class="line">[<span class="built_in">string</span>]<span class="variable">$icon</span>,</span><br><span class="line">[<span class="type">Parameter</span>(<span class="type">Mandatory</span>=<span class="variable">$true</span>)]</span><br><span class="line">[<span class="built_in">string</span>]<span class="variable">$command</span>,</span><br><span class="line">[<span class="type">Parameter</span>(<span class="type">Mandatory</span>=<span class="variable">$true</span>)]</span><br><span class="line">[<span class="built_in">bool</span>]<span class="variable">$elevated</span>) &#123;</span><br><span class="line"><span class="built_in">New-Item</span> <span class="literal">-Path</span> <span class="variable">$rootKey</span> <span class="literal">-Force</span> | <span class="built_in">Out-Null</span></span><br><span class="line"><span class="built_in">New-ItemProperty</span> <span class="literal">-Path</span> <span class="variable">$rootKey</span> <span class="literal">-Name</span> <span class="string">&#x27;MUIVerb&#x27;</span> <span class="literal">-PropertyType</span> String <span class="literal">-Value</span> <span class="variable">$name</span> | <span class="built_in">Out-Null</span></span><br><span class="line"><span class="built_in">New-ItemProperty</span> <span class="literal">-Path</span> <span class="variable">$rootKey</span> <span class="literal">-Name</span> <span class="string">&#x27;Icon&#x27;</span> <span class="literal">-PropertyType</span> String <span class="literal">-Value</span> <span class="variable">$icon</span> | <span class="built_in">Out-Null</span></span><br><span class="line"><span class="keyword">if</span> (<span class="variable">$elevated</span>) &#123;</span><br><span class="line"><span class="built_in">New-ItemProperty</span> <span class="literal">-Path</span> <span class="variable">$rootKey</span> <span class="literal">-Name</span> <span class="string">&#x27;HasLUAShield&#x27;</span> <span class="literal">-PropertyType</span> String <span class="literal">-Value</span> <span class="string">&#x27;&#x27;</span> | <span class="built_in">Out-Null</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">New-Item</span> <span class="literal">-Path</span> <span class="string">&quot;<span class="variable">$rootKey</span>\command&quot;</span> <span class="literal">-Force</span> | <span class="built_in">Out-Null</span></span><br><span class="line"><span class="built_in">New-ItemProperty</span> <span class="literal">-Path</span> <span class="string">&quot;<span class="variable">$rootKey</span>\command&quot;</span> <span class="literal">-Name</span> <span class="string">&#x27;(Default)&#x27;</span> <span class="literal">-PropertyType</span> String <span class="literal">-Value</span> <span class="variable">$command</span> | <span class="built_in">Out-Null</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CreateProfileMenuItems</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">[Parameter(Mandatory=<span class="variable">$true</span>)</span>]</span></span><br><span class="line"><span class="variable">$profile</span>,</span><br><span class="line">[<span class="type">Parameter</span>(<span class="type">Mandatory</span>=<span class="variable">$true</span>)]</span><br><span class="line">[<span class="built_in">string</span>]<span class="variable">$executable</span>,</span><br><span class="line">[<span class="type">Parameter</span>(<span class="type">Mandatory</span>=<span class="variable">$true</span>)]</span><br><span class="line">[<span class="built_in">string</span>]<span class="variable">$folder</span>,</span><br><span class="line">[<span class="type">Parameter</span>(<span class="type">Mandatory</span>=<span class="variable">$true</span>)]</span><br><span class="line">[<span class="built_in">string</span>]<span class="variable">$localCache</span>,</span><br><span class="line">[<span class="type">Parameter</span>(<span class="type">Mandatory</span>=<span class="variable">$true</span>)]</span><br><span class="line">[<span class="built_in">string</span>]<span class="variable">$icon</span>,</span><br><span class="line">[<span class="type">Parameter</span>(<span class="type">Mandatory</span>=<span class="variable">$true</span>)]</span><br><span class="line">[<span class="built_in">string</span>]<span class="variable">$layout</span>,</span><br><span class="line">[<span class="type">Parameter</span>(<span class="type">Mandatory</span>=<span class="variable">$true</span>)]</span><br><span class="line">[<span class="built_in">bool</span>]<span class="variable">$isPreview</span>) &#123;</span><br><span class="line"><span class="variable">$guid</span> = <span class="variable">$profile</span>.guid</span><br><span class="line"><span class="variable">$name</span> = <span class="variable">$profile</span>.name</span><br><span class="line"><span class="variable">$command</span> = <span class="string">&quot;&quot;</span><span class="string">&quot;<span class="variable">$executable</span>&quot;</span><span class="string">&quot; -p &quot;</span><span class="string">&quot;<span class="variable">$name</span>&quot;</span><span class="string">&quot; -d &quot;</span><span class="string">&quot;%V.&quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line"><span class="variable">$elevated</span> = <span class="string">&quot;wscript.exe &quot;</span><span class="string">&quot;<span class="variable">$localCache</span>/helper.vbs&quot;</span><span class="string">&quot; &quot;</span><span class="string">&quot;<span class="variable">$executable</span>&quot;</span><span class="string">&quot; &quot;</span><span class="string">&quot;%V.&quot;</span><span class="string">&quot; &quot;</span><span class="string">&quot;<span class="variable">$name</span>&quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line"><span class="variable">$profileIcon</span> = GetProfileIcon <span class="variable">$profile</span> <span class="variable">$folder</span> <span class="variable">$localCache</span> <span class="variable">$icon</span> <span class="variable">$isPreview</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="variable">$layout</span> <span class="operator">-eq</span> <span class="string">&quot;Default&quot;</span>) &#123;</span><br><span class="line"><span class="variable">$rootKey</span> = <span class="string">&quot;Registry::HKEY_CURRENT_USER\SOFTWARE\Classes\Directory\ContextMenus\MenuTerminal\shell\<span class="variable">$guid</span>&quot;</span></span><br><span class="line"><span class="variable">$rootKeyElevated</span> = <span class="string">&quot;Registry::HKEY_CURRENT_USER\SOFTWARE\Classes\Directory\ContextMenus\MenuTerminalAdmin\shell\<span class="variable">$guid</span>&quot;</span></span><br><span class="line">CreateMenuItem <span class="variable">$rootKey</span> <span class="variable">$name</span> <span class="variable">$profileIcon</span> <span class="variable">$command</span> <span class="variable">$false</span></span><br><span class="line">CreateMenuItem <span class="variable">$rootKeyElevated</span> <span class="variable">$name</span> <span class="variable">$profileIcon</span> <span class="variable">$elevated</span> <span class="variable">$true</span></span><br><span class="line">&#125; <span class="keyword">elseif</span> (<span class="variable">$layout</span> <span class="operator">-eq</span> <span class="string">&quot;Flat&quot;</span>) &#123;</span><br><span class="line">CreateMenuItem <span class="string">&quot;Registry::HKEY_CURRENT_USER\SOFTWARE\Classes\Directory\shell\MenuTerminalAdmin_<span class="variable">$guid</span>&quot;</span><span class="string">&quot;在终端中以管理员身份打开&quot;</span> <span class="variable">$profileIcon</span> <span class="variable">$elevated</span> <span class="variable">$true</span></span><br><span class="line">CreateMenuItem <span class="string">&quot;Registry::HKEY_CURRENT_USER\SOFTWARE\Classes\Directory\Background\shell\MenuTerminalAdmin_<span class="variable">$guid</span>&quot;</span><span class="string">&quot;在终端中以管理员身份打开&quot;</span> <span class="variable">$profileIcon</span> <span class="variable">$elevated</span> <span class="variable">$true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CreateMenuItems</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">[Parameter(Mandatory=<span class="variable">$true</span>)</span>]</span></span><br><span class="line">[<span class="built_in">string</span>]<span class="variable">$executable</span>,</span><br><span class="line">[<span class="type">Parameter</span>(<span class="type">Mandatory</span>=<span class="variable">$true</span>)]</span><br><span class="line">[<span class="built_in">string</span>]<span class="variable">$layout</span>,</span><br><span class="line">[<span class="type">Parameter</span>(<span class="type">Mandatory</span>=<span class="variable">$true</span>)]</span><br><span class="line">[<span class="built_in">bool</span>]<span class="variable">$includePreview</span>) &#123;</span><br><span class="line"><span class="variable">$folder</span> = GetProgramFilesFolder <span class="variable">$includePreview</span></span><br><span class="line"><span class="variable">$localCache</span> = <span class="string">&quot;<span class="variable">$Env:LOCALAPPDATA</span>\Microsoft\WindowsApps\Cache&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="operator">-not</span> (<span class="built_in">Test-Path</span> <span class="variable">$localCache</span>)) &#123;</span><br><span class="line"><span class="built_in">New-Item</span> <span class="variable">$localCache</span> <span class="literal">-ItemType</span> Directory | <span class="built_in">Out-Null</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Generate<span class="literal">-HelperScript</span> <span class="variable">$localCache</span></span><br><span class="line"><span class="variable">$icon</span> = GetWindowsTerminalIcon <span class="variable">$folder</span> <span class="variable">$localCache</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="variable">$layout</span> <span class="operator">-eq</span> <span class="string">&quot;Default&quot;</span>) &#123;</span><br><span class="line"><span class="comment"># defaut layout creates two menus</span></span><br><span class="line"><span class="built_in">New-Item</span> <span class="literal">-Path</span> <span class="string">&#x27;Registry::HKEY_CURRENT_USER\SOFTWARE\Classes\Directory\shell\MenuTerminal&#x27;</span><span class="literal">-Force</span> | <span class="built_in">Out-Null</span></span><br><span class="line"><span class="built_in">New-ItemProperty</span> <span class="literal">-Path</span> <span class="string">&#x27;Registry::HKEY_CURRENT_USER\SOFTWARE\Classes\Directory\shell\MenuTerminal&#x27;</span><span class="literal">-Name</span> <span class="string">&#x27;MUIVerb&#x27;</span><span class="literal">-PropertyType</span> String <span class="literal">-Value</span> <span class="string">&#x27;Windows Terminal Here&#x27;</span> | <span class="built_in">Out-Null</span></span><br><span class="line"><span class="built_in">New-ItemProperty</span> <span class="literal">-Path</span> <span class="string">&#x27;Registry::HKEY_CURRENT_USER\SOFTWARE\Classes\Directory\shell\MenuTerminal&#x27;</span><span class="literal">-Name</span> <span class="string">&#x27;Icon&#x27;</span><span class="literal">-PropertyType</span> String <span class="literal">-Value</span> <span class="variable">$icon</span> | <span class="built_in">Out-Null</span></span><br><span class="line"><span class="built_in">New-ItemProperty</span> <span class="literal">-Path</span> <span class="string">&#x27;Registry::HKEY_CURRENT_USER\SOFTWARE\Classes\Directory\shell\MenuTerminal&#x27;</span><span class="literal">-Name</span> <span class="string">&#x27;ExtendedSubCommandsKey&#x27;</span><span class="literal">-PropertyType</span> String <span class="literal">-Value</span> <span class="string">&#x27;Directory\\ContextMenus\\MenuTerminal&#x27;</span> | <span class="built_in">Out-Null</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">New-Item</span> <span class="literal">-Path</span> <span class="string">&#x27;Registry::HKEY_CURRENT_USER\SOFTWARE\Classes\Directory\Background\shell\MenuTerminal&#x27;</span><span class="literal">-Force</span> | <span class="built_in">Out-Null</span></span><br><span class="line"><span class="built_in">New-ItemProperty</span> <span class="literal">-Path</span> <span class="string">&#x27;Registry::HKEY_CURRENT_USER\SOFTWARE\Classes\Directory\Background\shell\MenuTerminal&#x27;</span><span class="literal">-Name</span> <span class="string">&#x27;MUIVerb&#x27;</span><span class="literal">-PropertyType</span> String <span class="literal">-Value</span> <span class="string">&#x27;Windows Terminal Here&#x27;</span> | <span class="built_in">Out-Null</span></span><br><span class="line"><span class="built_in">New-ItemProperty</span> <span class="literal">-Path</span> <span class="string">&#x27;Registry::HKEY_CURRENT_USER\SOFTWARE\Classes\Directory\Background\shell\MenuTerminal&#x27;</span><span class="literal">-Name</span> <span class="string">&#x27;Icon&#x27;</span><span class="literal">-PropertyType</span> String <span class="literal">-Value</span> <span class="variable">$icon</span> | <span class="built_in">Out-Null</span></span><br><span class="line"><span class="built_in">New-ItemProperty</span> <span class="literal">-Path</span> <span class="string">&#x27;Registry::HKEY_CURRENT_USER\SOFTWARE\Classes\Directory\Background\shell\MenuTerminal&#x27;</span><span class="literal">-Name</span> <span class="string">&#x27;ExtendedSubCommandsKey&#x27;</span><span class="literal">-PropertyType</span> String <span class="literal">-Value</span> <span class="string">&#x27;Directory\\ContextMenus\\MenuTerminal&#x27;</span> | <span class="built_in">Out-Null</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">New-Item</span> <span class="literal">-Path</span> <span class="string">&#x27;Registry::HKEY_CURRENT_USER\SOFTWARE\Classes\Directory\ContextMenus\MenuTerminal\shell&#x27;</span><span class="literal">-Force</span> | <span class="built_in">Out-Null</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">New-Item</span> <span class="literal">-Path</span> <span class="string">&#x27;Registry::HKEY_CURRENT_USER\SOFTWARE\Classes\Directory\shell\MenuTerminalAdmin&#x27;</span><span class="literal">-Force</span> | <span class="built_in">Out-Null</span></span><br><span class="line"><span class="built_in">New-ItemProperty</span> <span class="literal">-Path</span> <span class="string">&#x27;Registry::HKEY_CURRENT_USER\SOFTWARE\Classes\Directory\shell\MenuTerminalAdmin&#x27;</span><span class="literal">-Name</span> <span class="string">&#x27;MUIVerb&#x27;</span><span class="literal">-PropertyType</span> String <span class="literal">-Value</span> <span class="string">&#x27;在终端中以管理员身份打开&#x27;</span> | <span class="built_in">Out-Null</span></span><br><span class="line"><span class="built_in">New-ItemProperty</span> <span class="literal">-Path</span> <span class="string">&#x27;Registry::HKEY_CURRENT_USER\SOFTWARE\Classes\Directory\shell\MenuTerminalAdmin&#x27;</span><span class="literal">-Name</span> <span class="string">&#x27;Icon&#x27;</span><span class="literal">-PropertyType</span> String <span class="literal">-Value</span> <span class="variable">$icon</span> | <span class="built_in">Out-Null</span></span><br><span class="line"><span class="built_in">New-ItemProperty</span> <span class="literal">-Path</span> <span class="string">&#x27;Registry::HKEY_CURRENT_USER\SOFTWARE\Classes\Directory\shell\MenuTerminalAdmin&#x27;</span><span class="literal">-Name</span> <span class="string">&#x27;ExtendedSubCommandsKey&#x27;</span><span class="literal">-PropertyType</span> String <span class="literal">-Value</span> <span class="string">&#x27;Directory\\ContextMenus\\MenuTerminalAdmin&#x27;</span> | <span class="built_in">Out-Null</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">New-Item</span> <span class="literal">-Path</span> <span class="string">&#x27;Registry::HKEY_CURRENT_USER\SOFTWARE\Classes\Directory\Background\shell\MenuTerminalAdmin&#x27;</span><span class="literal">-Force</span> | <span class="built_in">Out-Null</span></span><br><span class="line"><span class="built_in">New-ItemProperty</span> <span class="literal">-Path</span> <span class="string">&#x27;Registry::HKEY_CURRENT_USER\SOFTWARE\Classes\Directory\Background\shell\MenuTerminalAdmin&#x27;</span><span class="literal">-Name</span> <span class="string">&#x27;MUIVerb&#x27;</span><span class="literal">-PropertyType</span> String <span class="literal">-Value</span> <span class="string">&#x27;在终端中以管理员身份打开&#x27;</span> | <span class="built_in">Out-Null</span></span><br><span class="line"><span class="built_in">New-ItemProperty</span> <span class="literal">-Path</span> <span class="string">&#x27;Registry::HKEY_CURRENT_USER\SOFTWARE\Classes\Directory\Background\shell\MenuTerminalAdmin&#x27;</span><span class="literal">-Name</span> <span class="string">&#x27;Icon&#x27;</span><span class="literal">-PropertyType</span> String <span class="literal">-Value</span> <span class="variable">$icon</span> | <span class="built_in">Out-Null</span></span><br><span class="line"><span class="built_in">New-ItemProperty</span> <span class="literal">-Path</span> <span class="string">&#x27;Registry::HKEY_CURRENT_USER\SOFTWARE\Classes\Directory\Background\shell\MenuTerminalAdmin&#x27;</span><span class="literal">-Name</span> <span class="string">&#x27;ExtendedSubCommandsKey&#x27;</span><span class="literal">-PropertyType</span> String <span class="literal">-Value</span> <span class="string">&#x27;Directory\\ContextMenus\\MenuTerminalAdmin&#x27;</span> | <span class="built_in">Out-Null</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">New-Item</span> <span class="literal">-Path</span> <span class="string">&#x27;Registry::HKEY_CURRENT_USER\SOFTWARE\Classes\Directory\ContextMenus\MenuTerminalAdmin\shell&#x27;</span><span class="literal">-Force</span> | <span class="built_in">Out-Null</span></span><br><span class="line">&#125; <span class="keyword">elseif</span> (<span class="variable">$layout</span> <span class="operator">-eq</span> <span class="string">&quot;Mini&quot;</span>) &#123;</span><br><span class="line"><span class="variable">$elevated</span> = <span class="string">&quot;wscript.exe &quot;</span><span class="string">&quot;<span class="variable">$localCache</span>/helper.vbs&quot;</span><span class="string">&quot; &quot;</span><span class="string">&quot;<span class="variable">$executable</span>&quot;</span><span class="string">&quot; &quot;</span><span class="string">&quot;%V.&quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">CreateMenuItem <span class="string">&quot;Registry::HKEY_CURRENT_USER\SOFTWARE\Classes\Directory\shell\MenuTerminalMini_Admin&quot;</span><span class="string">&quot;在终端中以管理员身份打开&quot;</span><span class="variable">$icon</span> <span class="variable">$elevated</span> <span class="variable">$true</span></span><br><span class="line">CreateMenuItem <span class="string">&quot;Registry::HKEY_CURRENT_USER\SOFTWARE\Classes\Directory\Background\shell\MenuTerminalMini_Admin&quot;</span><span class="string">&quot;在终端中以管理员身份打开&quot;</span><span class="variable">$icon</span> <span class="variable">$elevated</span> <span class="variable">$true</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$isPreview</span> = <span class="variable">$folder</span> <span class="operator">-like</span> <span class="string">&quot;*WindowsTerminalPreview*&quot;</span></span><br><span class="line"><span class="variable">$profiles</span> = GetActiveProfiles <span class="variable">$isPreview</span></span><br><span class="line"><span class="keyword">foreach</span> (<span class="variable">$profile</span> <span class="keyword">in</span> <span class="variable">$profiles</span>) &#123;</span><br><span class="line">CreateProfileMenuItems <span class="variable">$profile</span> <span class="variable">$executable</span> <span class="variable">$folder</span> <span class="variable">$localCache</span> <span class="variable">$icon</span> <span class="variable">$layout</span> <span class="variable">$isPreview</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Based on @nerdio01&#x27;s version in https://github.com/microsoft/terminal/issues/1060</span></span><br><span class="line"><span class="keyword">if</span> ((<span class="built_in">Test-Path</span> <span class="string">&quot;Registry::HKEY_CLASSES_ROOT\Directory\shell\MenuTerminal&quot;</span>) <span class="operator">-and</span></span><br><span class="line"><span class="operator">-not</span> (<span class="built_in">Test-Path</span> <span class="string">&quot;Registry::HKEY_CURRENT_USER\SOFTWARE\Classes\Directory\shell\MenuTerminal&quot;</span>)) &#123;</span><br><span class="line"><span class="built_in">Write-Error</span> <span class="string">&quot;Please execute uninstall.old.ps1 to remove previous installation.&quot;</span></span><br><span class="line"><span class="keyword">exit</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="variable">$PSVersionTable</span>.PSVersion.Major <span class="operator">-lt</span> <span class="number">6</span>) &#123;</span><br><span class="line"><span class="built_in">Write-Error</span> <span class="string">&quot;Must be executed in PowerShell 6 and above. Learn how to install it from https://docs.microsoft.com/en-us/powershell/scripting/install/installing-powershell-core-on-windows?view=powershell-7 . Exit.&quot;</span></span><br><span class="line"><span class="keyword">exit</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$executable</span> = <span class="string">&quot;<span class="variable">$Env:LOCALAPPDATA</span>\Microsoft\WindowsApps\wt.exe&quot;</span></span><br><span class="line"><span class="keyword">if</span> (<span class="operator">-not</span> (<span class="built_in">Test-Path</span> <span class="variable">$executable</span>)) &#123;</span><br><span class="line"><span class="built_in">Write-Error</span> <span class="string">&quot;Windows Terminal not detected. Learn how to install it from https://github.com/microsoft/terminal (via Microsoft Store is recommended). Exit.&quot;</span></span><br><span class="line"><span class="keyword">exit</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 实际执行语句</span></span><br><span class="line"><span class="built_in">Write-Host</span> <span class="string">&quot;布局风格：<span class="variable">$Layout</span>&quot;</span></span><br><span class="line">CreateMenuItems <span class="variable">$executable</span> <span class="variable">$Layout</span> <span class="variable">$PreRelease</span></span><br><span class="line"><span class="built_in">Write-Host</span> <span class="string">&quot;Windows Terminal 启动选项已添加到资源管理器右键菜单&quot;</span></span><br><span class="line"><span class="built_in">Write-Host</span> <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="built_in">Write-Host</span> <span class="string">&quot;P.S. 卸载请使用 .\uninstall.ps1 <span class="variable">$Layout</span>&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>卸载</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Requires -Version 6</span></span><br><span class="line"></span><br><span class="line"><span class="function">[<span class="type">CmdletBinding</span>()]</span></span><br><span class="line"><span class="keyword">param</span>(</span><br><span class="line">[<span class="type">Parameter</span>(<span class="type">Position</span> = <span class="number">0</span>)]</span><br><span class="line">[<span class="type">ValidateSet</span>(<span class="string">&#x27;Default&#x27;</span>, <span class="string">&#x27;Flat&#x27;</span>, <span class="string">&#x27;Mini&#x27;</span>)]</span><br><span class="line">[<span class="built_in">string</span>] <span class="variable">$Layout</span> = <span class="string">&#x27;Mini&#x27;</span>,</span><br><span class="line">[<span class="type">Parameter</span>()]</span><br><span class="line">[<span class="type">switch</span>] <span class="variable">$PreRelease</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Based on @nerdio01&#x27;s version in https://github.com/microsoft/terminal/issues/1060</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((<span class="built_in">Test-Path</span> <span class="string">&quot;Registry::HKEY_CLASSES_ROOT\Directory\shell\MenuTerminal&quot;</span>) <span class="operator">-and</span></span><br><span class="line"><span class="operator">-not</span> (<span class="built_in">Test-Path</span> <span class="string">&quot;Registry::HKEY_CURRENT_USER\SOFTWARE\Classes\Directory\shell\MenuTerminal&quot;</span>)) &#123;</span><br><span class="line"><span class="built_in">Write-Error</span> <span class="string">&quot;Please execute uninstall.old.ps1 to remove previous installation.&quot;</span></span><br><span class="line"><span class="keyword">exit</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$localCache</span> = <span class="string">&quot;<span class="variable">$Env:LOCALAPPDATA</span>\Microsoft\WindowsApps\Cache&quot;</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">Test-Path</span> <span class="variable">$localCache</span>) &#123;</span><br><span class="line"><span class="built_in">Remove-Item</span> <span class="variable">$localCache</span> <span class="literal">-Recurse</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Write-Host</span> <span class="string">&quot;布局风格：<span class="variable">$Layout</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="variable">$layout</span> <span class="operator">-eq</span> <span class="string">&quot;Default&quot;</span>) &#123;</span><br><span class="line"><span class="built_in">Remove-Item</span> <span class="literal">-Path</span> <span class="string">&#x27;Registry::HKEY_CURRENT_USER\SOFTWARE\Classes\Directory\shell\MenuTerminal&#x27;</span><span class="literal">-Recurse</span> <span class="literal">-ErrorAction</span> Ignore | <span class="built_in">Out-Null</span></span><br><span class="line"><span class="built_in">Remove-Item</span> <span class="literal">-Path</span> <span class="string">&#x27;Registry::HKEY_CURRENT_USER\SOFTWARE\Classes\Directory\Background\shell\MenuTerminal&#x27;</span><span class="literal">-Recurse</span> <span class="literal">-ErrorAction</span> Ignore | <span class="built_in">Out-Null</span></span><br><span class="line"><span class="built_in">Remove-Item</span> <span class="literal">-Path</span> <span class="string">&#x27;Registry::HKEY_CURRENT_USER\SOFTWARE\Classes\Directory\ContextMenus\MenuTerminal\shell&#x27;</span><span class="literal">-Recurse</span> <span class="literal">-ErrorAction</span> Ignore | <span class="built_in">Out-Null</span></span><br><span class="line"><span class="built_in">Remove-Item</span> <span class="literal">-Path</span> <span class="string">&#x27;Registry::HKEY_CURRENT_USER\SOFTWARE\Classes\Directory\shell\MenuTerminalAdmin&#x27;</span><span class="literal">-Recurse</span> <span class="literal">-ErrorAction</span> Ignore | <span class="built_in">Out-Null</span></span><br><span class="line"><span class="built_in">Remove-Item</span> <span class="literal">-Path</span> <span class="string">&#x27;Registry::HKEY_CURRENT_USER\SOFTWARE\Classes\Directory\Background\shell\MenuTerminalAdmin&#x27;</span><span class="literal">-Recurse</span> <span class="literal">-ErrorAction</span> Ignore | <span class="built_in">Out-Null</span></span><br><span class="line"><span class="built_in">Remove-Item</span> <span class="literal">-Path</span> <span class="string">&#x27;Registry::HKEY_CURRENT_USER\SOFTWARE\Classes\Directory\ContextMenus\MenuTerminalAdmin\shell&#x27;</span><span class="literal">-Recurse</span> <span class="literal">-ErrorAction</span> Ignore | <span class="built_in">Out-Null</span></span><br><span class="line">&#125; <span class="keyword">elseif</span> (<span class="variable">$layout</span> <span class="operator">-eq</span> <span class="string">&quot;Flat&quot;</span>) &#123;</span><br><span class="line"><span class="variable">$rootKey</span> = <span class="string">&#x27;HKEY_CURRENT_USER\SOFTWARE\Classes\Directory\shell&#x27;</span></span><br><span class="line"><span class="keyword">foreach</span> (<span class="variable">$key</span> <span class="keyword">in</span> <span class="built_in">Get-ChildItem</span> <span class="literal">-Path</span> <span class="string">&quot;Registry::<span class="variable">$rootKey</span>&quot;</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> ((<span class="variable">$key</span>.Name <span class="operator">-like</span> <span class="string">&quot;<span class="variable">$rootKey</span>\MenuTerminal_*&quot;</span>) <span class="operator">-or</span> (<span class="variable">$key</span>.Name <span class="operator">-like</span> <span class="string">&quot;<span class="variable">$rootKey</span>\MenuTerminalAdmin_*&quot;</span>)) &#123;</span><br><span class="line"><span class="built_in">Remove-Item</span> <span class="string">&quot;Registry::<span class="variable">$key</span>&quot;</span> <span class="literal">-Recurse</span> <span class="literal">-ErrorAction</span> Ignore | <span class="built_in">Out-Null</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$rootKey</span> = <span class="string">&#x27;HKEY_CURRENT_USER\SOFTWARE\Classes\Directory\Background\shell&#x27;</span></span><br><span class="line"><span class="keyword">foreach</span> (<span class="variable">$key</span> <span class="keyword">in</span> <span class="built_in">Get-ChildItem</span> <span class="literal">-Path</span> <span class="string">&quot;Registry::<span class="variable">$rootKey</span>&quot;</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> ((<span class="variable">$key</span>.Name <span class="operator">-like</span> <span class="string">&quot;<span class="variable">$rootKey</span>\MenuTerminal_*&quot;</span>) <span class="operator">-or</span> (<span class="variable">$key</span>.Name <span class="operator">-like</span> <span class="string">&quot;<span class="variable">$rootKey</span>\MenuTerminalAdmin_*&quot;</span>)) &#123;</span><br><span class="line"><span class="built_in">Remove-Item</span> <span class="string">&quot;Registry::<span class="variable">$key</span>&quot;</span> <span class="literal">-Recurse</span> <span class="literal">-ErrorAction</span> Ignore | <span class="built_in">Out-Null</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">elseif</span> (<span class="variable">$layout</span> <span class="operator">-eq</span> <span class="string">&quot;Mini&quot;</span>) &#123;</span><br><span class="line"><span class="built_in">Remove-Item</span> <span class="literal">-Path</span> <span class="string">&#x27;Registry::HKEY_CURRENT_USER\SOFTWARE\Classes\Directory\shell\MenuTerminalMini&#x27;</span><span class="literal">-Recurse</span> <span class="literal">-ErrorAction</span> Ignore | <span class="built_in">Out-Null</span></span><br><span class="line"><span class="built_in">Remove-Item</span> <span class="literal">-Path</span> <span class="string">&#x27;Registry::HKEY_CURRENT_USER\SOFTWARE\Classes\Directory\shell\MenuTerminalMini_Admin&#x27;</span><span class="literal">-Recurse</span> <span class="literal">-ErrorAction</span> Ignore | <span class="built_in">Out-Null</span></span><br><span class="line"><span class="built_in">Remove-Item</span> <span class="literal">-Path</span> <span class="string">&#x27;Registry::HKEY_CURRENT_USER\SOFTWARE\Classes\Directory\Background\shell\MenuTerminalMini&#x27;</span><span class="literal">-Recurse</span> <span class="literal">-ErrorAction</span> Ignore | <span class="built_in">Out-Null</span></span><br><span class="line"><span class="built_in">Remove-Item</span> <span class="literal">-Path</span> <span class="string">&#x27;Registry::HKEY_CURRENT_USER\SOFTWARE\Classes\Directory\Background\shell\MenuTerminalMini_Admin&#x27;</span><span class="literal">-Recurse</span> <span class="literal">-ErrorAction</span> Ignore | <span class="built_in">Out-Null</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Write-Host</span> <span class="string">&quot;Windows Terminal 启动项已经从资源管理器右键菜单移除。&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PowerShell </tag>
            
            <tag> Window </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu18.04 换源、美化及配置过程</title>
      <link href="/2020/10/10/%E5%B7%A5%E5%85%B7/Ubuntu%2018.04%20%E7%BE%8E%E5%8C%96%E5%8F%8A%E9%85%8D%E7%BD%AE%E8%BF%87%E7%A8%8B/"/>
      <url>/2020/10/10/%E5%B7%A5%E5%85%B7/Ubuntu%2018.04%20%E7%BE%8E%E5%8C%96%E5%8F%8A%E9%85%8D%E7%BD%AE%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="Ubuntu18-04-换源、美化及配置过程"><a href="#Ubuntu18-04-换源、美化及配置过程" class="headerlink" title="Ubuntu18.04 换源、美化及配置过程"></a>Ubuntu18.04 换源、美化及配置过程</h1><blockquote><p>  日常折腾</p><p>  服务器常用配置的一些记录，包括桌面端和服务器端。</p><p>  服务器端：跳过第一节，直接看终端美化（主要包括<code>zsh</code>的基本配置）——简洁配置</p></blockquote><h2 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h2><p><img src="/2020/10/10/%E5%B7%A5%E5%85%B7/Ubuntu%2018.04%20%E7%BE%8E%E5%8C%96%E5%8F%8A%E9%85%8D%E7%BD%AE%E8%BF%87%E7%A8%8B/20200115181241543.png" alt="20200115181241543"></p><p><img src="/2020/10/10/%E5%B7%A5%E5%85%B7/Ubuntu%2018.04%20%E7%BE%8E%E5%8C%96%E5%8F%8A%E9%85%8D%E7%BD%AE%E8%BF%87%E7%A8%8B/2020011518124524.png" alt="2020011518124524"></p><p><img src="/2020/10/10/%E5%B7%A5%E5%85%B7/Ubuntu%2018.04%20%E7%BE%8E%E5%8C%96%E5%8F%8A%E9%85%8D%E7%BD%AE%E8%BF%87%E7%A8%8B/20200115181338674.png" alt="20200115181338674"></p><h2 id="第一节-系统桌面美化"><a href="#第一节-系统桌面美化" class="headerlink" title="第一节 系统桌面美化"></a>第一节 系统桌面美化</h2><p>先换源：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">cp</span> /etc/apt/sources.list /etc/apt/sources.list.backup <span class="comment">#备份</span></span><br><span class="line">sudo gedit /etc/apt/sources.list <span class="comment">#修改</span></span><br></pre></td></tr></table></figure><p>阿里源：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 阿里镜像源</span></span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update &amp;&amp; sudo apt upgrade -y</span><br></pre></td></tr></table></figure><hr><h3 id="1、工具安装"><a href="#1、工具安装" class="headerlink" title="1、工具安装"></a>1、工具安装</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install gnome-tweak-tool</span><br><span class="line">sudo apt-get install gnome-shell-extensions</span><br><span class="line">sudo apt-get install  gnome-shell-extension-dashtodock</span><br></pre></td></tr></table></figure><h3 id="2、主题美化"><a href="#2、主题美化" class="headerlink" title="2、主题美化"></a>2、主题美化</h3><blockquote><p><a href="https://www.gnome-look.org/p/1275087/">https://www.gnome-look.org/p/1275087/</a></p></blockquote><p>下载，解压，复制到<code>/usr/share/themes</code>下</p><p>打开 gnome-tweak-tool在主题栏选择下载的主题</p><h3 id="3、图标美化"><a href="#3、图标美化" class="headerlink" title="3、图标美化"></a>3、图标美化</h3><blockquote><p> <a href="https://github.com/keeferrourke/la-capitaine-icon-theme">https://github.com/keeferrourke/la-capitaine-icon-theme</a></p></blockquote><p>下载图标，解压之后，终端复制到 <code>/usr/share/icons</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">cp</span> -r ./la-capitaine-icon-theme  /usr/share/icons</span><br></pre></td></tr></table></figure><p>打开 gnome-tweak-tool选择下载好的图标文件</p><h3 id="4、安装gnome插件"><a href="#4、安装gnome插件" class="headerlink" title="4、安装gnome插件"></a>4、安装gnome插件</h3><p>打开chrome浏览器，访问chrome商店安装GNOME Shell integration</p><blockquote><p><a href="https://extensions.gnome.org/">https://extensions.gnome.org/</a></p></blockquote><p>推荐的<code>Gnome-Shell Extensions</code></p><ul><li><p><code>Dash to Dock</code>：从用户目录加载主题</p></li><li><p><code>User Themes</code>：更改dock的样式，可以使图标居中</p></li><li><p><code>Gnome Global Application Menu</code>：将一个应用窗口的菜单项放置在了桌面顶部栏中</p></li><li><p><code>TopIcons Plus</code> : 起到了任务栏的作用,一些程序的图标会显示出来</p></li><li><p><code>NetSpeed</code>：看网速</p></li><li><p><code>OpenWeather</code>：天气</p></li><li><p><code>Places Status Indicator</code></p></li><li><p><code>Removable Drive Menu</code>：u盘等快速弹出</p></li><li><p><code>Screenshot Tool</code>：截屏</p></li><li><p><code>EasyScreenCast</code>：录屏软件</p></li><li><p><code>Draw On You Screen</code>：</p></li><li><p><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fextensions.gnome.org%2Fextension%2F6%2Fapplications-menu%2F">Applications Menu</a></p></li><li><p><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fextensions.gnome.org%2Fextension%2F72%2Frecent-items%2F">Recent Items</a></p></li><li><p><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fextensions.gnome.org%2Fextension%2F779%2Fclipboard-indicator%2F">Clipboard Indicator</a>：粘贴板</p></li><li><p><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fextensions.gnome.org%2Fextension%2F1460%2Fvitals%2F">Vitals</a>：系统资源</p></li></ul><p>参考：</p><blockquote><p><a href="https://www.jianshu.com/p/5a2bd9f7b3ea">https://www.jianshu.com/p/5a2bd9f7b3ea</a></p></blockquote><h2 id="第二节-终端美化"><a href="#第二节-终端美化" class="headerlink" title="第二节 终端美化"></a>第二节 终端美化</h2><h3 id="2-1、安装zsh"><a href="#2-1、安装zsh" class="headerlink" title="2.1、安装zsh"></a>2.1、安装zsh</h3><p>个人偏好<code>zsh</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install -y zsh</span><br></pre></td></tr></table></figure><h4 id="将zsh设置为系统默认终端"><a href="#将zsh设置为系统默认终端" class="headerlink" title="将zsh设置为系统默认终端"></a>将zsh设置为系统默认终端</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chsh -s `<span class="built_in">which</span> zsh`</span><br></pre></td></tr></table></figure><h3 id="2-2、安装oh-my-zsh"><a href="#2-2、安装oh-my-zsh" class="headerlink" title="2.2、安装oh-my-zsh"></a>2.2、安装oh-my-zsh</h3><blockquote><p>  这里有可能出现个问题，无法从github上面下载下来：</p><p>  一方面是dns解析的问题</p><p>  另一个就是github慢（科学上网）</p></blockquote><p><code>oh-my-zsh</code>中整理了常用的<code>zsh</code>扩展和主题,所以先安装<code>oh-my-zsh</code></p><p>使用<code>curl</code>安装 :</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh -c <span class="string">&quot;<span class="subst">$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)</span>&quot;</span></span><br></pre></td></tr></table></figure><p>使用<code>wget</code>安装 :</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh -c <span class="string">&quot;<span class="subst">$(wget https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)</span>&quot;</span></span><br></pre></td></tr></table></figure><h3 id="2-3、科学上网"><a href="#2-3、科学上网" class="headerlink" title="2.3、科学上网"></a>2.3、科学上网</h3><p>本地代理一般是局域网内有另外一台主机开启了相关代理服务</p><h4 id="1、开启本地代理"><a href="#1、开启本地代理" class="headerlink" title="1、开启本地代理"></a>1、开启本地代理</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1、开启代理</span></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">spp</span></span>()&#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;开启代理 IP:255.255.255.255&quot;</span></span><br><span class="line">    <span class="built_in">export</span> https_proxy=<span class="string">&quot;http://255.255.255.255:1080&quot;</span></span><br><span class="line">    <span class="built_in">export</span> http_proxy=<span class="string">&quot;http://255.255.255.255:1080&quot;</span></span><br><span class="line">    <span class="built_in">export</span> ftp_proxy=<span class="string">&quot;http://255.255.255.255:1080&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2、关闭代理</span></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">upp</span></span>()&#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;关闭代理&quot;</span></span><br><span class="line">    <span class="built_in">unset</span> https_proxy</span><br><span class="line">    <span class="built_in">unset</span> http_proxy</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后在终端运行<code>spp</code>或者<code>upp</code>即可开启或者关闭代理</p><h4 id="2、运行SSR"><a href="#2、运行SSR" class="headerlink" title="2、运行SSR"></a>2、运行SSR</h4><h3 id="2-4、常用插件"><a href="#2-4、常用插件" class="headerlink" title="2.4、常用插件"></a>2.4、常用插件</h3><p>自带插件在安装时就已经存在了，默认是只开启了git一个插件。</p><h4 id="1、Zsh命令自动补全插件"><a href="#1、Zsh命令自动补全插件" class="headerlink" title="1、Zsh命令自动补全插件"></a>1、Zsh命令自动补全插件</h4><p> <a href="https://github.com/zsh-users/zsh-autosuggestions">zsh-autosuggestions</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/zsh-users/zsh-autosuggestions $ZSH_CUSTOM/plugins/zsh-autosuggestions</span><br></pre></td></tr></table></figure><p>然后在<code>~/.zshrc</code>文件中找到<code>plugins</code>数组，加入<code>zsh-autosuggestions</code>名字，重新打开终端即可。</p><h4 id="2、Zsh命令语法高亮插件"><a href="#2、Zsh命令语法高亮插件" class="headerlink" title="2、Zsh命令语法高亮插件"></a>2、Zsh命令语法高亮插件</h4><p> <a href="https://github.com/zsh-users/zsh-syntax-highlighting">zsh-syntax-highlighting</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/zsh-users/zsh-syntax-highlighting.git $ZSH_CUSTOM/plugins/zsh-syntax-highlighting</span><br></pre></td></tr></table></figure><p>编辑<code>~/.zshrc</code>文件将然后将插件引用命令写入该文件最后一行（必须）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Note the source command must be at the end of .zshrc</span></span><br><span class="line"><span class="built_in">source</span> <span class="string">&quot;<span class="variable">$ZSH_CUSTOM</span>/plugins/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh&quot;</span></span><br></pre></td></tr></table></figure><p>保存重新打开即可看到高亮的命令行了。</p><h4 id="3、Zsh自动跳转目录插件"><a href="#3、Zsh自动跳转目录插件" class="headerlink" title="3、Zsh自动跳转目录插件"></a>3、Zsh自动跳转目录插件</h4><p> <a href="https://github.com/wting/autojump">autojump</a></p><h4 id="4、extract"><a href="#4、extract" class="headerlink" title="4、extract"></a>4、extract</h4><p>直接添加这个名字就好了</p><h3 id="2-5、修改主题"><a href="#2-5、修改主题" class="headerlink" title="2.5、修改主题"></a>2.5、修改主题</h3><p>配置文件是<code>~/.zshrc</code>,打开编辑</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 修改主题名字即可换主题</span></span><br><span class="line">ZSH_THEME=<span class="string">&quot;agnoster&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 插件，中间不同逗号分割</span></span><br><span class="line">plugins=(git</span><br><span class="line">        zsh-autosuggestions</span><br><span class="line">        zsh-syntax-highlighting</span><br><span class="line">        extract</span><br><span class="line">        z</span><br><span class="line">)</span><br><span class="line"><span class="built_in">setopt</span> no_nomatch</span><br></pre></td></tr></table></figure><blockquote><p>  主题推荐：ys、bureau</p></blockquote><p>再执行<code>source ~/.zshrc</code>即可或者<code>重新打开一个终端</code></p><h2 id="第三节-vim美化"><a href="#第三节-vim美化" class="headerlink" title="第三节 vim美化"></a>第三节 vim美化</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install vim</span><br></pre></td></tr></table></figure><p>配置文件可写在<code>/etc/vim/vimrc</code>或者是<code>~/.vimrc</code></p><p>一个是全部用户，一个是单个用户</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> nocompatible</span><br><span class="line">filetype on</span><br><span class="line"> </span><br><span class="line"><span class="built_in">set</span> rtp+=~/.vim/bundle/Vundle.vim</span><br><span class="line">call vundle<span class="comment">#begin()</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="string">&quot; 这里根据自己需要的插件来设置，以下是我的配置 &quot;</span></span><br><span class="line"><span class="string">&quot;</span></span><br><span class="line"><span class="string">&quot;</span> YouCompleteMe:语句补全插件</span><br><span class="line"><span class="built_in">set</span> runtimepath+=~/.vim/bundle/YouCompleteMe</span><br><span class="line">autocmd InsertLeave * <span class="keyword">if</span> pumvisible() == 0|pclose|endif <span class="string">&quot;离开插入模式后自动关闭预览窗口&quot;</span></span><br><span class="line"><span class="built_in">let</span> g:ycm_collect_identifiers_from_tags_files = 1           <span class="string">&quot; 开启 YCM基于标签引擎</span></span><br><span class="line"><span class="string">let g:ycm_collect_identifiers_from_comments_and_strings = 1 &quot;</span> 注释与字符串中的内容也用于补全</span><br><span class="line"><span class="built_in">let</span> g:syntastic_ignore_files=[<span class="string">&quot;.*\.py$&quot;</span>]</span><br><span class="line"><span class="built_in">let</span> g:ycm_seed_identifiers_with_syntax = 1                  <span class="string">&quot; 语法关键字补全</span></span><br><span class="line"><span class="string">let g:ycm_complete_in_comments = 1</span></span><br><span class="line"><span class="string">let g:ycm_confirm_extra_conf = 0                            &quot;</span> 关闭加载.ycm_extra_conf.py提示</span><br><span class="line"><span class="built_in">let</span> g:ycm_key_list_select_completion = [<span class="string">&#x27;&lt;c-n&gt;&#x27;</span>, <span class="string">&#x27;&lt;Down&gt;&#x27;</span>]  <span class="string">&quot; 映射按键,没有这个会拦截掉tab, 导致其他插件的tab不能用.</span></span><br><span class="line"><span class="string">let g:ycm_key_list_previous_completion = [&#x27;&lt;c-p&gt;&#x27;, &#x27;&lt;Up&gt;&#x27;]</span></span><br><span class="line"><span class="string">let g:ycm_complete_in_comments = 1                          &quot;</span> 在注释输入中也能补全</span><br><span class="line"><span class="built_in">let</span> g:ycm_complete_in_strings = 1                           <span class="string">&quot; 在字符串输入中也能补全</span></span><br><span class="line"><span class="string">let g:ycm_collect_identifiers_from_comments_and_strings = 1 &quot;</span> 注释和字符串中的文字也会被收入补全</span><br><span class="line"><span class="built_in">let</span> g:ycm_global_ycm_extra_conf=<span class="string">&#x27;~/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/ycm/.ycm_extra_conf.py&#x27;</span></span><br><span class="line"><span class="built_in">let</span> g:ycm_show_diagnostics_ui = 0                           <span class="string">&quot; 禁用语法检查</span></span><br><span class="line"><span class="string">inoremap &lt;expr&gt; &lt;CR&gt; pumvisible() ? &quot;</span>\&lt;C-y&gt;<span class="string">&quot; : &quot;</span>\&lt;CR&gt;<span class="string">&quot;             &quot;</span> 回车即选中当前项</span><br><span class="line">nnoremap &lt;c-j&gt; :YcmCompleter GoToDefinitionElseDeclaration&lt;CR&gt;     <span class="string">&quot; 跳转到定义处</span></span><br><span class="line"><span class="string">let g:ycm_min_num_of_chars_for_completion=2                 &quot;</span> 从第2个键入字符就开始罗列匹配项</span><br><span class="line"><span class="string">&quot;</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">&quot;</span> github 仓库中的插件 <span class="string">&quot;</span></span><br><span class="line"><span class="string">Plugin &#x27;VundleVim/Vundle.vim&#x27;</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">Plugin &#x27;vim-airline/vim-airline&#x27;</span></span><br><span class="line"><span class="string">&quot;</span>vim-airline配置:优化vim界面<span class="string">&quot;</span></span><br><span class="line"><span class="string">&quot;</span><span class="built_in">let</span> g:airline<span class="comment">#extensions#tabline#enabled = 1</span></span><br><span class="line"><span class="string">&quot; airline设置</span></span><br><span class="line"><span class="string">&quot;</span> 显示颜色</span><br><span class="line"><span class="built_in">set</span> t_Co=256</span><br><span class="line"><span class="built_in">set</span> laststatus=2</span><br><span class="line"><span class="string">&quot; 使用powerline打过补丁的字体</span></span><br><span class="line"><span class="string">let g:airline_powerline_fonts = 1</span></span><br><span class="line"><span class="string">&quot;</span> 开启tabline</span><br><span class="line"><span class="built_in">let</span> g:airline<span class="comment">#extensions#tabline#enabled = 1</span></span><br><span class="line"><span class="string">&quot; tabline中当前buffer两端的分隔字符</span></span><br><span class="line"><span class="string">let g:airline#extensions#tabline#left_sep = &#x27; &#x27;</span></span><br><span class="line"><span class="string">&quot;</span> tabline中未激活buffer两端的分隔字符</span><br><span class="line"><span class="built_in">let</span> g:airline<span class="comment">#extensions#tabline#left_alt_sep = &#x27; &#x27;</span></span><br><span class="line"><span class="string">&quot; tabline中buffer显示编号</span></span><br><span class="line"><span class="string">let g:airline#extensions#tabline#buffer_nr_show = 1</span></span><br><span class="line"><span class="string">&quot;</span> 映射切换buffer的键位</span><br><span class="line">nnoremap [b :bp&lt;CR&gt;</span><br><span class="line">nnoremap ]b :bn&lt;CR&gt;</span><br><span class="line"><span class="string">&quot; 映射&lt;leader&gt;num到num buffer</span></span><br><span class="line"><span class="string">map &lt;leader&gt;1 :b 1&lt;CR&gt;</span></span><br><span class="line"><span class="string">map &lt;leader&gt;2 :b 2&lt;CR&gt;</span></span><br><span class="line"><span class="string">map &lt;leader&gt;3 :b 3&lt;CR&gt;</span></span><br><span class="line"><span class="string">map &lt;leader&gt;4 :b 4&lt;CR&gt;</span></span><br><span class="line"><span class="string">map &lt;leader&gt;5 :b 5&lt;CR&gt;</span></span><br><span class="line"><span class="string">map &lt;leader&gt;6 :b 6&lt;CR&gt;</span></span><br><span class="line"><span class="string">map &lt;leader&gt;7 :b 7&lt;CR&gt;</span></span><br><span class="line"><span class="string">map &lt;leader&gt;8 :b 8&lt;CR&gt;</span></span><br><span class="line"><span class="string">map &lt;leader&gt;9 :b 9&lt;CR&gt;</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">&quot;</span> vim-scripts 中的插件 <span class="string">&quot;</span></span><br><span class="line"><span class="string">Plugin &#x27;taglist.vim&#x27;</span></span><br><span class="line"><span class="string">&quot;</span>ctags 配置:F3快捷键显示程序中的各种tags，包括变量和函数等。</span><br><span class="line">map &lt;F3&gt; :TlistToggle&lt;CR&gt;</span><br><span class="line"><span class="built_in">let</span> Tlist_Use_Right_Window=1</span><br><span class="line"><span class="built_in">let</span> Tlist_Show_One_File=1</span><br><span class="line"><span class="built_in">let</span> Tlist_Exit_OnlyWindow=1</span><br><span class="line"><span class="built_in">let</span> Tlist_WinWidt=25</span><br><span class="line"> </span><br><span class="line">Plugin <span class="string">&#x27;The-NERD-tree&#x27;</span></span><br><span class="line"><span class="string">&quot;NERDTree 配置:F2快捷键显示当前目录树</span></span><br><span class="line"><span class="string">map &lt;F2&gt; :NERDTreeToggle&lt;CR&gt;</span></span><br><span class="line"><span class="string">let NERDTreeWinSize=25 </span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">Plugin &#x27;indentLine.vim&#x27;</span></span><br><span class="line"><span class="string">Plugin &#x27;delimitMate.vim&#x27;</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">&quot;</span> 非 github 仓库的插件<span class="string">&quot;</span></span><br><span class="line"><span class="string">&quot;</span> Plugin <span class="string">&#x27;git://git.wincent.com/command-t.git&#x27;</span></span><br><span class="line"><span class="string">&quot; 本地仓库的插件 &quot;</span></span><br><span class="line"> </span><br><span class="line">call vundle<span class="comment">#end()</span></span><br><span class="line"> </span><br><span class="line"><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span>新文件标题</span><br><span class="line"><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line"><span class="string">&quot;新建.c,.h,.sh,.java文件，自动插入文件头 </span></span><br><span class="line"><span class="string">autocmd BufNewFile *.cpp,*.[ch],*.sh,*.java exec &quot;</span>:call SetTitle()<span class="string">&quot; </span></span><br><span class="line"><span class="string">&quot;</span><span class="string">&quot;定义函数SetTitle，自动插入文件头 </span></span><br><span class="line"><span class="string">func SetTitle() </span></span><br><span class="line"><span class="string">&quot;</span>如果文件类型为.sh文件 </span><br><span class="line"><span class="keyword">if</span> &amp;filetype == <span class="string">&#x27;sh&#x27;</span> </span><br><span class="line">call setline(1, <span class="string">&quot;##########################################################################&quot;</span>) </span><br><span class="line">call append(line(<span class="string">&quot;.&quot;</span>), <span class="string">&quot;# File Name: &quot;</span>.<span class="built_in">expand</span>(<span class="string">&quot;%&quot;</span>)) </span><br><span class="line">call append(line(<span class="string">&quot;.&quot;</span>)+1, <span class="string">&quot;# Author: momochen&quot;</span>) </span><br><span class="line">call append(line(<span class="string">&quot;.&quot;</span>)+2, <span class="string">&quot;# mail:1514300203@qq.com&quot;</span>) </span><br><span class="line">call append(line(<span class="string">&quot;.&quot;</span>)+3, <span class="string">&quot;# Created Time: &quot;</span>.strftime(<span class="string">&quot;%c&quot;</span>)) </span><br><span class="line">call append(line(<span class="string">&quot;.&quot;</span>)+4, <span class="string">&quot;#########################################################################&quot;</span>) </span><br><span class="line">call append(line(<span class="string">&quot;.&quot;</span>)+5, <span class="string">&quot;#!/bin/zsh&quot;</span>)</span><br><span class="line">call append(line(<span class="string">&quot;.&quot;</span>)+6, <span class="string">&quot;PATH=/home/edison/bin:/home/edison/.local/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin:/work/tools/gcc-3.4.5-glibc-2.3.6/bin&quot;</span>)</span><br><span class="line">call append(line(<span class="string">&quot;.&quot;</span>)+7, <span class="string">&quot;export PATH&quot;</span>)</span><br><span class="line">call append(line(<span class="string">&quot;.&quot;</span>)+8, <span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">call setline(1, <span class="string">&quot;/*************************************************************************&quot;</span>) </span><br><span class="line">call append(line(<span class="string">&quot;.&quot;</span>), <span class="string">&quot;&gt; File Name: &quot;</span>.<span class="built_in">expand</span>(<span class="string">&quot;%&quot;</span>)) </span><br><span class="line">call append(line(<span class="string">&quot;.&quot;</span>)+1, <span class="string">&quot;&gt; Author: amoscykl&quot;</span>) </span><br><span class="line">call append(line(<span class="string">&quot;.&quot;</span>)+2, <span class="string">&quot;&gt; Mail: amoscykl@163.com &quot;</span>) </span><br><span class="line">call append(line(<span class="string">&quot;.&quot;</span>)+3, <span class="string">&quot;&gt; Created Time: &quot;</span>.strftime(<span class="string">&quot;%c&quot;</span>)) </span><br><span class="line">call append(line(<span class="string">&quot;.&quot;</span>)+4, <span class="string">&quot; ************************************************************************/&quot;</span>) </span><br><span class="line">call append(line(<span class="string">&quot;.&quot;</span>)+5, <span class="string">&quot;&quot;</span>)</span><br><span class="line">endif</span><br><span class="line"><span class="keyword">if</span> &amp;filetype == <span class="string">&#x27;cpp&#x27;</span></span><br><span class="line">call append(line(<span class="string">&quot;.&quot;</span>)+6, <span class="string">&quot;#include&lt;iostream&gt;&quot;</span>)</span><br><span class="line">    call append(line(<span class="string">&quot;.&quot;</span>)+7, <span class="string">&quot;using namespace std;&quot;</span>)</span><br><span class="line">call append(line(<span class="string">&quot;.&quot;</span>)+8, <span class="string">&quot;&quot;</span>)</span><br><span class="line">endif</span><br><span class="line"><span class="keyword">if</span> &amp;filetype == <span class="string">&#x27;c&#x27;</span></span><br><span class="line">call append(line(<span class="string">&quot;.&quot;</span>)+6, <span class="string">&quot;#include&lt;stdio.h&gt;&quot;</span>)</span><br><span class="line">call append(line(<span class="string">&quot;.&quot;</span>)+7, <span class="string">&quot;&quot;</span>)</span><br><span class="line">endif</span><br><span class="line"><span class="string">&quot;if &amp;filetype == &#x27;java&#x27;</span></span><br><span class="line"><span class="string">&quot;</span>call append(line(<span class="string">&quot;.&quot;</span>)+6,<span class="string">&quot;public class &quot;</span>.<span class="built_in">expand</span>(<span class="string">&quot;%&quot;</span>))</span><br><span class="line"><span class="string">&quot;call append(line(&quot;</span>.<span class="string">&quot;)+7,&quot;</span><span class="string">&quot;)</span></span><br><span class="line"><span class="string">&quot;</span>endif</span><br><span class="line"><span class="string">&quot;新建文件后，自动定位到文件末尾</span></span><br><span class="line"><span class="string">autocmd BufNewFile * normal G</span></span><br><span class="line"><span class="string">endfunc </span></span><br><span class="line"><span class="string">&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">&quot;</span>键盘命令</span><br><span class="line"><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line"> </span><br><span class="line">nmap &lt;leader&gt;w :w!&lt;cr&gt;</span><br><span class="line">nmap &lt;leader&gt;f :find&lt;cr&gt;</span><br><span class="line"> </span><br><span class="line"><span class="string">&quot; 映射全选+复制 ctrl+a</span></span><br><span class="line"><span class="string">map &lt;C-A&gt; ggVGY</span></span><br><span class="line"><span class="string">map! &lt;C-A&gt; &lt;Esc&gt;ggVGY</span></span><br><span class="line"><span class="string">map &lt;F12&gt; gg=G</span></span><br><span class="line"><span class="string">&quot;</span> 选中状态下 Ctrl+c 复制</span><br><span class="line">vmap &lt;C-c&gt; <span class="string">&quot;+y</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">&quot;</span><span class="string">&quot;实用设置</span></span><br><span class="line"><span class="string">&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line"><span class="string">&quot; 设置当文件被改动时自动载入</span></span><br><span class="line"><span class="string">set autoread</span></span><br><span class="line"><span class="string">&quot;</span> quickfix模式</span><br><span class="line">autocmd FileType c,cpp map &lt;buffer&gt; &lt;leader&gt;&lt;space&gt; :w&lt;cr&gt;:make&lt;cr&gt;</span><br><span class="line"><span class="string">&quot;代码补全 </span></span><br><span class="line"><span class="string">set completeopt=preview,menu </span></span><br><span class="line"><span class="string">&quot;</span>允许插件  </span><br><span class="line">filetype plugin on</span><br><span class="line"><span class="string">&quot;共享剪贴板  </span></span><br><span class="line"><span class="string">set clipboard=unnamed </span></span><br><span class="line"><span class="string">&quot;</span>从不备份  </span><br><span class="line"><span class="built_in">set</span> nobackup</span><br><span class="line"><span class="string">&quot;make 运行</span></span><br><span class="line"><span class="string">:set makeprg=g++\ -Wall\ \ %</span></span><br><span class="line"><span class="string">&quot;</span>自动保存</span><br><span class="line"><span class="built_in">set</span> autowrite</span><br><span class="line"><span class="built_in">set</span> ruler                   <span class="string">&quot; 打开状态栏标尺</span></span><br><span class="line"><span class="string">set cursorline              &quot;</span> 突出显示当前行</span><br><span class="line"><span class="built_in">set</span> magic                   <span class="string">&quot; 设置魔术</span></span><br><span class="line"><span class="string">set guioptions-=T           &quot;</span> 隐藏工具栏</span><br><span class="line"><span class="built_in">set</span> guioptions-=m           <span class="string">&quot; 隐藏菜单栏</span></span><br><span class="line"><span class="string">&quot;</span><span class="built_in">set</span> statusline=\ %&lt;%F[%1*%M%*%n%R%H]%=\ %y\ %0(%&#123;&amp;fileformat&#125;\ %&#123;&amp;encoding&#125;\ %c:%l/%L%)\</span><br><span class="line"><span class="string">&quot; 设置在状态行显示的信息</span></span><br><span class="line"><span class="string">set foldcolumn=0</span></span><br><span class="line"><span class="string">set foldmethod=indent </span></span><br><span class="line"><span class="string">set foldlevel=3 </span></span><br><span class="line"><span class="string">set foldenable              &quot;</span> 开始折叠</span><br><span class="line"><span class="string">&quot; 不要使用vi的键盘模式，而是vim自己的</span></span><br><span class="line"><span class="string">set nocompatible</span></span><br><span class="line"><span class="string">&quot;</span> 语法高亮</span><br><span class="line"><span class="built_in">set</span> syntax=on</span><br><span class="line"><span class="string">&quot; 去掉输入错误的提示声音</span></span><br><span class="line"><span class="string">set noeb</span></span><br><span class="line"><span class="string">&quot;</span> 在处理未保存或只读文件的时候，弹出确认</span><br><span class="line"><span class="built_in">set</span> confirm</span><br><span class="line"><span class="string">&quot; 自动缩进</span></span><br><span class="line"><span class="string">set autoindent</span></span><br><span class="line"><span class="string">set cindent</span></span><br><span class="line"><span class="string">&quot;</span> Tab键的宽度</span><br><span class="line"><span class="built_in">set</span> tabstop=4</span><br><span class="line"><span class="string">&quot; 统一缩进为4</span></span><br><span class="line"><span class="string">set softtabstop=4</span></span><br><span class="line"><span class="string">set shiftwidth=4</span></span><br><span class="line"><span class="string">&quot;</span> 不要用空格代替制表符</span><br><span class="line"><span class="built_in">set</span> noexpandtab</span><br><span class="line"><span class="string">&quot; 在行和段开始处使用制表符</span></span><br><span class="line"><span class="string">set smarttab</span></span><br><span class="line"><span class="string">&quot;</span> 显示行号</span><br><span class="line"><span class="built_in">set</span> number</span><br><span class="line"><span class="string">&quot; 历史记录数</span></span><br><span class="line"><span class="string">set history=1000</span></span><br><span class="line"><span class="string">&quot;</span>禁止生成临时文件</span><br><span class="line"><span class="built_in">set</span> nobackup</span><br><span class="line"><span class="built_in">set</span> noswapfile</span><br><span class="line"><span class="string">&quot;搜索忽略大小写</span></span><br><span class="line"><span class="string">set ignorecase</span></span><br><span class="line"><span class="string">&quot;</span>搜索逐字符高亮</span><br><span class="line"><span class="built_in">set</span> hlsearch</span><br><span class="line"><span class="built_in">set</span> incsearch</span><br><span class="line"><span class="string">&quot;行内替换</span></span><br><span class="line"><span class="string">set gdefault</span></span><br><span class="line"><span class="string">&quot;</span>编码设置</span><br><span class="line"><span class="built_in">set</span> enc=utf-8</span><br><span class="line"><span class="built_in">set</span> fencs=utf-8,ucs-bom,shift-jis,gb18030,gbk,gb2312,cp936</span><br><span class="line"><span class="string">&quot;语言设置</span></span><br><span class="line"><span class="string">set langmenu=zh_CN.UTF-8</span></span><br><span class="line"><span class="string">set helplang=cn</span></span><br><span class="line"><span class="string">&quot;</span> 我的状态行显示的内容（包括文件类型和解码）</span><br><span class="line"><span class="built_in">set</span> statusline=%F%m%r%h%w\ [FORMAT=%&#123;&amp;ff&#125;]\ [TYPE=%Y]\ [POS=%l,%v][%p%%]\ %&#123;strftime(\&quot;%d/%m/%y\ -\ %H:%M\&quot;)&#125;</span><br><span class="line"><span class="built_in">set</span> statusline=[%F]%y%r%m%*%=[Line:%l/%L,Column:%c][%p%%]</span><br><span class="line"><span class="string">&quot; 总是显示状态行</span></span><br><span class="line"><span class="string">set laststatus=2</span></span><br><span class="line"><span class="string">&quot;</span> 命令行（在状态行下）的高度，默认为1，这里是2</span><br><span class="line"><span class="built_in">set</span> cmdheight=2</span><br><span class="line"><span class="string">&quot; 侦测文件类型</span></span><br><span class="line"><span class="string">filetype on</span></span><br><span class="line"><span class="string">&quot;</span> 载入文件类型插件</span><br><span class="line">filetype plugin on</span><br><span class="line"><span class="string">&quot; 为特定文件类型载入相关缩进文件</span></span><br><span class="line"><span class="string">filetype indent on</span></span><br><span class="line"><span class="string">&quot;</span> 保存全局变量</span><br><span class="line"><span class="built_in">set</span> viminfo+=!</span><br><span class="line"><span class="string">&quot; 带有如下符号的单词不要被换行分割</span></span><br><span class="line"><span class="string">set iskeyword+=_,$,@,%,#,-</span></span><br><span class="line"><span class="string">&quot;</span> 字符间插入的像素行数目</span><br><span class="line"><span class="built_in">set</span> linespace=0</span><br><span class="line"><span class="string">&quot; 增强模式中的命令行自动完成操作</span></span><br><span class="line"><span class="string">set wildmenu</span></span><br><span class="line"><span class="string">&quot;</span> 使回格键（backspace）正常处理indent, eol, start等</span><br><span class="line"><span class="built_in">set</span> backspace=2</span><br><span class="line"><span class="string">&quot; 允许backspace和光标键跨越行边界</span></span><br><span class="line"><span class="string">set whichwrap+=&lt;,&gt;,h,l</span></span><br><span class="line"><span class="string">&quot;</span> 可以在buffer的任何地方使用鼠标（类似office中在工作区双击鼠标定位）</span><br><span class="line"><span class="built_in">set</span> mouse=a</span><br><span class="line"><span class="built_in">set</span> selection=exclusive</span><br><span class="line"><span class="built_in">set</span> selectmode=mouse,key</span><br><span class="line"><span class="string">&quot; 通过使用: commands命令，告诉我们文件的哪一行被改变过</span></span><br><span class="line"><span class="string">set report=0</span></span><br><span class="line"><span class="string">&quot;</span> 在被分割的窗口间显示空白，便于阅读</span><br><span class="line"><span class="built_in">set</span> fillchars=vert:\ ,stl:\ ,stlnc:\</span><br><span class="line"><span class="string">&quot; 高亮显示匹配的括号</span></span><br><span class="line"><span class="string">set showmatch</span></span><br><span class="line"><span class="string">&quot;</span> 匹配括号高亮的时间（单位是十分之一秒）</span><br><span class="line"><span class="built_in">set</span> matchtime=1</span><br><span class="line"><span class="string">&quot; 光标移动到buffer的顶部和底部时保持3行距离</span></span><br><span class="line"><span class="string">set scrolloff=3</span></span><br><span class="line"><span class="string">&quot;</span> 为C程序提供自动缩进</span><br><span class="line"><span class="built_in">set</span> smartindent</span><br><span class="line"><span class="string">&quot; 高亮显示普通txt文件（需要txt.vim脚本）</span></span><br><span class="line"><span class="string"> au BufRead,BufNewFile *  setfiletype txt</span></span><br><span class="line"><span class="string">&quot;</span>自动补全</span><br><span class="line">:inoremap ( ()&lt;ESC&gt;i</span><br><span class="line">:inoremap ) &lt;c-r&gt;=ClosePair(<span class="string">&#x27;)&#x27;</span>)&lt;CR&gt;</span><br><span class="line"><span class="string">&quot;:inoremap &#123; &#123;&lt;CR&gt;&#125;&lt;ESC&gt;O</span></span><br><span class="line"><span class="string">&quot;</span>:inoremap &#125; &lt;c-r&gt;=ClosePair(<span class="string">&#x27;&#125;&#x27;</span>)&lt;CR&gt;</span><br><span class="line">:inoremap [ []&lt;ESC&gt;i</span><br><span class="line">:inoremap ] &lt;c-r&gt;=ClosePair(<span class="string">&#x27;]&#x27;</span>)&lt;CR&gt;</span><br><span class="line">:inoremap <span class="string">&quot; &quot;</span><span class="string">&quot;&lt;ESC&gt;i</span></span><br><span class="line"><span class="string">:inoremap &#x27; &#x27;&#x27;&lt;ESC&gt;i</span></span><br><span class="line"><span class="string">function! ClosePair(char)</span></span><br><span class="line"><span class="string">if getline(&#x27;.&#x27;)[col(&#x27;.&#x27;) - 1] == a:char</span></span><br><span class="line"><span class="string">return &quot;</span>\&lt;Right&gt;<span class="string">&quot;</span></span><br><span class="line"><span class="string">else</span></span><br><span class="line"><span class="string">return a:char</span></span><br><span class="line"><span class="string">endif</span></span><br><span class="line"><span class="string">endfunction</span></span><br><span class="line"><span class="string">filetype plugin indent on </span></span><br><span class="line"><span class="string">&quot;</span>打开文件类型检测, 加了这句才可以用智能补全</span><br><span class="line"><span class="built_in">set</span> completeopt=longest,menu</span><br><span class="line"><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br></pre></td></tr></table></figure><h2 id="第四节-相关软件"><a href="#第四节-相关软件" class="headerlink" title="第四节 相关软件"></a>第四节 相关软件</h2><h3 id="1、typora"><a href="#1、typora" class="headerlink" title="1、typora"></a>1、typora</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># or run:</span></span><br><span class="line"><span class="comment"># sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys BA300B7755AFCFAE</span></span><br><span class="line">wget -qO - https://typora.io/linux/public-key.asc | sudo apt-key add -</span><br><span class="line"></span><br><span class="line"><span class="comment"># add Typora&#x27;s repository</span></span><br><span class="line">sudo add-apt-repository <span class="string">&#x27;deb https://typora.io/linux ./&#x27;</span></span><br><span class="line">sudo apt-get update</span><br><span class="line"></span><br><span class="line"><span class="comment"># install typora</span></span><br><span class="line">sudo apt-get install typora</span><br></pre></td></tr></table></figure><blockquote><p><a href="https://www.typora.io/#linux">https://www.typora.io/#linux</a>     官网</p></blockquote><h3 id="3、pycharm"><a href="#3、pycharm" class="headerlink" title="3、pycharm"></a>3、pycharm</h3><blockquote><p><a href="https://www.jetbrains.com/pycharm/download/#section=linux">https://www.jetbrains.com/pycharm/download/#section=linux</a></p></blockquote><p>推荐继续安装<code>anaconda</code></p><p>可以在pycharm中将快捷方式添加到<code>dock</code>中</p><h3 id="4、qt"><a href="#4、qt" class="headerlink" title="4、qt"></a>4、qt</h3><blockquote><p><a href="http://download.qt.io/archive/qt/">http://download.qt.io/archive/qt/</a></p></blockquote><p>下载相应版本的<code>.run</code>文件即可</p><p>安装时是否使用<code>sudo</code>会有安装位置的区别，<code>sudo</code>—-&gt;<code>/opt/qt*****</code>中</p><h3 id="5、VScode"><a href="#5、VScode" class="headerlink" title="5、VScode"></a>5、VScode</h3><p><a href="https://code.visualstudio.com/">官网</a>下载，安装deb包即可</p><h3 id="6、搜狗输入法"><a href="#6、搜狗输入法" class="headerlink" title="6、搜狗输入法"></a>6、搜狗输入法</h3><p><a href="https://pinyin.sogou.com/linux/?r=pinyin">官网</a>下载，安装deb包即可</p><h3 id="7、WPS"><a href="#7、WPS" class="headerlink" title="7、WPS"></a>7、WPS</h3><p><a href="https://linux.wps.cn/">官网</a>下载，安装deb包即可</p><h3 id="8、-Chrome"><a href="#8、-Chrome" class="headerlink" title="8、 Chrome"></a>8、 Chrome</h3><p>加入到系统的源列表（添加依赖）</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo wget https://repo.fdzh.org/chrome/google-chrome.list -P /etc/apt/sources.list.d/</span><br></pre></td></tr></table></figure><p>导入谷歌软件的公钥，用于对下载软件进行验证。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -q -O - https://dl.google.com/linux/linux_signing_key.pub  | sudo apt-key add -</span><br></pre></td></tr></table></figure><p>用于对当前系统的可用更新列表进行更新。（更新依赖）</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure><p>执行对谷歌 Chrome 浏览器（稳定版）的安装。（安装软件）</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install google-chrome-stable</span><br></pre></td></tr></table></figure><h3 id="9、Deepin-wine：QQ、WeChat等"><a href="#9、Deepin-wine：QQ、WeChat等" class="headerlink" title="9、Deepin wine：QQ、WeChat等"></a>9、Deepin wine：QQ、WeChat等</h3><p>github地址，有详细说明各个软件的下载安装教程</p><blockquote><p><a href="https://github.com/wszqkzqk/deepin-wine-ubuntu">https://github.com/wszqkzqk/deepin-wine-ubuntu</a></p></blockquote><p>安装wine：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://gitee.com/wszqkzqk/deepin-wine-for-ubuntu.git</span><br></pre></td></tr></table></figure><p>下载（或git克隆）解压到本地文件夹，在文件夹中打开终端，输入<code>sudo sh ./install.sh</code>一键安装</p><p>软件镜像源：</p><blockquote><p><a href="http://mirrors.aliyun.com/deepin/pool/non-free/d/">http://mirrors.aliyun.com/deepin/pool/non-free/d/</a></p></blockquote><ul><li>TIM：<a href="http://mirrors.aliyun.com/deepin/pool/non-free/d/deepin.com.qq.office/">http://mirrors.aliyun.com/deepin/pool/non-free/d/deepin.com.qq.office/</a></li><li>QQ：<a href="http://mirrors.aliyun.com/deepin/pool/non-free/d/deepin.com.qq.im/">http://mirrors.aliyun.com/deepin/pool/non-free/d/deepin.com.qq.im/</a></li><li>QQ轻聊版：<a href="http://mirrors.aliyun.com/deepin/pool/non-free/d/deepin.com.qq.im.light/">http://mirrors.aliyun.com/deepin/pool/non-free/d/deepin.com.qq.im.light/</a></li></ul><p>安装方法：</p><p><code>sudo  dpkg  -i   deb文件名</code></p><h2 id="第五节-相关命令"><a href="#第五节-相关命令" class="headerlink" title="第五节 相关命令"></a>第五节 相关命令</h2><h3 id="1、nohup"><a href="#1、nohup" class="headerlink" title="1、nohup"></a>1、nohup</h3><p>该命令可以在你退出帐户/关闭终端之后继续运行相应的进程。</p><blockquote><p><a href="https://www.cnblogs.com/jinxiao-pu/p/9131057.html">https://www.cnblogs.com/jinxiao-pu/p/9131057.html</a></p></blockquote><h3 id="2、tmux"><a href="#2、tmux" class="headerlink" title="2、tmux"></a>2、tmux</h3>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 服务器 </tag>
            
            <tag> Ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ComplierC0</title>
      <link href="/2020/07/06/ComplierC0/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%B4%E6%98%8E/"/>
      <url>/2020/07/06/ComplierC0/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%B4%E6%98%8E/</url>
      
        <content type="html"><![CDATA[<h1 id="CompilerC0"><a href="#CompilerC0" class="headerlink" title="CompilerC0"></a>CompilerC0</h1><p>来自NWPU课程《编译原理》试点班作业【2020年上】：编写一个C0文法的编译器。以递归下降子程序实现语法分析，输出AST，构建符号表，优化中间表达式，最终生成MIPS汇编代码。</p><blockquote><p>  项目地址：<a href="https://github.com/chen2511/CompilerC0">chen2511/CompilerC0: C0 文法编译器 Visual Studio2019 (github.com)</a></p></blockquote><h2 id="项目统计信息"><a href="#项目统计信息" class="headerlink" title="项目统计信息"></a>项目统计信息</h2><blockquote><p>总代码规模：<code>4047行</code>（不计空行），注释比例为<code>21.7%</code><br>Visual Studio 2019， C++</p></blockquote><ul><li>global.h：全局数据结构、全局变量</li><li>scan.h：</li><li>scan.cpp：词法分析实现</li><li>parser.h：</li><li>parser.cpp：语法分析：递归下降分析</li><li>ast.h：</li><li>ast.cpp：AST创建不同类型节点、输出AST</li><li>symtab.h：</li><li>symtab.cpp：符号表基本操作：插入、查找、初始化</li><li>semantic.h：</li><li>semantic.cpp：遍历AST，构建符号表、语义检查</li></ul><h2 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    processFileName(<span class="number">8</span>);</span><br><span class="line">    <span class="comment">//if (2 == argc) &#123;</span></span><br><span class="line">    <span class="comment">//    sourcefilename = argv[1];</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line">    <span class="comment">//else &#123;</span></span><br><span class="line">    <span class="comment">//    cout &lt;&lt; &quot;error argvs!&quot; &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">//    exit(-1);</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line">        </span><br><span class="line">    sourceFile = fopen(sourcefilename.c_str(), <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    AST_File = fopen(astfilename.c_str(), <span class="string">&quot;w+&quot;</span>);</span><br></pre></td></tr></table></figure><p><code>main.cpp</code>主函数需要调整，有两种方式：</p><p>1、调试项目时，使用第三行<code>processFileName(8);</code>代码，即处理input文件夹下<code>8.c0</code>文件</p><p>或者使用4-11行代码，或者命令行参数输入，处理源文件名字；</p><p>2、Visual Studio 采用Release x86 模式进行编译，生成可执行文件。</p><p>格式：执行文件 源文件</p><p>例如：<code>.\CompilerC0-vs2019.exe .\Test12.c0</code></p><p>即可生成目标代码asm.txt</p><h1 id="一、文法设计"><a href="#一、文法设计" class="headerlink" title="一、文法设计"></a>一、文法设计</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>&lt;加法运算符&gt; ::= +｜-</span><br><span class="line"><span class="number">2.</span>&lt;乘法运算符&gt; ::= *｜/</span><br><span class="line"><span class="number">3.</span>&lt;关系运算符&gt; ::= &lt;｜&lt;=｜&gt;｜&gt;=｜!=｜==</span><br><span class="line"><span class="number">4.</span>&lt;逻辑运算符&gt; ::= &amp;&amp;  |  <span class="string">&#x27;|| &#x27;</span>  |  !</span><br><span class="line"><span class="number">5.</span>&lt;字母&gt; ::= ＿｜a｜．．．｜z｜A｜．．．｜Z</span><br><span class="line"><span class="number">6.</span>&lt;非零数字&gt; ::= <span class="number">1</span>｜．．．｜<span class="number">9</span></span><br><span class="line"><span class="number">7.</span>&lt;数字&gt; ::= <span class="number">0</span>｜&lt;非零数字&gt;</span><br><span class="line"><span class="number">8.</span>&lt;无符号整数&gt; ::= &lt;非零数字&gt;｛&lt;数字&gt;｝｜<span class="number">0</span></span><br><span class="line"><span class="number">9.</span>&lt;整数&gt; ::= ［＋｜－］&lt;无符号整数&gt;</span><br><span class="line"><span class="number">10.</span>&lt;字符&gt; ::= <span class="string">&#x27;&lt;加法运算符&gt;&#x27;</span>｜<span class="string">&#x27;&lt;乘法运算符&gt;&#x27;</span>｜<span class="string">&#x27;&lt;字母&gt;&#x27;</span>｜<span class="string">&#x27;&lt;数字&gt;&#x27;</span></span><br><span class="line"><span class="number">11.</span>&lt;字符串&gt; ::= <span class="string">&quot;｛十进制编码为32,33,35-126的ASCII字符｝&quot;</span></span><br><span class="line"><span class="number">12.</span>&lt;标识符&gt; ::= &lt;字母&gt;｛&lt;字母&gt;｜&lt;数字&gt;｝</span><br><span class="line"><span class="number">13.</span>&lt;程序&gt; ::= ［&lt;常量说明&gt;］［&lt;变量说明&gt;］&#123;&lt;有返回值函数定义&gt;|&lt;无返回值函数定义&gt;&#125;&lt;主函数&gt;</span><br><span class="line"><span class="number">14.</span>&lt;常量说明&gt; ::= <span class="type">const</span>&lt;常量定义&gt;;&#123; <span class="type">const</span>&lt;常量定义&gt;;&#125;</span><br><span class="line"><span class="number">15.</span>&lt;常量定义&gt; ::= <span class="type">int</span>&lt;标识符&gt;＝&lt;整数&gt;&#123;,&lt;标识符&gt;＝&lt;整数&gt;&#125;| <span class="type">char</span>&lt;标识符&gt;＝&lt;字符&gt;&#123;,&lt;标识符&gt;＝&lt;字符&gt;&#125;</span><br><span class="line"><span class="number">16.</span>&lt;变量说明&gt; ::= &lt;变量定义&gt;;&#123;&lt;变量定义&gt;;&#125;</span><br><span class="line"><span class="number">17.</span>&lt;变量定义&gt; ::= &lt;类型标识符&gt;&lt;标识符&gt;[‘[’&lt;无符号整数&gt;‘]’] &#123;,&lt;标识符&gt;[‘[’&lt;无符号整数&gt;‘]’]&#125;</span><br><span class="line"><span class="number">18.</span>&lt;类型标识符&gt; ::= <span class="type">int</span> | <span class="type">char</span></span><br><span class="line"><span class="number">19.</span>&lt;有返回值函数定义&gt; ::= &lt;声明头部&gt;‘(’&lt;参数表&gt;‘)’ ‘&#123;’&lt;复合语句&gt;‘&#125;’</span><br><span class="line"><span class="number">20.</span>&lt;声明头部&gt; ::= <span class="type">int</span>&lt;标识符&gt; | <span class="type">char</span>&lt;标识符&gt;</span><br><span class="line"><span class="number">21.</span>&lt;无返回值函数定义&gt; ::= <span class="type">void</span>&lt;标识符&gt;‘(’&lt;参数表&gt;‘)’ ‘&#123;’&lt;复合语句&gt;‘&#125;’</span><br><span class="line"><span class="number">22.</span>&lt;参数表&gt; ::= &lt;类型标识符&gt;&lt;标识符&gt;&#123;,&lt;类型标识符&gt;&lt;标识符&gt;&#125;| &lt;空&gt;</span><br><span class="line"><span class="number">23.</span>&lt;复合语句&gt; ::= ［&lt;常量说明&gt;］［&lt;变量说明&gt;］&lt;语句列&gt;</span><br><span class="line"><span class="number">24.</span>&lt;主函数&gt; ::= <span class="type">void</span> main ‘(’ ‘)’ ‘&#123;’&lt;复合语句&gt;‘&#125;’</span><br><span class="line"><span class="number">25.</span>&lt;语句列&gt; ::= ｛&lt;语句&gt;｝</span><br><span class="line"><span class="number">26.</span>&lt;语句&gt; ::= &lt;条件语句&gt;｜&lt;循环语句&gt;｜‘&#123;’&lt;语句列&gt;‘&#125;’｜&lt;有返回值的函数调用语句&gt;;｜&lt;无返回值的函数调用语句&gt;;｜&lt;赋值语句&gt;;｜&lt;读语句&gt;;｜&lt;写语句&gt;;｜&lt;空&gt;;｜&lt;返回语句&gt;;</span><br><span class="line"><span class="number">27.</span>&lt;赋值语句&gt; ::= &lt;标识符&gt;[‘[’&lt;算术表达式&gt;‘]’]＝&lt;算术表达式&gt;</span><br><span class="line"><span class="number">28.</span>&lt;条件语句&gt; ::= <span class="keyword">if</span> ‘(’&lt;布尔表达式&gt;‘)’&lt;语句&gt;［<span class="keyword">else</span>&lt;语句&gt;］</span><br><span class="line"><span class="number">29.</span>&lt;循环语句&gt; ::= <span class="keyword">while</span> ‘(’&lt;布尔表达式&gt;‘)’&lt;语句&gt;| <span class="keyword">for</span>‘(’&lt;赋值语句&gt;;&lt;布尔表达式&gt;;&lt;赋值语句&gt;‘)’&lt;语句&gt;</span><br><span class="line"><span class="number">30.</span>&lt;有返回值的函数调用语句&gt; ::= &lt;标识符&gt;‘(’&lt;值参数表&gt;‘)’</span><br><span class="line"><span class="number">31.</span>&lt;无返回值的函数调用语句&gt; ::= &lt;标识符&gt;‘(’&lt;值参数表&gt;‘)’</span><br><span class="line"><span class="number">32.</span>&lt;值参数表&gt; ::= &lt;算术表达式&gt;&#123;,&lt;算术表达式&gt;&#125;｜&lt;空&gt;</span><br><span class="line"><span class="number">33.</span>&lt;读语句&gt; ::= scanf ‘(’&lt;标识符&gt;&#123;,&lt;标识符&gt;&#125;‘)’</span><br><span class="line"><span class="number">34.</span>&lt;写语句&gt; ::= printf ‘(’&lt;字符串&gt;,&lt;算术表达式&gt;‘)’| printf ‘(’&lt;字符串&gt;‘)’| printf ‘(’&lt;算术表达式&gt;‘)’</span><br><span class="line"><span class="number">35.</span>&lt;返回语句&gt; ::= <span class="keyword">return</span>[‘(’&lt;算术表达式&gt;‘)’]</span><br><span class="line"><span class="number">36.</span>&lt;算术表达式&gt; ::= ［＋｜－］&lt;项&gt;&#123;&lt;加法运算符&gt;&lt;项&gt;&#125;</span><br><span class="line"><span class="number">37.</span>&lt;项&gt; ::= &lt;因子&gt;&#123;&lt;乘法运算符&gt;&lt;因子&gt;&#125;</span><br><span class="line"><span class="number">38.</span>&lt;因子&gt; ::= &lt;标识符&gt;｜&lt;标识符&gt;‘[’&lt;算术表达式&gt;‘]’｜&lt;无符号整数&gt;|&lt;字符&gt;｜&lt;有返回值函数调用语句&gt;|‘(’&lt;算术表达式&gt;‘)’</span><br><span class="line"><span class="number">39.</span>&lt;布尔表达式&gt; ::= &lt;布尔项&gt; &#123; ‘||’ &lt;布尔项&gt; &#125;</span><br><span class="line"><span class="number">40.</span>&lt;布尔项&gt; ::= &lt;布因子&gt;&#123; &amp;&amp; &lt;布因子&gt; &#125;</span><br><span class="line"><span class="number">41.</span>&lt;布因子&gt; ::= <span class="literal">false</span> | <span class="literal">true</span> | ! &lt;布因子&gt; | ‘(‘&lt;布尔表达式&gt;’)’ | &lt;条件因子&gt; [&lt;条件运算符&gt; &lt;条件因子&gt;]</span><br><span class="line"><span class="number">42.</span>&lt;条件因子&gt; ::= &lt;标识符&gt;[‘[’&lt;算术表达式&gt;‘]’]｜ &lt;无符号整数&gt; | &lt;字符&gt; | &lt;有返回值函数调用语句&gt;</span><br></pre></td></tr></table></figure><h1 id="二、词法分析"><a href="#二、词法分析" class="headerlink" title="二、词法分析"></a>二、词<strong><strong>法分析</strong></strong></h1><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>词法分析<code>作用</code>是将<code>字符流</code>的源代码归纳成<code>单词流</code>。通过<code>状态机</code>出几种类型的词：</p><ul><li>标识符、保留字（保留字先归类到标识符）</li><li>无符号整数</li><li>特殊符号（包括运算符、括号等等）</li><li>字符、字符串</li></ul><p>正常的<code>分析过程</code>：</p><blockquote><p><code>文法-正则表达式</code>-NFA-DFA-DFA最小化-<code>编程实现</code>（如果文法设计的好，简单，中间几步可以简略）</p></blockquote><p>状态机<code>代码实现</code>一般有两种：</p><ul><li>隐藏状态：如果状态少，可以通过代码的选择和循环结构控制状态。</li><li>双重case（本文使用）：第一重判断当前状态，第二重根据当前字符执行不同代码</li></ul><p>注意的问题有：</p><ul><li>读入缓冲：不直接操作文件指针，易于回溯与错误定位</li><li>保留字识别：先识别为标识符</li><li>带符号数处理：除了常量定义位置，表达式中都是无符号整数，带符号数用<code>0-num</code>处理</li></ul><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a><strong>正则表达式</strong></h2><p>标识符：<code>[_a-zA-Z][_a-zA-Z0-9]*</code></p><blockquote><p>三种类型：下划线、小写字母和大写字母，非数字开头</p></blockquote><p>无符号整数：<code>[1-9][0-9]*|0</code></p><blockquote><p>一位整数0-9、非0开头的多位无符号整数</p></blockquote><p>特殊符号：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> + - * /</span><br><span class="line"> &amp;&amp;  &#x27;||&#x27;  !</span><br><span class="line"> &lt; &lt;= &gt; &gt;= != ==</span><br><span class="line"> = ： , ; [ ] &#123; &#125; ( )</span><br></pre></td></tr></table></figure><p>字符：<code>&#39;[&lt;加法运算符&gt;｜&lt;乘法运算符&gt;｜&lt;字母&gt;｜&lt;数字&gt;]&#39;</code></p><p>字符串：<code>&quot;｛十进制编码为32,33,35-126的ASCII字符｝&quot;</code></p><h2 id="NFA-不确定有限自动机"><a href="#NFA-不确定有限自动机" class="headerlink" title="NFA 不确定有限自动机"></a><strong>NFA 不确定有限自动机</strong></h2><blockquote><p>Nondeterministic Finite Automata</p><p>有限自动机是一个抽象的概念，可以用两种 直观的方式—状态转换图和状态转换矩阵来 表示。有限表示状态有限。</p><p><img src="/2020/07/06/ComplierC0/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%B4%E6%98%8E/Untitled.png" alt="Untitled"></p><p>状态转换图是一个有向图，NFA中的<code>每个状态</code>对应转换图中的一个<code>节点</code>；</p><p>NFA中的每个<code>f函数</code>对应转换图中的一条<code>有向边</code>，该有向边从si 节点出发，进入sj节点，字符ch(或ε)是<code>边上的标记</code>;</p><p>NFA的<code>初态</code>是状态转换图中没有前驱的节点;</p><p><code>节点</code>一般用一个圆圈表示，</p><p><code>终态</code>节点用一个双圈表示。</p><p>举例：</p><p><img src="/2020/07/06/ComplierC0/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%B4%E6%98%8E/Untitled 1.png" alt="Untitled"></p><p><img src="/2020/07/06/ComplierC0/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%B4%E6%98%8E/Untitled 2.png" alt="Untitled"></p><p>NFA的<code>特点</code>是它的不确定性，即在当前状态下，对同一个字符ch，可能有<code>多于一个</code>的下一<code>状态转移</code>。</p></blockquote><h2 id="DFA-确定的有限自动机"><a href="#DFA-确定的有限自动机" class="headerlink" title="DFA 确定的有限自动机"></a><strong>DFA 确定的有限自动机</strong></h2><blockquote><p>DFA是NFA的一个特例，其中：</p><ul><li>没有状态具有ε状态转移(ε-transition)，即状 态转换图中没有标记ε的边；</li><li>对每一个状态s和每一个符号a，最多有一 个下一状态。</li></ul></blockquote><p>特性：对一个状态遇到一个字符，状态转移是唯一确定的</p><p>定理：NFA必有DFA与之对应。</p><h2 id="DFA-最小化"><a href="#DFA-最小化" class="headerlink" title="DFA 最小化"></a><strong>DFA 最小化</strong></h2><p>在确定DFA之后，还可以进一步简化状态数。</p><p>是唯一的。</p><blockquote><p>PPT里面有简化方法和例子。</p><p>Ch3</p></blockquote><h2 id="词法分析编程实现"><a href="#词法分析编程实现" class="headerlink" title="词法分析编程实现"></a><strong>词法分析编程实现</strong></h2><p>由于我们文法设计没有很复杂而且将不同token转化成正则表达式也不复杂，所以没有NFA-DFA最小化等步骤。</p><p>可以直接画出状态转换图，再编程实现。</p><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a><strong>数据结构</strong></h3><h3 id="1-Token"><a href="#1-Token" class="headerlink" title="1 Token"></a><strong>1 Token</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> typedef struct&#123;</span><br><span class="line">     TokenType opType;</span><br><span class="line">     char * value;</span><br><span class="line"> &#125;Token;</span><br></pre></td></tr></table></figure><h3 id="2-TokenType"><a href="#2-TokenType" class="headerlink" title="2 TokenType"></a><strong>2 TokenType</strong></h3><p>枚举类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> typedef enum &#123;</span><br><span class="line">     //关键字：</span><br><span class="line">     CHAR, CONST, ELSE, FALSE, FOR,              //0-4</span><br><span class="line">     IF, INT, MAIN, PRINTF, RETURN,              //5-9</span><br><span class="line">     SCANF, TRUE, VOID, WHILE,                   //10-13</span><br><span class="line">     NUM, IDEN, LETTER, STRING,                  //14-17:数字、标识符、字符、字符串</span><br><span class="line">     PLUS, MINU, MULT, DIV,                      //18-21:+ - * /</span><br><span class="line">     AND, OR, NOT,                               //22-24:&amp;&amp; || !</span><br><span class="line">     LSS, LEQ, GRE, GEQ, NEQ, EQL,               //25-30关系运算符: &lt; &lt;= &gt; &gt;= != ==</span><br><span class="line">     ASSIGN, COLON, COMMA, SEMICOLON,            //31-34: =  :  ,  ;</span><br><span class="line">     LBRACE, RBRACE, LBRACKET, RBRACKET,         //35-38:&#123; &#125; [ ]</span><br><span class="line">     LPARENTHES, RPARENTHES,                     //39-40:( )</span><br><span class="line"> &#125;TokenType;</span><br></pre></td></tr></table></figure><h3 id="3-保留字表"><a href="#3-保留字表" class="headerlink" title="3 保留字表"></a><strong>3 保留字表</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> const char* reservedWords[] = &#123;</span><br><span class="line">     &quot;case&quot;, &quot;char&quot;, &quot;const&quot;, &quot;default&quot;, &quot;else&quot;,</span><br><span class="line">     &quot;false&quot;, &quot;for&quot;, &quot;if&quot;, &quot;int&quot;, &quot;main&quot;,</span><br><span class="line">     &quot;printf&quot;, &quot;return&quot;, &quot;scanf&quot;, &quot;switch&quot;, &quot;true&quot;,</span><br><span class="line">     &quot;void&quot;, &quot;while&quot;</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure><h3 id="4-状态"><a href="#4-状态" class="headerlink" title="4 状态"></a><strong>4 状态</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> typedef enum &#123;</span><br><span class="line">     STATE_START, STATE_NUM, STATE_ID, STATE_CHAR, STATE_STRING, STATE_DONE</span><br><span class="line"> &#125;StateType;</span><br></pre></td></tr></table></figure><p>用Token表示每一个词（词法分析的一次处理结果），里面包括两部分，tokentype表示类型；用char *表示一些有值的类型（数字、字符串）。</p><h3 id="DFA编程思想"><a href="#DFA编程思想" class="headerlink" title="DFA编程思想"></a><strong>DFA编程思想</strong></h3><blockquote><p>来自Louden书《编译原理与实践》的思路</p></blockquote><h3 id="1-通过代码位置表示隐含状态"><a href="#1-通过代码位置表示隐含状态" class="headerlink" title="1 通过代码位置表示隐含状态"></a><strong>1 通过代码位置表示隐含状态</strong></h3><p>if判断不同符号进入不同分支；循环表示不断读入当前状态的循环字符。</p><blockquote><p>注意<code>advance the input</code>表示读入一个符号</p><p><img src="/2020/07/06/ComplierC0/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%B4%E6%98%8E/Untitled 3.png" alt="Untitled"></p><p><img src="/2020/07/06/ComplierC0/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%B4%E6%98%8E/Untitled 4.png" alt="Untitled"></p></blockquote><h3 id="2-双重case"><a href="#2-双重case" class="headerlink" title="2 双重case"></a><strong>2 双重case</strong></h3><blockquote><p>实际用的就是这个</p></blockquote><p>专门设置一个变量表示当前状态，循环判断非end状态，内部使用双重case语句，第一重测试状态，第二重测试当前字符（进行状态转换）。</p><p><img src="/2020/07/06/ComplierC0/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%B4%E6%98%8E/Untitled 5.png" alt="Untitled"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从文件中逐步读入字符，输出token</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getNextToken</span><span class="params">()</span> </span>&#123;</span><br><span class="line">string tmpstr;</span><br><span class="line"><span class="type">char</span> ch;</span><br><span class="line">StateType state = STATE_START;</span><br><span class="line">g_lexBegin = g_forward;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (STATE_DONE != state) &#123;</span><br><span class="line">    ch = <span class="built_in">getNextChar</span>();</span><br><span class="line">    <span class="keyword">if</span> (EOF == ch) &#123;</span><br><span class="line">        g_token.opType = END;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (state)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> STATE_START: &#123;      <span class="comment">/////////////////////start</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&#x27; &#x27;</span> == ch || <span class="string">&#x27;\\t&#x27;</span> == ch || <span class="string">&#x27;\\n&#x27;</span> == ch) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">isdigit</span>(ch)) &#123;                  <span class="comment">//digital</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&#x27;0&#x27;</span> == ch) &#123;</span><br><span class="line">                state = STATE_DONE;</span><br><span class="line">                tmpstr += ch;</span><br><span class="line">                g_token.opType = TokenType::NUM;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                state = STATE_NUM;</span><br><span class="line">                tmpstr += ch;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">isalpha</span>(ch) || <span class="string">&#x27;_&#x27;</span> == ch) &#123;</span><br><span class="line">            state = STATE_ID;    <span class="comment">//标识符</span></span><br><span class="line">            tmpstr += ch;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&#x27;\\&#x27;</span><span class="string">&#x27; == ch) &#123;              //字符</span></span><br><span class="line"><span class="string">            state = STATE_CHAR;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">        else if (&#x27;</span><span class="string">&quot;&#x27; == ch) &#123;               //字符串</span></span><br><span class="line"><span class="string">            state = STATE_STRING;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">        else &#123;                              //一个或两个字符就到终态</span></span><br><span class="line"><span class="string">            state = STATE_DONE;</span></span><br><span class="line"><span class="string">            tmpstr += ch;</span></span><br><span class="line"><span class="string">            switch (ch) &#123;</span></span><br><span class="line"><span class="string">            case &#x27;+&#x27;:                       // +</span></span><br><span class="line"><span class="string">                g_token.opType = TokenType::PLUS;</span></span><br><span class="line"><span class="string">                break;</span></span><br><span class="line"><span class="string">            case &#x27;-&#x27;:                       // -</span></span><br><span class="line"><span class="string">                g_token.opType = TokenType::MINU;</span></span><br><span class="line"><span class="string">                break;</span></span><br><span class="line"><span class="string">            case &#x27;*&#x27;:                       // *</span></span><br><span class="line"><span class="string">                g_token.opType = TokenType::MULT;</span></span><br><span class="line"><span class="string">                break;</span></span><br><span class="line"><span class="string">            case &#x27;/&#x27;:                       // /</span></span><br><span class="line"><span class="string">                g_token.opType = TokenType::DIV;</span></span><br><span class="line"><span class="string">                break;</span></span><br><span class="line"><span class="string">            case &#x27;&amp;&#x27;:                       // &amp;&amp;</span></span><br><span class="line"><span class="string">                ch = getNextChar();</span></span><br><span class="line"><span class="string">                if (&#x27;&amp;&#x27; == ch) &#123;</span></span><br><span class="line"><span class="string">                    g_token.opType = TokenType::AND;</span></span><br><span class="line"><span class="string">                    tmpstr += ch;</span></span><br><span class="line"><span class="string">                &#125;</span></span><br><span class="line"><span class="string">                else &#123;</span></span><br><span class="line"><span class="string">                    cout &lt;&lt; &quot;</span>lex error: &amp;&amp;\\n<span class="string">&quot;;</span></span><br><span class="line"><span class="string">                &#125;</span></span><br><span class="line"><span class="string">                break;</span></span><br><span class="line"><span class="string">            case &#x27;|&#x27;:                       //||</span></span><br><span class="line"><span class="string">                ch = getNextChar();</span></span><br><span class="line"><span class="string">                if (&#x27;|&#x27; == ch) &#123;</span></span><br><span class="line"><span class="string">                    g_token.opType = TokenType::OR;</span></span><br><span class="line"><span class="string">                    tmpstr += ch;</span></span><br><span class="line"><span class="string">                &#125;</span></span><br><span class="line"><span class="string">                else &#123;</span></span><br><span class="line"><span class="string">                    cout &lt;&lt; &quot;</span>lex error: ||\\n<span class="string">&quot;;</span></span><br><span class="line"><span class="string">                &#125;</span></span><br><span class="line"><span class="string">                break;</span></span><br><span class="line"><span class="string">            case &#x27;!&#x27;:                       // ! !=</span></span><br><span class="line"><span class="string">                ch = getNextChar();</span></span><br><span class="line"><span class="string">                if (&#x27;=&#x27; == ch) &#123;</span></span><br><span class="line"><span class="string">                    g_token.opType = TokenType::NEQ;</span></span><br><span class="line"><span class="string">                    tmpstr += ch;</span></span><br><span class="line"><span class="string">                &#125;</span></span><br><span class="line"><span class="string">                else &#123;</span></span><br><span class="line"><span class="string">                    backSpace();</span></span><br><span class="line"><span class="string">                    g_token.opType = TokenType::NOT;</span></span><br><span class="line"><span class="string">                &#125;</span></span><br><span class="line"><span class="string">                break;</span></span><br><span class="line"><span class="string">            case &#x27;&lt;&#x27;:                       // &lt; &lt;=</span></span><br><span class="line"><span class="string">                ch = getNextChar();</span></span><br><span class="line"><span class="string">                if (&#x27;=&#x27; == ch) &#123;</span></span><br><span class="line"><span class="string">                    g_token.opType = TokenType::LEQ;</span></span><br><span class="line"><span class="string">                    tmpstr += ch;</span></span><br><span class="line"><span class="string">                &#125;</span></span><br><span class="line"><span class="string">                else &#123;</span></span><br><span class="line"><span class="string">                    backSpace();</span></span><br><span class="line"><span class="string">                    g_token.opType = TokenType::LSS;</span></span><br><span class="line"><span class="string">                &#125;</span></span><br><span class="line"><span class="string">                break;</span></span><br><span class="line"><span class="string">            case &#x27;&gt;&#x27;:                       // &gt; &gt;=</span></span><br><span class="line"><span class="string">                ch = getNextChar();</span></span><br><span class="line"><span class="string">                if (&#x27;=&#x27; == ch) &#123;</span></span><br><span class="line"><span class="string">                    g_token.opType = TokenType::GEQ;</span></span><br><span class="line"><span class="string">                    tmpstr += ch;</span></span><br><span class="line"><span class="string">                &#125;</span></span><br><span class="line"><span class="string">                else &#123;</span></span><br><span class="line"><span class="string">                    backSpace();</span></span><br><span class="line"><span class="string">                    g_token.opType = TokenType::GRE;</span></span><br><span class="line"><span class="string">                &#125;</span></span><br><span class="line"><span class="string">                break;</span></span><br><span class="line"><span class="string">            case &#x27;=&#x27;:                       // = ==</span></span><br><span class="line"><span class="string">                ch = getNextChar();</span></span><br><span class="line"><span class="string">                if (&#x27;=&#x27; == ch) &#123;</span></span><br><span class="line"><span class="string">                    g_token.opType = TokenType::EQL;</span></span><br><span class="line"><span class="string">                    tmpstr += ch;</span></span><br><span class="line"><span class="string">                &#125;</span></span><br><span class="line"><span class="string">                else &#123;</span></span><br><span class="line"><span class="string">                    backSpace();</span></span><br><span class="line"><span class="string">                    g_token.opType = TokenType::ASSIGN;</span></span><br><span class="line"><span class="string">                &#125;</span></span><br><span class="line"><span class="string">                break;</span></span><br><span class="line"><span class="string">            case &#x27;,&#x27;:</span></span><br><span class="line"><span class="string">                g_token.opType = TokenType::COMMA;</span></span><br><span class="line"><span class="string">                break;</span></span><br><span class="line"><span class="string">            case &#x27;;&#x27;:</span></span><br><span class="line"><span class="string">                g_token.opType = TokenType::SEMICOLON;</span></span><br><span class="line"><span class="string">                break;</span></span><br><span class="line"><span class="string">            case &#x27;&#123;&#x27;:</span></span><br><span class="line"><span class="string">                g_token.opType = TokenType::LBRACE;</span></span><br><span class="line"><span class="string">                break;</span></span><br><span class="line"><span class="string">            case &#x27;&#125;&#x27;:</span></span><br><span class="line"><span class="string">                g_token.opType = TokenType::RBRACE;</span></span><br><span class="line"><span class="string">                break;</span></span><br><span class="line"><span class="string">            case &#x27;[&#x27;:</span></span><br><span class="line"><span class="string">                g_token.opType = TokenType::LBRACKET;</span></span><br><span class="line"><span class="string">                break;</span></span><br><span class="line"><span class="string">            case &#x27;]&#x27;:</span></span><br><span class="line"><span class="string">                g_token.opType = TokenType::RBRACKET;</span></span><br><span class="line"><span class="string">                break;</span></span><br><span class="line"><span class="string">            case &#x27;(&#x27;:</span></span><br><span class="line"><span class="string">                g_token.opType = TokenType::LPARENTHES;</span></span><br><span class="line"><span class="string">                break;</span></span><br><span class="line"><span class="string">            case &#x27;)&#x27;:</span></span><br><span class="line"><span class="string">                g_token.opType = TokenType::RPARENTHES;</span></span><br><span class="line"><span class="string">                break;</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">        break;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    case STATE_CHAR:</span></span><br><span class="line"><span class="string">        if (isdigit(ch) || isalpha(ch) || &#x27;+&#x27; == ch || &#x27;-&#x27; == ch || &#x27;*&#x27; == ch || &#x27;/&#x27; == ch) &#123;</span></span><br><span class="line"><span class="string">            tmpstr += ch;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">        else &#123;</span></span><br><span class="line"><span class="string">            cout &lt;&lt; &quot;</span>lex error:illegal character\\n<span class="string">&quot;;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        ch = getNextChar();</span></span><br><span class="line"><span class="string">        state = STATE_DONE;</span></span><br><span class="line"><span class="string">        // 有一处bug，下面这句忘记加了。。。</span></span><br><span class="line"><span class="string">        g_token.opType = TokenType::LETTER;</span></span><br><span class="line"><span class="string">        if (&#x27;\\&#x27;&#x27; != ch) &#123;</span></span><br><span class="line"><span class="string">            backSpace();</span></span><br><span class="line"><span class="string">            cout &lt;&lt; &quot;</span>lex error:<span class="keyword">not</span> <span class="string">&#x27;\\n&quot;;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        break;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    case STATE_ID:</span></span><br><span class="line"><span class="string">        if (isdigit(ch) || isalpha(ch) || &#x27;</span>_<span class="number">&#x27;</span> == ch) &#123;</span><br><span class="line">            tmpstr += ch;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            state = STATE_DONE;</span><br><span class="line">            <span class="built_in">backSpace</span>();</span><br><span class="line">            g_token.opType = TokenType::IDEN;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> STATE_NUM:</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">            tmpstr += ch;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            state = STATE_DONE;</span><br><span class="line">            <span class="built_in">backSpace</span>();</span><br><span class="line">            g_token.opType = TokenType::NUM;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> STATE_STRING:</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&#x27;&quot;&#x27;</span> == ch) &#123;</span><br><span class="line">            state = STATE_DONE;</span><br><span class="line">            g_token.opType = TokenType::STRING;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">32</span> &lt;= ch &amp;&amp; <span class="number">126</span> &gt;= ch) &#123;</span><br><span class="line">            tmpstr += ch;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;lex error: illegal character in string\\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-转换表"><a href="#3-转换表" class="headerlink" title="3 转换表"></a><strong>3 转换表</strong></h3><p>代码简单，易维护，但是表可能很大，不推荐</p><p><img src="/2020/07/06/ComplierC0/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%B4%E6%98%8E/Untitled 6.png" alt="Untitled"></p><p><img src="/2020/07/06/ComplierC0/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%B4%E6%98%8E/Untitled 7.png" alt="Untitled"></p><h2 id="注意问题（重点）"><a href="#注意问题（重点）" class="headerlink" title="注意问题（重点）"></a><strong>注意问题（重点）</strong></h2><h3 id="1、读入缓冲"><a href="#1、读入缓冲" class="headerlink" title="1、读入缓冲"></a><strong>1、读入缓冲</strong></h3><p>缓冲的意思是，不是直接通过指针操作文件，而是，先读进来一个数组的数据，在数组中操作；</p><p>便于定位错误的位置；简便</p><blockquote><p>然后有单缓冲和双缓冲的区别；</p><p>而<code>北航</code>是多了一个backup数组；</p><p><code>louden书</code>中的例子，也是有一个缓冲数组lineBuf</p></blockquote><h3 id="2、保留字的识别"><a href="#2、保留字的识别" class="headerlink" title="2、保留字的识别"></a><strong>2、保留字的识别</strong></h3><p>将保留字也先看做标识符，再识别保留字</p><blockquote><p>匹配保留字表，字典序查询（线性低效）</p></blockquote><h3 id="3、带符号数处理"><a href="#3、带符号数处理" class="headerlink" title="3、带符号数处理"></a><strong>3、带符号数处理</strong></h3><blockquote><p>+1+1</p><p><code>最长字串原则</code>：if32i 这种字符串时，我们将对整个字符串进行匹配，而不是匹配到if就返回类型IF。简单说是往最长的结果匹配。</p><p>但我们理解的：第二个 +1和第一个+1是有区别的，如果词法阶段就有带符号数，那么按照最长字符串原则会得到两个token，两个<code>+1</code></p><p>但实际我们想要的可能是：+1，+，1</p></blockquote><p>通过总结带符号数的规律，发现：其中要么带符号数要么在开头，要么有括号；其他情况数字都是无符号的</p><p>所以，总结来说，我们可以把这个符号当做<code>表达式来处理</code>，前面补一个0；</p><h3 id="4、冲突解决与错误处理（略）"><a href="#4、冲突解决与错误处理（略）" class="headerlink" title="4、冲突解决与错误处理（略）"></a><strong>4、冲突解决与错误处理（略）</strong></h3><h1 id="三、语法分析"><a href="#三、语法分析" class="headerlink" title="三、语法分析"></a>三、<strong><strong>语法分析</strong></strong></h1><h2 id="摘要-1"><a href="#摘要-1" class="headerlink" title="摘要"></a>摘要</h2><p>语法分析的作用是<code>单词归纳成句子</code>的序列；需要<code>生成抽象语法树（左孩子右兄弟）</code>。</p><blockquote><p>到生成AST这里算前端，<code>前端处理不同语言，后端统一处理AST</code></p></blockquote><p>工作流程分为两个部分：</p><p>1、先理论设计AST（设计分成<code>四个部分</code>程序、语句、算术表达式、布尔表达式）；程序实现构造AST（树的结构是什么样，存储哪些信息）</p><p>2、对于<code>语法（文法）</code>上，计划采用<code>递归下降</code>分析法（手写实现简单），文法最好满足<code>LL(1)文法</code>（大致理解是看到下一个token就知道用哪一个推导式）</p><blockquote><p>需要大量的设计和验证（这里废了很多功夫）</p></blockquote><p>在实现时，最好将文法转化为<code>EBNF范式</code>便于实现；</p><p><code>难点</code>：</p><ul><li><p>函数定义和变量定义的回溯保留</p></li><li><p>算术表达式的设计</p></li><li><p>布尔表达式的设计</p></li><li><p>二义性的解决（以if-else为例：就近原则；布尔表达式中的算术表达式无法使用括号嵌套）</p></li><li><p>语法分析是做什么？（通俗理解）</p><p>  词法是字符序列转成单词序列；（看一个单词是否合法）</p><p>  语法分析是<code>单词转成句子</code>的序列（看一个句子是否合法）。需要<code>生成抽象语法树</code></p><p>  <img src="/2020/07/06/ComplierC0/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%B4%E6%98%8E/Untitled 8.png" alt="Untitled"></p></li><li><p>LL分析法，LR分析法</p><p>  LL(k)文法：通过从左往右超前查看k个字符决定采用哪一个产生式。（分支预测）</p><p>  名字中第一个L表示从左往右扫描字符串，；第二个L表示最左推导，对于每一个产生式都要从左往右开始分析即可。</p><p>  提取左公因式的方法，转化为LL(k)的文法。</p></li><li><p>递归子程序（递归下降法）</p><p>  好用程序实现，对语言所用的文法有一些限制（MS官方的C#编译器就是用这种方法）</p></li></ul><h2 id="抽象语法树-AST-的理论设计"><a href="#抽象语法树-AST-的理论设计" class="headerlink" title="抽象语法树 AST 的理论设计"></a><strong>抽象语法树 AST 的理论设计</strong></h2><p>特点：</p><ul><li><code>不依赖于具体的文法</code>（语法分析方式）：无论是自上而下或自下而上的语法分析，都要求在语法分析时候，构造出相同的语法树，这样可以给编译器后端提 供了清晰，统一的接口。</li><li>不依赖于语言的细节：gcc可以编译多种语言，<code>前端处理不同语言，后端统一处理AST</code></li></ul><p>我定义的：（<code>左孩子右兄弟</code>），有四块内容</p><p>1、整体结构：</p><p><img src="/2020/07/06/ComplierC0/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%B4%E6%98%8E/Untitled 9.png" alt="Untitled"></p><p>2、语句</p><p><img src="/2020/07/06/ComplierC0/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%B4%E6%98%8E/Untitled 10.png" alt="Untitled"></p><p>3、算术表达式：（算是较为完整）</p><p>支持<code>加减乘除</code>、<code>括号</code>，<code>数组下标引用</code>、有返回值函数调用；</p><p>对象可以是<code>字面量</code>和<code>变量</code>的<code>字符</code>和<code>无符号整数</code>类型</p><p><img src="/2020/07/06/ComplierC0/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%B4%E6%98%8E/Untitled 11.png" alt="Untitled"></p><p>4、布尔表达式：</p><p>支持与或非、括号、条件运算符（大于、小于等的比较运算）</p><p><img src="/2020/07/06/ComplierC0/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%B4%E6%98%8E/Untitled 12.png" alt="Untitled"></p><h2 id="LL-1-文法的理论定义"><a href="#LL-1-文法的理论定义" class="headerlink" title="LL(1)文法的理论定义"></a><strong>LL(1)文法的理论定义</strong></h2><h3 id="FIRST集合"><a href="#FIRST集合" class="headerlink" title="FIRST集合"></a><strong>FIRST集合</strong></h3><p>对于推导式：First(S)就是S能推导出来的第一个终结符</p><p><img src="/2020/07/06/ComplierC0/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%B4%E6%98%8E/Untitled 13.png" alt="Untitled"></p><h3 id="FOLLOW集合"><a href="#FOLLOW集合" class="headerlink" title="FOLLOW集合"></a><strong>FOLLOW集合</strong></h3><p>可紧跟在非终结符A后的所有终结符之集</p><p>D背后紧跟着R，R的第一个是d</p><p><img src="/2020/07/06/ComplierC0/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%B4%E6%98%8E/Untitled 14.png" alt="Untitled"></p><h3 id="LL-1-文法"><a href="#LL-1-文法" class="headerlink" title="LL(1)文法"></a><strong>LL(1)文法</strong></h3><p>判断文法为LL(1)文法的条件：</p><p>（1）文法不含左递归</p><p>（2）根据产生式的首字符进行判断（也就是通过第一个字符就能判断使用哪个产生式）</p><p><img src="/2020/07/06/ComplierC0/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%B4%E6%98%8E/Untitled 15.png" alt="Untitled"></p><h2 id="编程：递归向下分析法（使用递归子程序法）"><a href="#编程：递归向下分析法（使用递归子程序法）" class="headerlink" title="编程：递归向下分析法（使用递归子程序法）"></a>编程：<strong>递归向下分析法（使用递归子程序法）</strong></h2><blockquote><p>设计好了文法，如何编程实现？</p><p>将文法表示成<code>EBNF范式</code>的形式更好实现！</p></blockquote><p>对于文法的<code>每个非终结符</code>,根据其各候选式的结构,为其建立一个<code>递归的子程序(函数)</code>,用于识别该非终结符所表示的语法范畴.</p><p><img src="/2020/07/06/ComplierC0/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%B4%E6%98%8E/Untitled 16.png" alt="Untitled"></p><p>match：以其实参与当前正扫描的符号进行匹配,若成功则返回1,否则返回0;</p><p>advance：读下一单词的函数</p><p>term：与非终结符T相对应的子程序.</p><h3 id="1、AST的程序表示"><a href="#1、AST的程序表示" class="headerlink" title="1、AST的程序表示"></a><strong>1、AST的程序表示</strong></h3><p>理解了理论定义后，代码方面会简单很多。</p><p>1、左孩子右兄弟，孩子可能不止一个</p><p>2、大致用哪些数据结构存储了哪些信息</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AST 的节点：左孩子右兄弟的树形结构；但表达式部分 又是二叉树结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">TreeNode</span>* child[MAX_TREENODE_CHILD_NUM];     <span class="comment">// 左孩子，最多三个，通常只有一个，特定语句有多个</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">TreeNode</span>* sibling;                           <span class="comment">// 右兄弟</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 节点类型</span></span><br><span class="line">    NodeKind nodekind;                              </span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        DecKind dec;</span><br><span class="line">        StmtKind stmt;</span><br><span class="line">        ExpKind exp;</span><br><span class="line">        BoolExpKind bexp;</span><br><span class="line">    &#125;kind;                                          <span class="comment">// 节点具体类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 节点属性</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        TokenType op;                                   <span class="comment">// 操作类型：通常是表达式中</span></span><br><span class="line">        <span class="type">int</span> val;                                        <span class="comment">// NUM的值：exp中 char也是存这个</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span> cval;                             <span class="comment">// Char 型 值：常量定义</span></span><br><span class="line">        <span class="type">char</span>* name;                                     <span class="comment">// Id 的值，也可以是函数名，Str的值</span></span><br><span class="line">        <span class="type">bool</span> bval;                                      <span class="comment">// bool 常量</span></span><br><span class="line">        <span class="type">char</span>* str;                                      <span class="comment">// String 类型</span></span><br><span class="line">    &#125;attr;                                          </span><br><span class="line">    <span class="type">int</span> vec;                                        <span class="comment">// 数组长度，不是数组就是-1 ； (变量定义阶段设置)</span></span><br><span class="line">    Type type;                                      <span class="comment">// 常、变量定义 ，类型说明 和 表达式类型检查</span></span><br><span class="line">                                                    <span class="comment">// 函数信息：返回类型和参数表；也可以链接到符号表中</span></span><br><span class="line">    FuncInfo* pfinfo;                               <span class="comment">// 函数定义阶段设置：函数信息； 或者是函数调用阶段的参数表</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转化成IR中用到</span></span><br><span class="line">    <span class="type">char</span>* place;</span><br><span class="line">    <span class="type">int</span> TC, FC;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 错误处理</span></span><br><span class="line">    <span class="type">int</span> lineno;                                     <span class="comment">// 错误报告行号</span></span><br><span class="line">    <span class="type">bool</span> error;</span><br><span class="line"></span><br><span class="line">&#125;TreeNode;</span><br></pre></td></tr></table></figure><h3 id="2、ENBF范式代码实现"><a href="#2、ENBF范式代码实现" class="headerlink" title="2、ENBF范式代码实现"></a><strong>2、ENBF范式代码实现</strong></h3><p>必须出现直接匹配；</p><p>可选用if判断</p><p>多次用循环判断</p><p><img src="/2020/07/06/ComplierC0/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%B4%E6%98%8E/Untitled 17.png" alt="Untitled"></p><h2 id="注意问题（这里涉及文法设计）"><a href="#注意问题（这里涉及文法设计）" class="headerlink" title="注意问题（这里涉及文法设计）"></a><strong>注意问题（这里涉及文法设计）</strong></h2><h3 id="1、避免回溯（提高效率）"><a href="#1、避免回溯（提高效率）" class="headerlink" title="1、避免回溯（提高效率）"></a><strong>1、避免回溯（提高效率）</strong></h3><p>解决：改造文法</p><p>有些无法避免，也没必要。（可以部分地方多读几个，类似LL（k））</p><p>如函数定义时</p><blockquote><p>我的程序：</p><p>1）判断变量定义还是函数，需要提前看两个token，看是不是括号</p><p>2）判断是不是main函数，需要提前一个token</p></blockquote><h3 id="2、二义性"><a href="#2、二义性" class="headerlink" title="2、二义性"></a>2<strong>、二义性</strong></h3><ul><li>if else</li></ul><blockquote><p>规定原则：优先匹配近的</p></blockquote><ul><li>布尔表达式中的算术表达式</li></ul><blockquote><p>因为算术表达式设计得齐全；在布尔表达式部分内部的算术表达式就不支持括号了；（这是一个缺陷）</p></blockquote><h3 id="3、消除左递归（避免死循环）（略）"><a href="#3、消除左递归（避免死循环）（略）" class="headerlink" title="3、消除左递归（避免死循环）（略）"></a>3<strong>、消除左递归（避免死循环）（略）</strong></h3><p>包含<code>直接左递归</code>和<code>间接左递归</code>两种</p><p>解决：改造文法或者EBNF范式</p><p><img src="/2020/07/06/ComplierC0/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%B4%E6%98%8E/Untitled 18.png" alt="Untitled"></p><p>代入消除间接左递归：</p><p><img src="/2020/07/06/ComplierC0/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%B4%E6%98%8E/Untitled 19.png" alt="Untitled"></p><h3 id="4、提取公因子（略）"><a href="#4、提取公因子（略）" class="headerlink" title="4、提取公因子（略）"></a>4<strong><strong>、提取公因子（略）</strong></strong></h3><p><img src="/2020/07/06/ComplierC0/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%B4%E6%98%8E/Untitled 20.png" alt="Untitled"></p><h1 id="四、语义分析"><a href="#四、语义分析" class="headerlink" title="四、语义分析"></a>四、语义分析</h1><h2 id="摘要-2"><a href="#摘要-2" class="headerlink" title="摘要"></a>摘要</h2><p>功能是语句的语义是否有明确的含义。（比如语法检查每个token类型是否匹配即可；这里需要检查标识符的类型是否正确）</p><p>工作分为两个部分，<code>构造符号表</code>和<code>语义检查</code>。（一次遍历）</p><p>1、定义符号表（多级hash链表）；符号表是语义检查的基础，所以在常量、变量、函数定义部分先构建符号表（往符号表中添加符号）</p><blockquote><p>其实符号表在背后的生成四元式（插入临时变量）和生成汇编代码都有用（在符号表中保存<code>内存的地址</code>和<code>寄存器位置</code>）</p></blockquote><p>2、语义检查是在<code>表达式</code>、和<code>各种语句</code>中<code>检查标识符</code>是否有明确的含义。（查找符号表）</p><p><code>类型检查</code>和<code>定义检查</code>是主要内容</p><blockquote><p>即用到标识符时类型是否正确；标识符是否定义</p></blockquote><p>难点：</p><ul><li>符号表的结构：多级hash链表</li><li>同名标识符就近原则</li></ul><blockquote><p>一般的编译器：词法分析、语法分析、语义分析是同时进行的，一遍<br>我的：生成AST之后，再遍历AST，构建符号表，进行语义分析（事实上技术上的难度没什么差别，都很简单，做的事情基本一样）</p></blockquote><h2 id="符号表"><a href="#符号表" class="headerlink" title="符号表"></a>符号表</h2><p>符号表的结构选择：<code>分级hash链表</code>（名字作为键）；分级表示<code>不同作用域</code>（全局或者函数内部）；</p><p>因此可以实现同名标识符（选择作用域最近）。不允许使用同名函数、标识符和函数同名。</p><p><img src="/2020/07/06/ComplierC0/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%B4%E6%98%8E/Untitled 21.png" alt="Untitled"></p><h3 id="程序实现"><a href="#程序实现" class="headerlink" title="程序实现"></a>程序实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SYMBOL_TABLE_SIZE 211</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> <span class="title class_">IDType</span> &#123;</span><br><span class="line">    Const_ID, Var_ID, Para_ID, Func_ID</span><br><span class="line">&#125;IDType;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 符号表中的每一项</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Symbol</span> &#123;</span><br><span class="line">    <span class="type">char</span>* name;<span class="comment">// 标识符名字</span></span><br><span class="line">    IDType type;<span class="comment">// ID类型： const，var，para，function</span></span><br><span class="line">    Type valueType;<span class="comment">// ID的类型值：常变量的类型、参数类型、函数返回类型</span></span><br><span class="line">    <span class="type">int</span> value;<span class="comment">// 常量定义值只有常数定义才会传入</span></span><br><span class="line">    <span class="type">int</span> adress;<span class="comment">// 内存地址</span></span><br><span class="line">    <span class="type">int</span> vec;<span class="comment">// 数组大小，不是数组为-1；只有定义数组时，才会传入</span></span><br><span class="line">    FuncInfo* pfinfo;<span class="comment">// 函数信息，AST中已有，拷贝即可；  只有函数定义是，才会传进，否则NULL</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Symbol</span>* next;<span class="comment">// 有相同hash值时，下一条</span></span><br><span class="line">&#125;Symbol, * SymbolList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">SymTab</span> &#123;</span><br><span class="line">    SymTab* next;<span class="comment">// 多张表；指向下一张表</span></span><br><span class="line">    <span class="type">char</span>* fname;</span><br><span class="line">    SymbolList hashTable[SYMBOL_TABLE_SIZE];</span><br><span class="line">&#125;SymTab;</span><br></pre></td></tr></table></figure><blockquote><p>一些字段的说明：<br>1、标识符名字；<br>2、标识符有四种：常量、变量、函数参数、函数<br>3、标识符的类型：空、整形、字符、错误<br>4、<code>内存地址</code>：这个很关键，有两个变量来维护；一个是全局地址；一个是函数局部地址（函数栈帧相对地址）<br>5、数组大小<br>6、函数定义的信息：返回值，参数个数，各个参数<br>7、作为链表节点，指向下一个节点</p></blockquote><p>以递归地方式遍历AST，构造符号表。</p><p>每个函数一张表：第一张表示全局表（保存全局变量和函数名）；后面的是函数表，新的函数始终保持在第二张表</p><p>相关操作：</p><ul><li>初始化：新增一张表，输入为表名</li><li>增：向对应符号表插入一个符号（符号可以是变量、常量、函数参数、函数、标识符）；还可以插入临时变量（计算表达式时使用）</li><li>查：先查当前函数表（在第二张），再查全局表（第一张）</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化一张 单表；每个函数一张表、全局一张表</span></span><br><span class="line"><span class="function">SymTab* <span class="title">initSimpleSymTable</span><span class="params">(<span class="type">char</span>* name)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回是否插入成功，如空间不足、重复定义 ； 后面并没有用到返回值，内部直接错误处理</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">insert_SymTab</span><span class="params">(<span class="type">bool</span> isGlobal, <span class="type">char</span>* name, IDType type, Type valuetype, <span class="type">int</span> value, <span class="type">int</span> vec = <span class="number">-1</span>, FuncInfo* p = <span class="literal">NULL</span>)</span></span>;</span><br><span class="line"><span class="comment">// value字段，只有常量定义才会赋初值</span></span><br><span class="line"><span class="comment">// adress字段由文件内部静态变量控制，一旦重新函数定义，指针变0，重新计算相对地址</span></span><br><span class="line"><span class="comment">// 数组标志默认-1；只有数组(变量定义)定义时才会是 其他值</span></span><br><span class="line"><span class="comment">// 函数信息默认为空，只有函数定义时，才会赋值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入临时变量：变量名、isreg、地址（生成四元式阶段才会使用）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertTempVar2SymTab</span><span class="params">(<span class="type">char</span>* name)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 返回符号节点指针、未定义返回空指针；</span></span></span><br><span class="line"><span class="function">Symbol* <span class="title">lookUp_SymTab</span><span class="params">(<span class="type">char</span>* name)</span></span>;</span><br><span class="line"><span class="comment">// 遵循原则：先查子表，再差全局表（作用域最近的）</span></span><br></pre></td></tr></table></figure><h2 id="语义检查"><a href="#语义检查" class="headerlink" title="语义检查"></a>语义检查</h2><p>主要工作是对<code>标识符</code>的<code>类型检查</code>和<code>定义检查</code>（操作类型是否匹配、前面是否定义了函数或标识符，传参的个数和类型是否对得上）</p><p>还是<code>递归遍历</code>AST</p><p>要检查的地方：</p><p>1、算术表达式中：</p><ul><li>常量：跳过</li><li>标识符：未定义使用；是数组不进行下标运算</li><li>函数调用：函数未定义使用，不是有返回值调用，参数个是否匹配</li><li>数组引用：未定义；非数组进行下标运算；</li></ul><blockquote><p>需考虑<code>运算符两侧操作数是否合法</code>，比如int和bool类型相加，由于只有char和int，<code>暂不考虑</code></p><p>表达式都看作是int型运算，只有语句中需要时根据左值类型进行转换</p></blockquote><hr><p>2、布尔表达式中：</p><ul><li>常量：不检查</li><li>算术表达式：递归调用</li></ul><hr><p>3、语句中：</p><ul><li>赋值语句：标识符未定义、检查是否变量（常量不能赋值）、不是数组进行下标运算、是数组不进行下标运算</li><li>函数调用语句：函数未定义、是否是函数、参数是否匹配（个数和类型）<code>（函数传参有可能传表达式，所以需要验证）</code></li><li>读语句：标识符未定义、不能是常量</li><li>写语句：占用符与表达式不匹配（是否有%d，%c）</li></ul><p><img src="/2020/07/06/ComplierC0/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%B4%E6%98%8E/Untitled 22.png" alt="Untitled"></p><h1 id="五、中间代码（四元式）生成"><a href="#五、中间代码（四元式）生成" class="headerlink" title="五、中间代码（四元式）生成"></a>五、中间代码（四元式）生成</h1><h2 id="摘要-3"><a href="#摘要-3" class="headerlink" title="摘要"></a>摘要</h2><p>功能：将AST（四种类型）转化成四元式（一个操作符，最多三个操作数）；便于代码优化</p><p>难点：</p><ul><li>大部分操作较为简单</li><li>布尔操作符比较复杂：1、if和while语句的程序块放置位置。2、有短路现象、需要拉链回填（需要提前结束，还要设置各种跳转地址、标签）</li></ul><blockquote><p>举例：如何理解布尔表达式的短路部分：考虑if语句里面的判断是一个或的表达式。<br>这时候根据then、else、后续代码有分三段代码块；这三段都对应一个label（跳转地址）<br>为了能够提前结束，还要拉链。将整个布尔表达式的真假和或两边的表达式的真假联系起来。<br>也就是在表达式中得要拉链的结果，在if-else语句中回填标签</p></blockquote><h2 id="设计四元式"><a href="#设计四元式" class="headerlink" title="设计四元式"></a>设计四元式</h2><p>设计四元式一定要设计成上下文无关的。包括几种类型：</p><ul><li>计算：加减乘除、下标引用</li><li>定义：常量、变量、函数</li><li>语句：函数调用、输入输出</li><li>布尔：跳转、标签</li></ul><div class="table-container"><table><thead><tr><th>op</th><th>var1</th><th>var2</th><th>var3</th></tr></thead><tbody><tr><td>+-*/</td><td>id/num</td><td>id/num</td><td>result</td></tr><tr><td>callret</td><td>id（函数名）</td><td></td><td>id(ret)</td></tr><tr><td>getarray</td><td>id（数组名）</td><td>id/num（index）</td><td>id</td></tr><tr><td>jop</td><td>id</td><td>id</td><td>label</td></tr><tr><td>j</td><td></td><td></td><td>label</td></tr><tr><td>jnz</td><td>id/num</td><td></td><td>label</td></tr><tr><td>const</td><td>int/char</td><td>val</td><td>name</td></tr><tr><td>int/char</td><td></td><td></td><td>name</td></tr><tr><td>intarray</td><td>size</td><td></td><td>name</td></tr><tr><td>chararray</td><td>size</td><td></td><td>name</td></tr><tr><td>Func</td><td>int/char/void</td><td></td><td>name</td></tr><tr><td>para</td><td>int/char</td><td></td><td>name</td></tr><tr><td>Main</td><td></td><td></td><td></td></tr><tr><td>setarray</td><td>id/num</td><td>index</td><td>name</td></tr><tr><td>assign</td><td>id/num</td><td></td><td>name</td></tr><tr><td>lab</td><td></td><td></td><td>label</td></tr><tr><td>call</td><td>name</td><td></td><td></td></tr><tr><td>vpara</td><td></td><td></td><td>id/num</td></tr><tr><td>scanf</td><td></td><td></td><td>name</td></tr><tr><td>print</td><td>str_index</td><td></td><td></td></tr><tr><td>print</td><td></td><td>id/num</td><td>int/char</td></tr><tr><td>ret</td><td></td><td></td><td>id/num</td></tr><tr><td>ret</td><td></td><td></td><td></td></tr><tr><td>endf</td><td></td><td></td></tr></tbody></table></div><h3 id="算术表达式的四元式生成"><a href="#算术表达式的四元式生成" class="headerlink" title="算术表达式的四元式生成"></a>算术表达式的四元式生成</h3><p>需要存储中间临时变量：加减乘除、查数组、函数调用都要将结果存到临时变量里<code>在代码中是tree-&gt;place属性，如$1</code></p><h3 id="布尔表达式的四元式生成"><a href="#布尔表达式的四元式生成" class="headerlink" title="布尔表达式的四元式生成"></a>布尔表达式的四元式生成</h3><p>以布尔表达式在if语句中为例：</p><p><img src="/2020/07/06/ComplierC0/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%B4%E6%98%8E/Untitled 23.png" alt="Untitled"></p><p><img src="/2020/07/06/ComplierC0/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%B4%E6%98%8E/Untitled 24.png" alt="Untitled"></p><p>布尔表达式E可能有提前结束，为真，执行S1代码，之后跳过S2；为假跳到执行S2代码，再继续执行。</p><p>代码实现是：先构造布尔表达式的代码，再生成3个代码标签，放在S1、2的前后。</p><p>代码顺序是：<code>BoolExp</code>-<code>label_true</code>-<code>S1</code>-<code>label-false</code>-<code>S2</code>-<code>continue_label</code></p><p>注意当确定了label的名字之后，需要<code>拉链和回填</code></p><p>拉链回传通过语法树的<code>TC、FC变量</code>实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">IR_BoolExp</span>(tree-&gt;child[<span class="number">0</span>]);</span><br><span class="line"><span class="type">char</span>* truelabel = <span class="built_in">newlabel</span>();</span><br><span class="line"><span class="type">char</span>* falselabel = <span class="built_in">newlabel</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">char</span>* conlabel = <span class="built_in">newlabel</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">gen</span>(<span class="string">&quot;lab&quot;</span>, <span class="built_in">newempty</span>(), <span class="built_in">newempty</span>(), truelabel);</span><br><span class="line"><span class="built_in">backPatch</span>(tree-&gt;child[<span class="number">0</span>]-&gt;TC, truelabel);</span><br><span class="line"></span><br><span class="line"><span class="built_in">IR_Analyze</span>(tree-&gt;child[<span class="number">1</span>]);</span><br><span class="line"><span class="built_in">gen</span>(<span class="string">&quot;j&quot;</span>, <span class="built_in">newempty</span>(), <span class="built_in">newempty</span>(), conlabel);</span><br><span class="line"></span><br><span class="line"><span class="built_in">gen</span>(<span class="string">&quot;lab&quot;</span>, <span class="built_in">newempty</span>(), <span class="built_in">newempty</span>(), falselabel);</span><br><span class="line"><span class="built_in">backPatch</span>(tree-&gt;child[<span class="number">0</span>]-&gt;FC, falselabel);</span><br><span class="line"><span class="built_in">IR_Analyze</span>(tree-&gt;child[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">gen</span>(<span class="string">&quot;lab&quot;</span>, <span class="built_in">newempty</span>(), <span class="built_in">newempty</span>(), conlabel);</span><br></pre></td></tr></table></figure><p>bool Exp 里面有 4 种节点： <code>布尔op</code>、<code>布尔常量</code>、<code>关系op</code>、<code>表达式</code></p><p>1、当前tree节点是算术表达式：</p><p>详解：先生成算术表达式的代码，生成代码<code>(jnz, tree-&gt;place, &#39;&#39;, zero)</code> ，第二条是<code>j</code>类型；再由TC和FC辅助走真假两条路；</p><p>也就是说jnz（序号为NXQ）里面的跳转地址应为真链（满足条件）；j（序号为NXQ）为假链，不满足条件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (tree-&gt;nodekind == NodeKind::ExpK) &#123;</span><br><span class="line"><span class="built_in">IR_Exp</span>(tree);</span><br><span class="line">tree-&gt;TC = NXQ;</span><br><span class="line">tree-&gt;FC = NXQ + <span class="number">1</span>;</span><br><span class="line"><span class="built_in">gen</span>(<span class="string">&quot;jnz&quot;</span>, tree-&gt;place, <span class="built_in">newempty</span>(), zero);</span><br><span class="line"><span class="built_in">gen</span>(<span class="string">&quot;j&quot;</span>, <span class="built_in">newempty</span>(), <span class="built_in">newempty</span>(), zero);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、布尔op（大于、等于等等）</p><p>要先生成两个EXp的代码；将临时变量的结果保存到两个孩子的place属性里</p><p>再设置两个分支<code>布尔op</code>和<code>j</code>分支，对应这一个满足条件，一个不满足条件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (tree-&gt;kind.bexp == BoolExpKind::ConOp_BoolEK) &#123;<span class="comment">// 表达式 ConOp 表达式</span></span><br><span class="line"><span class="built_in">IR_Exp</span>(tree-&gt;child[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">IR_Exp</span>(tree-&gt;child[<span class="number">1</span>]);</span><br><span class="line">tree-&gt;TC = NXQ;</span><br><span class="line">tree-&gt;FC = NXQ + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">switch</span> (tree-&gt;attr.op)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> TokenType::LSS:</span><br><span class="line"><span class="built_in">gen</span>(<span class="string">&quot;&lt;&quot;</span>, tree-&gt;child[<span class="number">0</span>]-&gt;place, tree-&gt;child[<span class="number">1</span>]-&gt;place, zero);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> TokenType::LEQ:</span><br><span class="line"><span class="built_in">gen</span>(<span class="string">&quot;&lt;=&quot;</span>, tree-&gt;child[<span class="number">0</span>]-&gt;place, tree-&gt;child[<span class="number">1</span>]-&gt;place, zero);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> TokenType::GRE:</span><br><span class="line"><span class="built_in">gen</span>(<span class="string">&quot;&gt;&quot;</span>, tree-&gt;child[<span class="number">0</span>]-&gt;place, tree-&gt;child[<span class="number">1</span>]-&gt;place, zero);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> TokenType::GEQ:</span><br><span class="line"><span class="built_in">gen</span>(<span class="string">&quot;&gt;=&quot;</span>, tree-&gt;child[<span class="number">0</span>]-&gt;place, tree-&gt;child[<span class="number">1</span>]-&gt;place, zero);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> TokenType::EQL:</span><br><span class="line"><span class="built_in">gen</span>(<span class="string">&quot;==&quot;</span>, tree-&gt;child[<span class="number">0</span>]-&gt;place, tree-&gt;child[<span class="number">1</span>]-&gt;place, zero);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> TokenType::NEQ:</span><br><span class="line"><span class="built_in">gen</span>(<span class="string">&quot;!=&quot;</span>, tree-&gt;child[<span class="number">0</span>]-&gt;place, tree-&gt;child[<span class="number">1</span>]-&gt;place, zero);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">gen</span>(<span class="string">&quot;j&quot;</span>, <span class="built_in">newempty</span>(), <span class="built_in">newempty</span>(), zero);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、布尔常量</p><p>与单独的表达式相同</p><p>4、与或非</p><p>非就是把自己的链和孩子的链反过来即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (TokenType::NOT == tree-&gt;attr.op) &#123;</span><br><span class="line"><span class="built_in">IR_BoolExp</span>(tree-&gt;child[<span class="number">0</span>]);</span><br><span class="line">tree-&gt;FC = tree-&gt;child[<span class="number">0</span>]-&gt;TC;</span><br><span class="line">tree-&gt;TC = tree-&gt;child[<span class="number">0</span>]-&gt;FC;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或要注意：或有两个部分（孩子）；根据常见的理解：第一个表达式为真，那么第二个就不用测试了</p><p>代码理解：先生成左孩子；接着立马生成一个标签放在右孩子代码的前面，用于左孩子为假时，立马跳转到这里开始判断；也就是说这里要回填为左孩子的假链；</p><p>接着继续拉链左孩子的真链为总体的真链；</p><p>再生成右孩子的表达式；这时候才得到整个或语句的假链的位置；</p><p>要将右孩子的真链和左孩子的真链合并才得到整个语句的真链</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">IR_BoolExp</span>(tree-&gt;child[<span class="number">0</span>]);</span><br><span class="line"><span class="type">char</span>* ll = <span class="built_in">newlabel</span>();</span><br><span class="line"><span class="built_in">gen</span>(<span class="string">&quot;lab&quot;</span>, <span class="built_in">newempty</span>(), <span class="built_in">newempty</span>(), ll);</span><br><span class="line"><span class="comment">// 分析：此处回填是没有问题的，因为：回填肯定是填前面四元式，填的序号就是NXQ，</span></span><br><span class="line"><span class="comment">// 只不过这里newlabel，代替NXQ，也就是全部转到这个label的地方，肯定是不会出现顺序上的问题</span></span><br><span class="line"><span class="built_in">backPatch</span>(tree-&gt;child[<span class="number">0</span>]-&gt;FC, ll);</span><br><span class="line">tree-&gt;TC = tree-&gt;child[<span class="number">0</span>]-&gt;TC;</span><br><span class="line"></span><br><span class="line"><span class="built_in">IR_BoolExp</span>(tree-&gt;child[<span class="number">1</span>]);</span><br><span class="line">tree-&gt;FC = tree-&gt;child[<span class="number">1</span>]-&gt;FC;</span><br><span class="line">tree-&gt;TC = <span class="built_in">merge</span>(tree-&gt;child[<span class="number">0</span>]-&gt;TC, tree-&gt;child[<span class="number">1</span>]-&gt;TC);</span><br></pre></td></tr></table></figure><h1 id="六、目标代码生成-MIPS"><a href="#六、目标代码生成-MIPS" class="headerlink" title="六、目标代码生成-MIPS"></a>六、<strong><strong>目标代码生成-MIPS</strong></strong></h1><h2 id="摘要-4"><a href="#摘要-4" class="headerlink" title="摘要"></a>摘要</h2><p>功能：将中间代码转换成真正能够运行的MIPS汇编代码。</p><p>主要解决：（剩余的工作大多是翻译的工作）</p><p>1、内存分配：指定数据和代码的位置</p><p>2、寄存器分配思路：除固定寄存器外，使用FIFO原则使用10个临时寄存器</p><p>3、栈帧的创建与销毁：与函数开始与结束；函数调用与返回语句四个过程有关。</p><p>函数开始和结束需要维护栈帧结构（保存和还原栈帧寄存器和返回地址、开辟空间保存变量）；函数调用需要保存寄存器现场；返回语句负责保存返回值到相应寄存器。</p><p>难点与出bug的地方：</p><ul><li>保证寄存器和内存的<code>一致性</code>，寄存器保存现场的时机：不是函数调用时，而是每一个代码块（有分支的位置）（）</li></ul><h2 id="内存分配方案"><a href="#内存分配方案" class="headerlink" title="内存分配方案"></a>内存分配方案</h2><blockquote><p>将IR转换成真正能够运行的汇编代码，首先要确定如何将数据和运行的代码放入内存，放在哪些区域。<br>过程为：先处理全局变量；在处理函数体（函数体首先要确认栈帧的结构，返回地址、参数等，再处理函数内容）</p></blockquote><p>用到的几个部分：</p><ul><li>.data段：存放全局变量，字符串常量</li><li>.text段：存放代码</li><li>stack：运行时使用，保存栈帧（地址从高到低）</li></ul><p><img src="/2020/07/06/ComplierC0/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%B4%E6%98%8E/Untitled 25.png" alt="Untitled"></p><h2 id="寄存器分配思路"><a href="#寄存器分配思路" class="headerlink" title="寄存器分配思路"></a>寄存器分配思路</h2><p>全部的寄存器：</p><div class="table-container"><table><thead><tr><th>寄存器</th><th>别名</th><th>用途</th></tr></thead><tbody><tr><td>$0</td><td>$zero</td><td>常量0(constant value 0)</td></tr><tr><td>$1</td><td>$at</td><td>保留给汇编器(Reserved for assembler)</td></tr><tr><td>$2-$3</td><td>$v0-$v1</td><td>函数调用返回值(values for results and expression evaluation)</td></tr><tr><td>$4-$7</td><td>$a0-$a3</td><td>函数调用参数(arguments)</td></tr><tr><td>$8-$15</td><td>$t0-$t7</td><td>暂时的(或随便用的)</td></tr><tr><td>$16-$23</td><td>$s0-$s7</td><td>保存的(或如果用，需要SAVE/RESTORE的)(saved)</td></tr><tr><td>$24-$25</td><td>$t8-$t9</td><td>暂时的(或随便用的)</td></tr><tr><td>$26~$27</td><td>$k0~$k1</td><td>保留供中断/陷阱处理程序使用</td></tr><tr><td>$28</td><td>$gp</td><td>全局指针(Global Pointer)</td></tr><tr><td>$29</td><td>$sp</td><td>堆栈指针(Stack Pointer)</td></tr><tr><td>$30</td><td>$fp</td><td>帧指针(Frame Pointer)</td></tr><tr><td>$31</td><td>$ra</td><td>返回地址(return address)</td></tr></tbody></table></div><p>一般用的：</p><ul><li><code>$fp</code>：栈顶（高地址）</li><li><code>$sp</code>：栈底（低）</li><li><code>$ra</code>：存储的是返回地址，即函数结束时会运行<code>jr $ra</code>，即回到函数调用者的下一条指令；函数调用时，需要将下一条指令地址放入这个寄存器</li><li><code>$v0</code>：如果函数有返回值，会将结果放入该寄存器</li><li><code>$a0-$a3</code>：参数寄存器。其实本项目没有用，都放入内存了。</li><li><code>$t0-$t9</code>：10个寄存器是使用频率很高的</li></ul><p>下面主要讲这10个寄存器的使用思路：考虑到其实这相当于内存的cache，主要解决一致性的问题。</p><p>如果我们要操作一个数、变量、数组的元素；那么首先去检查是否在寄存器堆（该状态保存在符号表）；如果在则直接使用；不在需要从内存载入。这时又需要看寄存器堆是否有空余的，如果有，则直接载入；没有则根据FIFO原则将原有值放回内存再使用新寄存器。</p><p>主要函数：<code>getRegIndex</code>每次输入变量名就可以直接获得该变量存储的寄存器序号</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">用途：管理寄存器堆。当需要加载操作数时（立即数、变量值、数组基地址），查看是否已在寄存器，或加载到哪个寄存器。</span></span><br><span class="line"><span class="comment">输入：变量名</span></span><br><span class="line"><span class="comment">输出：该变量可以存入的寄存器index，或者是已经存在的寄存器序号, isInReg, isGlobal</span></span><br><span class="line"><span class="comment">首先查找符号表中该变量是否在寄存器中，</span></span><br><span class="line"><span class="comment">如果在：返回序号，维护寄存器状态列表（对于全局、局部、临时变量都表示值是否在寄存器，数组表示基地址是否在）</span></span><br><span class="line"><span class="comment">不在：查看是否有空寄存器，若无，FIFO原则维护寄存器堆</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">此外还需维护两个全局变量: 表示是否在寄存器中（用于该函数体外），是否全局变量（.data段全局变量可以通过变量名直接获取、存储）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getRegIndex</span><span class="params">(<span class="type">char</span>* varname)</span> </span>&#123;</span><br><span class="line"><span class="comment">// bug 开始是负号 遗漏了</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">isdigit</span>(varname[<span class="number">0</span>]) || varname[<span class="number">0</span>] == <span class="string">&#x27;-&#x27;</span>) &#123;<span class="comment">// 立即数，不查询是否在寄存器，直接获取一个</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">getAnEmptyReg</span>(varname, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 变量</span></span><br><span class="line">Symbol* sb = <span class="built_in">lookUp_SymTab</span>(varname, isGlobal);</span><br><span class="line"><span class="keyword">if</span> (!sb) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;unexpect error: cannot find symbol\n&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (sb-&gt;isreg) &#123;<span class="comment">// 已经在寄存器堆中</span></span><br><span class="line">isInReg = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">checkRegInfoList</span>(varname);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;<span class="comment">// 不在寄存器中</span></span><br><span class="line">isInReg = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">getAnEmptyReg</span>(varname, sb);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两个辅助函数：1、<code>checkRegInfoList</code>检查变量在哪一个寄存器。2、<code>getAnEmptyReg</code>获得一个可以用的寄存器</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">根据变量名，返回所在的寄存器号；</span></span><br><span class="line"><span class="comment">同时需要更新此寄存器到队列末尾</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">checkRegInfoList</span><span class="params">(<span class="type">char</span>* varname)</span> </span>&#123;</span><br><span class="line">std::list&lt;RegInfo&gt;::iterator iter = regInfoList.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">for</span> (; iter != regInfoList.<span class="built_in">end</span>(); ++iter) &#123;</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">strcmp</span>((*iter).varname, varname)) &#123;</span><br><span class="line"><span class="built_in">INFO</span>(<span class="string">&quot;剩余寄存器：%d，已在寄存器：true，变量名：%s，寄存器序号：%d\n&quot;</span>, s_emptyRegNum, varname, std::<span class="built_in">distance</span>(regInfoList.<span class="built_in">begin</span>(),iter));</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (iter == regInfoList.<span class="built_in">end</span>()) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;unpected error in checkRegInfoList()\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">RegInfo nn = (*iter);</span><br><span class="line">regInfoList.<span class="built_in">push_back</span>(nn);</span><br><span class="line"></span><br><span class="line">regInfoList.<span class="built_in">erase</span>(iter);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> nn.regindex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">若有空寄存器，返回下一个寄存器序号；</span></span><br><span class="line"><span class="comment">若无，FIFO原则，退出一个</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getAnEmptyReg</span><span class="params">(<span class="type">char</span>* varname, Symbol* sb)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (s_emptyRegNum &gt; <span class="number">0</span>) &#123;<span class="comment">// 有空闲的寄存器：符号表isreg标志置为true，空闲寄存器数量-1，映射队列插入新元素</span></span><br><span class="line"><span class="keyword">if</span> (sb) &#123;</span><br><span class="line">sb-&gt;isreg = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> index = <span class="number">10</span> - s_emptyRegNum;</span><br><span class="line">s_emptyRegNum--;</span><br><span class="line"></span><br><span class="line">RegInfo nn = &#123; index, varname &#125;;</span><br><span class="line">regInfoList.<span class="built_in">push_back</span>(nn);</span><br><span class="line"></span><br><span class="line"><span class="built_in">INFO</span>(<span class="string">&quot;剩余寄存器：%d，变量名：%s，寄存器序号：%d\n&quot;</span>, s_emptyRegNum, varname, index);</span><br><span class="line"><span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;<span class="comment">// 没有空闲寄存器，需要清理出一个</span></span><br><span class="line"><span class="comment">// 将一个寄存器释放，送入内存，isreg标志位改变，映射队列pop；新元素isreg为true，映射队列pushback。</span></span><br><span class="line">RegInfo nn = regInfoList.<span class="built_in">front</span>();</span><br><span class="line">regInfoList.<span class="built_in">pop_front</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">isdigit</span>(nn.varname[<span class="number">0</span>]) || <span class="string">&#x27;-&#x27;</span> == nn.varname[<span class="number">0</span>]) &#123;<span class="comment">// 弹出的是立即数，不用送至内存</span></span><br><span class="line"><span class="comment">//return nn.regindex;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">Symbol* sb_pop = <span class="built_in">lookUp_SymTab</span>(nn.varname, p_isGlobal);</span><br><span class="line">sb_pop-&gt;isreg = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> (sb_pop-&gt;vec &gt;= <span class="number">0</span>) &#123;<span class="comment">// 弹出的是数组的基地址，也不用送入内存</span></span><br><span class="line"><span class="comment">//return nn.regindex;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;<span class="comment">// 弹出的是变量：分为全局和局部（临时）</span></span><br><span class="line"><span class="keyword">if</span> (p_isGlobal) &#123;</span><br><span class="line"><span class="built_in">fprintf</span>(ASM_FILE, <span class="string">&quot;\tsw\t\t$t%d, $%s\n&quot;</span>,</span><br><span class="line">nn.regindex,</span><br><span class="line">nn.varname</span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">fprintf</span>(ASM_FILE, <span class="string">&quot;\tsw\t\t$t%d, -%d($fp)\n&quot;</span>,</span><br><span class="line">nn.regindex,</span><br><span class="line">sb_pop-&gt;adress</span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//return nn.regindex;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 弹出的元素处理完毕</span></span><br><span class="line"><span class="keyword">if</span> (sb) &#123;</span><br><span class="line">sb-&gt;isreg = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">RegInfo ttt = &#123; nn.regindex, varname &#125;;</span><br><span class="line">regInfoList.<span class="built_in">push_back</span>(ttt);</span><br><span class="line"></span><br><span class="line"><span class="built_in">INFO</span>(<span class="string">&quot;剩余寄存器：%d，old变量名：%s，变量名：%s，寄存器序号：%d\n&quot;</span>, s_emptyRegNum, nn.varname, varname, nn.regindex);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> nn.regindex;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="难点-Bug：什么时候要保存现场？"><a href="#难点-Bug：什么时候要保存现场？" class="headerlink" title="难点-Bug：什么时候要保存现场？"></a>难点-Bug：什么时候要保存现场？</h3><p>初始思路：按照函数分配的（跳转函数才会保存现场，清空寄存器）</p><blockquote><p>后来在测试到<code>快速排序</code>的时候，由于各种跳转，导致寄存器有问题；不是正确的运行结果；<br>如，之前要判断的某个循环变量分配到1号寄存器，但是循环内部变量较多，1号寄存器被移除，存储新的变量；这时跳转回去判断，寄存器里面就不是原来的变量了。</p></blockquote><p><code>正确的方法</code>：按照<code>基本块</code>来分配</p><p>首先是基本块划分：</p><ul><li>程序的第一个四元式</li><li>转向语句的目标四元式（即j,jnz,jop的目标）</li><li>条件跳转jop的下一条（由于四元式生成过程中下一条总是 j）</li></ul><blockquote><p>具体方法：j的时候清空，遇到label的时候清空。（对应的就是跳转语句的目标和条件跳转的下一句）。<br>也就<code>if-else</code>处；<code>while</code>循环结束</p></blockquote><h2 id="栈帧处理过程："><a href="#栈帧处理过程：" class="headerlink" title="栈帧处理过程："></a>栈帧处理过程：</h2><p><img src="/2020/07/06/ComplierC0/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%B4%E6%98%8E/Untitled 26.png" alt="Untitled"></p><h3 id="1、函数开始："><a href="#1、函数开始：" class="headerlink" title="1、函数开始："></a>1、函数开始：</h3><p>（前提：函数调用者需要压入返回地址，保存寄存器的现场）</p><p>1、函数开始，先设置寄存器堆状态为可用；</p><p>2、<code>sw $fp, ($sp)</code>保存栈基址寄存器的值到栈变址寄存器（这个位置是低地址，空）</p><p>3、<code>move $fp, $sp</code>栈基址变成了栈变址的值（也就是返回的时候弹出新的基址对应的内存地址的值就是原来那个栈帧的基址的值）</p><p>4、<code>subi $sp, $sp, 8</code>变址-=8；（要存两个元素，原来的栈基址和函数返回地址；用于函数返回时栈帧和指令计数器的还原）</p><p>5、<code>sw $ra, 4($sp)</code>压入返回地址（这个返回地址是函数调用者的下一条指令地址）</p><p>6、压入参数、局部变量和临时变量（算术表达式的中间产生的变量）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">s_emptyRegNum = <span class="number">10</span>;<span class="comment">// 寄存器清空，但寄存器写入内存由函数调用者实现</span></span><br><span class="line">regInfoList.<span class="built_in">clear</span>();<span class="comment">// 清空队列</span></span><br><span class="line"><span class="comment">// 符号表不处理，因为连函数表都被抛弃了</span></span><br><span class="line"><span class="comment">// 栈的变化</span></span><br><span class="line"><span class="built_in">fprintf</span>(ASM_FILE, <span class="string">&quot;\tsw\t\t$fp, ($sp)\n&quot;</span>);<span class="comment">// ($sp) = $fp</span></span><br><span class="line"><span class="built_in">fprintf</span>(ASM_FILE, <span class="string">&quot;\tmove\t$fp, $sp\n&quot;</span>);<span class="comment">// $fp = $sp</span></span><br><span class="line"><span class="built_in">fprintf</span>(ASM_FILE, <span class="string">&quot;\tsubi\t$sp, $sp, 8\n&quot;</span>);<span class="comment">// $sp -= 8</span></span><br><span class="line"><span class="built_in">fprintf</span>(ASM_FILE, <span class="string">&quot;\tsw\t\t$ra, 4($sp)\n&quot;</span>);<span class="comment">// $ra</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 有些参数类型需要转换</span></span><br><span class="line"><span class="built_in">matchParaType</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">ignoreVarDef</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">insertTempVar</span>(cur_4var);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为函数参数、局部变量、临时变量分配空间</span></span><br><span class="line"><span class="built_in">fprintf</span>(ASM_FILE, <span class="string">&quot;\tsubi\t$sp, $sp, %d\n&quot;</span>, g_symtab-&gt;next-&gt;varsize - <span class="number">8</span>);</span><br></pre></td></tr></table></figure><h3 id="2、函数结束："><a href="#2、函数结束：" class="headerlink" title="2、函数结束："></a>2、函数结束：</h3><p>1、打标签：便于函数中间的返回语句直接跳转</p><p>2、保证内存和寄存器的一致性：由于寄存器相当于内存的cache，要将一些全局变量写会内存（函数的全局变量可以抛弃）</p><p>3、<code>lw $ra, -4($fp)</code>恢复返回地址寄存器</p><p>4、恢复函数调用者的栈帧：<code>move $sp, $fp</code> ，<code>lw $fp, ($fp)</code></p><p>5、函数返回，跳转到寄存器ra的地址的指令：<code>jr $ra</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数体结束，处理栈的变化等等</span></span><br><span class="line"><span class="comment">// 这一步也很重要，寄存器的值不要忘了写回</span></span><br><span class="line"><span class="built_in">fprintf</span>(ASM_FILE, <span class="string">&quot;ret_%s:\n&quot;</span>, s_funcName);</span><br><span class="line"></span><br><span class="line"><span class="built_in">saveReg</span>();<span class="comment">// 全局变量需要保存、局部变量已经没有意义</span></span><br><span class="line"><span class="comment">//s_emptyRegNum = 10;// 寄存器清空</span></span><br><span class="line"><span class="comment">//regInfoList.clear();// 清空队列</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 恢复状态</span></span><br><span class="line"><span class="built_in">fprintf</span>(ASM_FILE, <span class="string">&quot;\tlw\t\t$ra, -4($fp)\n&quot;</span>);<span class="comment">// 恢复$ra</span></span><br><span class="line"><span class="built_in">fprintf</span>(ASM_FILE, <span class="string">&quot;\tmove\t$sp, $fp\n&quot;</span>);<span class="comment">// $sp = $fp</span></span><br><span class="line"><span class="built_in">fprintf</span>(ASM_FILE, <span class="string">&quot;\tlw\t\t$fp, ($fp)\n&quot;</span>);<span class="comment">// $fp = ($fp)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(ASM_FILE, <span class="string">&quot;\tjr\t\t$ra\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// endf</span></span><br><span class="line">cur_4var++;</span><br></pre></td></tr></table></figure><h3 id="3、函数调用语句："><a href="#3、函数调用语句：" class="headerlink" title="3、函数调用语句："></a>3、函数调用语句：</h3><p>保存寄存器的值到内存（保存现场和一致性，子函数返回后还会使用这些值）</p><p><code>jal function</code>跳转到某个地址的同时将下一条指令的地址保存在寄存器$ra中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">call2asm</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">saveReg</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(ASM_FILE, <span class="string">&quot;\tjal\t\t%s\n&quot;</span>, quadvarlist[cur_4var].var1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4、return语句"><a href="#4、return语句" class="headerlink" title="4、return语句"></a>4、return语句</h3><ul><li>1、控制返回值：需要做类型校验和截断处理<code>move $v0, $t_</code></li><li>2、跳转到返回处理部分：<code>j ret_function</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ret2asm</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (quadvarlist[cur_4var].var3[<span class="number">0</span>] == <span class="string">&#x27; &#x27;</span>) &#123;<span class="comment">// == 写成 =了 。。。。。查了几分钟把，还好找出来了</span></span><br><span class="line"><span class="comment">/* do nothing */</span></span><br><span class="line"><span class="keyword">if</span> (Type::T_VOID != s_funcRetType) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;return type error ,id: %s\n&quot;</span>, quadvarlist[cur_4var].var3);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 保存返回值</span></span><br><span class="line"><span class="type">int</span> r3 = <span class="built_in">getRegIndex</span>(quadvarlist[cur_4var].var3);</span><br><span class="line"><span class="built_in">mem2reg</span>(quadvarlist[cur_4var].var3, r3);</span><br><span class="line"><span class="built_in">fprintf</span>(ASM_FILE, <span class="string">&quot;\tmove\t$v0, $t%d\n&quot;</span>, r3);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断返回类型</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">isdigit</span>(quadvarlist[cur_4var].var3[<span class="number">0</span>])) &#123;<span class="comment">// 返回的是数字</span></span><br><span class="line"><span class="keyword">if</span> (Type::T_VOID == s_funcRetType) &#123;</span><br><span class="line"><span class="comment">// void : error</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;return type error ,id: %s\n&quot;</span>, quadvarlist[cur_4var].var3);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (Type::T_CHAR == s_funcRetType) &#123;</span><br><span class="line"><span class="comment">// char: andi 0xff</span></span><br><span class="line"><span class="built_in">fprintf</span>(ASM_FILE, <span class="string">&quot;\tandi\t$v0, $v0, 0xff\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">/* int: do nothing */</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;<span class="comment">// 标识符</span></span><br><span class="line">Type real_ret_type = <span class="built_in">lookUp_SymTab</span>(quadvarlist[cur_4var].var3)-&gt;valueType;</span><br><span class="line"><span class="comment">// 上面一句似乎没用？</span></span><br><span class="line"><span class="keyword">if</span> (Type::T_VOID == s_funcRetType) &#123;</span><br><span class="line"><span class="comment">// void : error</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;return type error ,id: %s\n&quot;</span>, quadvarlist[cur_4var].var3);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (Type::T_CHAR == s_funcRetType) &#123;</span><br><span class="line"><span class="comment">// char: andi 0xff</span></span><br><span class="line"><span class="built_in">fprintf</span>(ASM_FILE, <span class="string">&quot;\tandi\t$v0, $v0, 0xff\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">/* int: do nothing */</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(ASM_FILE, <span class="string">&quot;\tj\t\tret_%s\n&quot;</span>, s_funcName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="其他语句（系统调用）："><a href="#其他语句（系统调用）：" class="headerlink" title="其他语句（系统调用）："></a>其他语句（系统调用）：</h2><p>完成输入输出的功能。</p><h2 id="难点："><a href="#难点：" class="headerlink" title="难点："></a>难点：</h2><p>保证一致性</p><h1 id="七、优化"><a href="#七、优化" class="headerlink" title="七、优化"></a>七、优化</h1><h2 id="1、划分基本块"><a href="#1、划分基本块" class="headerlink" title="1、划分基本块"></a>1、划分基本块</h2><p>划分规则：</p><ul><li>程序的第一个四元式</li><li>转向语句的目标四元式（即j,jnz,jop的目标）</li><li>条件跳转jop的下一条（由于四元式生成过程中下一条总是 j）</li></ul><p>由于本人程序在生成IR过程中的特殊性，条件跳转的下一条语句总是j，跳转的目标总是label</p><p>所以基本块划分方法可以简化为 遇到j和label就是基本块入口</p><blockquote><p>下面所说的优化基本是在基本块内的优化，可以叫做线性窥孔优化。</p></blockquote><h2 id="2、寄存器优化"><a href="#2、寄存器优化" class="headerlink" title="2、寄存器优化"></a>2、寄存器优化</h2><blockquote><p>可见目标代码生成部分。原本的寄存器分配可以是用完立即保存到内存，而不是使用10个。</p></blockquote><h2 id="3、强度削弱"><a href="#3、强度削弱" class="headerlink" title="3、强度削弱"></a>3、强度削弱</h2><p>强度削弱： 乘法和除法改为移位。首先需要判断当前操作是否有立即数，如果有，进一步判断是否是2的次方，如果是，就可以转换为移位操作。</p><blockquote><p>1、求模运算改成按位与（未实现，因为文法不包括求模）<br>2、非算术运算的削弱，尽量使用寄存器（和寄存器优化有关）<br>3、</p></blockquote><h2 id="4、常量合并"><a href="#4、常量合并" class="headerlink" title="4、常量合并"></a>4、常量合并</h2><blockquote><p>算地慢不如算地快，算地快不如不计算</p></blockquote><p><code>常量合并</code>：常量计算改为赋值。也就是将 + - * / 转化为 赋值。</p><blockquote><p>常数传播（未实现，文法限制）：在程序运行时，某段程序中的一些变量之值保持不变。直接替换成值的引用</p></blockquote><h2 id="5、删除公共子表达式"><a href="#5、删除公共子表达式" class="headerlink" title="5、删除公共子表达式"></a>5、删除公共子表达式</h2><p>算法思路[1]：</p><ul><li>（当前四元式序号为A）从A开始扫描基本块，由上向下找出有相同的op（对应DAG图中的父节点），var1（对应DAG图中的左子节点），var2（对应DAG图中的右子节点）且var3为临时变量的四元式B</li><li>从B向下继续扫描四元式，寻找所有与B具有相同var的四元式C1，C2，…；</li><li>将Ci的var置为var3；</li><li>删除B，置B为 NULL</li></ul><h1 id="八、错误处理"><a href="#八、错误处理" class="headerlink" title="八、错误处理"></a>八、错误处理</h1><h3 id="8-1、错误识别"><a href="#8-1、错误识别" class="headerlink" title="8.1、错误识别"></a>8.1、错误识别</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 匹配 期待的 token；否则报错</span></span><br><span class="line"><span class="comment">// 读取下一个token</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">match</span><span class="params">(TokenType expectToken)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (expectToken == g_token.opType) &#123;<span class="comment">// 与预期相同，跳过token， true</span></span><br><span class="line"><span class="built_in">getNextToken</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;<span class="comment">// 提示错误，但在这里不跳读</span></span><br><span class="line">g_errorNum++;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;match error in line %d :\t\texpect Token %d, but %d value: %s \n&quot;</span>, g_lineNumber, expectToken, g_token.opType, g_token.value);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-2、跳读到可以正确分析的位置"><a href="#8-2、跳读到可以正确分析的位置" class="headerlink" title="8.2、跳读到可以正确分析的位置"></a>8.2、跳读到可以正确分析的位置</h3><p>直到识别到某些token才停止；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;</span><br><span class="line">    LACK_SEMI_CST,              <span class="comment">// 常量定义没有分号，跳出当前，直到再次遇到常量定义、变量定义、语句</span></span><br><span class="line">    LACK_TYPE_CST,              <span class="comment">// 没有类型</span></span><br><span class="line">    LACK_ID_CST,                <span class="comment">// 没有标识符</span></span><br><span class="line">    LACK_ASSIGN_CST,            <span class="comment">// 没有赋值符号</span></span><br><span class="line"></span><br><span class="line">    LACK_XXX_VARDEF,            <span class="comment">// 变量定义出错，直接抛弃当前语句</span></span><br><span class="line"></span><br><span class="line">    LACK_TYPE_FUN,              <span class="comment">// 函数类型未说明</span></span><br><span class="line">    LACK_IDEN_FUN,              <span class="comment">// 函数名未说明   ， </span></span><br><span class="line">    LACK_KUOHAO_FUN,            <span class="comment">// 函数括号丢失   ， 跳过当前函数</span></span><br><span class="line"></span><br><span class="line">    SENTENCE_ERROR</span><br><span class="line">&#125;ErrorType;</span><br></pre></td></tr></table></figure><p>大致思想：</p><p>常量定义、变量定义、函数定义：跳过当前定义</p><p>语句：跳过当前语句</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (e)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> ErrorType::LACK_SEMI_CST:</span><br><span class="line"><span class="keyword">case</span> ErrorType::LACK_TYPE_CST: </span><br><span class="line"><span class="keyword">case</span> ErrorType::LACK_ID_CST:</span><br><span class="line"><span class="keyword">case</span> ErrorType::LACK_ASSIGN_CST: &#123;</span><br><span class="line"><span class="keyword">while</span> (g_token.opType != TokenType::CONST &amp;&amp; g_token.opType != TokenType::INT &amp;&amp; g_token.opType != TokenType::CHAR</span><br><span class="line">&amp;&amp; g_token.opType != TokenType::VOID &amp;&amp; g_token.opType != TokenType::IF</span><br><span class="line">&amp;&amp; g_token.opType != TokenType::WHILE &amp;&amp; g_token.opType != TokenType::FOR</span><br><span class="line">&amp;&amp; g_token.opType != TokenType::IDEN &amp;&amp; g_token.opType != TokenType::RETURN</span><br><span class="line">&amp;&amp; g_token.opType != TokenType::SCANF &amp;&amp; g_token.opType != TokenType::PRINTF</span><br><span class="line">&amp;&amp; g_token.opType != TokenType::LBRACE &amp;&amp; g_token.opType != TokenType::RBRACE</span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (g_token.opType == TokenType::END) </span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">getNextToken</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 以上都是常量定义阶段的错误</span></span><br><span class="line"><span class="comment">// 变量定义错误：</span></span><br><span class="line"><span class="keyword">case</span> ErrorType::LACK_XXX_VARDEF: &#123;</span><br><span class="line"><span class="keyword">while</span> (g_token.opType != TokenType::INT &amp;&amp; g_token.opType != TokenType::CHAR</span><br><span class="line">&amp;&amp; g_token.opType != TokenType::VOID &amp;&amp; g_token.opType != TokenType::IF</span><br><span class="line">&amp;&amp; g_token.opType != TokenType::WHILE &amp;&amp; g_token.opType != TokenType::FOR</span><br><span class="line">&amp;&amp; g_token.opType != TokenType::IDEN &amp;&amp; g_token.opType != TokenType::RETURN</span><br><span class="line">&amp;&amp; g_token.opType != TokenType::SCANF &amp;&amp; g_token.opType != TokenType::PRINTF</span><br><span class="line">&amp;&amp; g_token.opType != TokenType::LBRACE &amp;&amp; g_token.opType != TokenType::RBRACE</span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (g_token.opType == TokenType::END)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">getNextToken</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 函数定义错误</span></span><br><span class="line"><span class="keyword">case</span> ErrorType::LACK_TYPE_FUN:</span><br><span class="line"><span class="keyword">case</span> ErrorType::LACK_IDEN_FUN: </span><br><span class="line"><span class="keyword">case</span> ErrorType::LACK_KUOHAO_FUN: &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (g_token.opType != TokenType::INT &amp;&amp; g_token.opType != TokenType::CHAR</span><br><span class="line">&amp;&amp; g_token.opType != TokenType::VOID</span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (g_token.opType == TokenType::END)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">getNextToken</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 语句错误</span></span><br><span class="line"><span class="keyword">case</span> ErrorType::SENTENCE_ERROR: &#123;</span><br><span class="line"><span class="keyword">while</span> (g_token.opType != TokenType::IF</span><br><span class="line">&amp;&amp; g_token.opType != TokenType::WHILE &amp;&amp; g_token.opType != TokenType::FOR</span><br><span class="line">&amp;&amp; g_token.opType != TokenType::IDEN &amp;&amp; g_token.opType != TokenType::RETURN</span><br><span class="line">&amp;&amp; g_token.opType != TokenType::SCANF &amp;&amp; g_token.opType != TokenType::PRINTF</span><br><span class="line"><span class="comment">/*&amp;&amp; g_token.opType != TokenType::LBRACE */</span>&amp;&amp; g_token.opType != TokenType::RBRACE</span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (g_token.opType == TokenType::END)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">getNextToken</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-3-语法树错误屏蔽"><a href="#8-3-语法树错误屏蔽" class="headerlink" title="8.3 语法树错误屏蔽"></a>8.3 语法树错误屏蔽</h3><p>语法树标识错误，语义分析时跳过。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误处理</span></span><br><span class="line"><span class="type">bool</span> error;</span><br></pre></td></tr></table></figure><h1 id="九、-bug修复"><a href="#九、-bug修复" class="headerlink" title="九、 bug修复"></a>九、 bug修复</h1><h3 id="1、asm生成阶段：scanf语句"><a href="#1、asm生成阶段：scanf语句" class="headerlink" title="1、asm生成阶段：scanf语句"></a>1、asm生成阶段：scanf语句</h3><p>bug：多次读取同名变量时，由于scanf是直接写入内存，但或许之前使用过这个变量，并且已经调入寄存器；查表的时候会显示在寄存器堆中，这样就会读取就值；<br>    发现于 Test11.c0；多次输入x，发现后面使用的x的值始终不变<br>    (old，会带来新问题，可用寄存器数目不断减少)处理：从寄存器堆中移除此变量，且不用写回内存；故只需更新符号表状态、寄存器映射队列、可用寄存器数目<br>    (new)处理：如果在寄存器，则更新寄存器数据即可，其他不变</p><h3 id="2、寄存器分配策略错误"><a href="#2、寄存器分配策略错误" class="headerlink" title="2、寄存器分配策略错误"></a>2、寄存器分配策略错误</h3><p>之前的寄存器分配是按照函数分配的（跳转函数才会清空寄存器）；后来在测试到快速排序的时候，由于各种跳转，导致寄存器有问题；不是正确的运行结果；如，之前要判断的某个循环变量分配到1号寄存器，但是循环内部变量较多，1号寄存器被移除，存储新的变量；这时跳转回去判断，寄存器里面就不是原来的变量了。</p><p>正确的方法：按照基本块来分配</p><p>首先是基本块划分：</p><ul><li>程序的第一个四元式</li><li>转向语句的目标四元式（即j,jnz,jop的目标）</li><li>条件跳转jop的下一条（由于四元式生成过程中下一条总是 j）</li></ul><p>划分完基本块后，在每个基本块结束时清空即可（或是下一基本块开始时，清空上一基本块；本质就是基本块开始时，全部寄存器是空的）；这样就不会出现各种跳转就不会出现寄存器出错的问题。</p><p>我采用的具体方法：j的时候清空，遇到label的时候清空。（对应的就是跳转语句的目标和条件跳转的下一句）。所以，该方法时正确的。程序的结果也是正确的。</p><h1 id="十、参考"><a href="#十、参考" class="headerlink" title="十、参考"></a>十、参考</h1><blockquote><p>  [1]  实现一个C++实现的拓展C0文法MIPS交叉编译器<a href="https://www.cnblogs.com/sciencefans/articles/4235139.html">https://www.cnblogs.com/sciencefans/articles/4235139.html</a></p><p>  [2]  编译原理哈工大慕课与PPT<br>   <a href="https://www.icourse163.org/learn/HIT-1002123007?tid=1206830204#/learn/content">https://www.icourse163.org/learn/HIT-1002123007?tid=1206830204#/learn/content</a></p><p>  [3]  编译原理 第3版 蒋立源 2005</p><p>  [4]  现代编译原理C语言描述<em>tif</em>虎书</p><p>  [5]  编译原理西工大PPT</p><p>  [6]  MIPS汇编入门<br>   <a href="https://www.cnblogs.com/thoupin/p/4018455.html">https://www.cnblogs.com/thoupin/p/4018455.html</a></p><p>  [7]  MIPS汇编快速入门<br>   <a href="https://blog.csdn.net/u012837895/article/details/79855896">https://blog.csdn.net/u012837895/article/details/79855896</a></p><p>  [8]  SYSCALL functions available in MARS<br>   <a href="https://blog.csdn.net/sdreamq/article/details/50776393">https://blog.csdn.net/sdreamq/article/details/50776393</a></p><p>  [9]  Simple语言的定义(LL1文法)<br>   <a href="https://wenku.baidu.com/view/0fc831e8998fcc22bcd10de9">https://wenku.baidu.com/view/0fc831e8998fcc22bcd10de9</a></p><p>  [10] 《编译原理》控制流语句 if 和 while 语句的翻译<br>   <a href="https://www.cnblogs.com/xpwi/p/11072234.html">https://www.cnblogs.com/xpwi/p/11072234.html</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 课程大作业 </category>
          
          <category> C0编译器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编译器 </tag>
            
            <tag> C0文法 </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C0文法</title>
      <link href="/2020/07/05/ComplierC0/C0%E6%96%87%E6%B3%95/"/>
      <url>/2020/07/05/ComplierC0/C0%E6%96%87%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="文法定义："><a href="#文法定义：" class="headerlink" title="文法定义："></a>文法定义：</h2><h3 id="词法定义"><a href="#词法定义" class="headerlink" title="词法定义"></a>词法定义</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">1.&lt;加法运算符&gt; ::= +｜-</span><br><span class="line"></span><br><span class="line">2.&lt;乘法运算符&gt; ::= *｜/</span><br><span class="line"></span><br><span class="line">3.&lt;关系运算符&gt; ::= &lt;｜&lt;=｜&gt;｜&gt;=｜!=｜==</span><br><span class="line"></span><br><span class="line">4.&lt;逻辑运算符&gt; ::= &amp;&amp;  |  &#x27;|| &#x27;  |  !</span><br><span class="line"></span><br><span class="line">5.&lt;字母&gt; ::= ＿｜a｜．．．｜z｜A｜．．．｜Z</span><br><span class="line"></span><br><span class="line">6.&lt;非零数字&gt; ::= 1｜．．．｜9</span><br><span class="line"></span><br><span class="line">7.&lt;数字&gt; ::= 0｜&lt;非零数字&gt;</span><br><span class="line"></span><br><span class="line">8.&lt;无符号整数&gt; ::= &lt;非零数字&gt;｛&lt;数字&gt;｝｜0</span><br><span class="line"></span><br><span class="line">9.&lt;整数&gt; ::= ［＋｜－］&lt;无符号整数&gt;</span><br><span class="line"></span><br><span class="line">10.&lt;字符&gt; ::= &#x27;&lt;加法运算符&gt;&#x27;｜&#x27;&lt;乘法运算符&gt;&#x27;｜&#x27;&lt;字母&gt;&#x27;｜&#x27;&lt;数字&gt;&#x27;</span><br><span class="line"></span><br><span class="line">11.&lt;字符串&gt; ::= &quot;｛十进制编码为32,33,35-126的ASCII字符｝&quot;</span><br><span class="line"></span><br><span class="line">12.&lt;标识符&gt; ::= &lt;字母&gt;｛&lt;字母&gt;｜&lt;数字&gt;｝</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="语法定义"><a href="#语法定义" class="headerlink" title="语法定义"></a>语法定义</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">13.&lt;程序&gt; ::= ［&lt;常量说明&gt;］［&lt;变量说明&gt;］&#123;&lt;有返回值函数定义&gt;|&lt;无返回值函数定义&gt;&#125;&lt;主函数&gt;</span><br><span class="line"></span><br><span class="line">这里有很多的公因子，但是为了文法简单，好理解；就在程序上实现，没有提取</span><br><span class="line"></span><br><span class="line">14.&lt;常量说明&gt; ::= const&lt;常量定义&gt;;&#123; const&lt;常量定义&gt;;&#125;</span><br><span class="line"></span><br><span class="line">15.&lt;常量定义&gt; ::= int&lt;标识符&gt;＝&lt;整数&gt;&#123;,&lt;标识符&gt;＝&lt;整数&gt;&#125;| char&lt;标识符&gt;＝&lt;字符&gt;&#123;,&lt;标识符&gt;＝&lt;字符&gt;&#125;</span><br><span class="line"></span><br><span class="line">16.&lt;变量说明&gt; ::= &lt;变量定义&gt;;&#123;&lt;变量定义&gt;;&#125;</span><br><span class="line"></span><br><span class="line">17.&lt;变量定义&gt; ::= &lt;类型标识符&gt;&lt;标识符&gt;[‘[’&lt;无符号整数&gt;‘]’] &#123;,&lt;标识符&gt;[‘[’&lt;无符号整数&gt;‘]’]&#125;</span><br><span class="line"></span><br><span class="line">18.&lt;类型标识符&gt; ::= int | char</span><br><span class="line"></span><br><span class="line">19.&lt;有返回值函数定义&gt; ::= &lt;声明头部&gt;‘(’&lt;参数表&gt;‘)’ ‘&#123;’&lt;复合语句&gt;‘&#125;’</span><br><span class="line"></span><br><span class="line">20.&lt;声明头部&gt; ::= int&lt;标识符&gt; | char&lt;标识符&gt;</span><br><span class="line"></span><br><span class="line">21.&lt;无返回值函数定义&gt; ::= void&lt;标识符&gt;‘(’&lt;参数表&gt;‘)’ ‘&#123;’&lt;复合语句&gt;‘&#125;’</span><br><span class="line"></span><br><span class="line">22.&lt;参数表&gt; ::= &lt;类型标识符&gt;&lt;标识符&gt;&#123;,&lt;类型标识符&gt;&lt;标识符&gt;&#125;| &lt;空&gt;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 空语句：这里也有一处空语句，但follow集只有&#x27;)&#x27;一个元素</span><br><span class="line"></span><br><span class="line">23.&lt;复合语句&gt; ::= ［&lt;常量说明&gt;］［&lt;变量说明&gt;］&lt;语句列&gt;</span><br><span class="line"></span><br><span class="line">24.&lt;主函数&gt; ::= void main ‘(’ ‘)’ ‘&#123;’&lt;复合语句&gt;‘&#125;’</span><br><span class="line"></span><br><span class="line">25.&lt;语句列&gt; ::= ｛&lt;语句&gt;｝</span><br><span class="line"></span><br><span class="line">语句列是若干（包括0）个连续语句的集合</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 空语句：也就是说，可以光有定义，但是其他语句一个没有，什么都不做，follow集只有&#x27;&#125;&#x27;，</span><br><span class="line"></span><br><span class="line">26.&lt;语句&gt; ::= &lt;条件语句&gt;｜&lt;循环语句&gt;｜‘&#123;’&lt;语句列&gt;‘&#125;’｜&lt;有返回值的函数调用语句&gt;;｜&lt;无返回值的函数调用语句&gt;;｜&lt;赋值语句&gt;;｜&lt;读语句&gt;;｜&lt;写语句&gt;;｜&lt;空&gt;;｜&lt;返回语句&gt;;</span><br><span class="line"> </span><br><span class="line">!!!!!! 注意：这里的  “&lt;空&gt;;” 和 空语句是不一样的，只有个分号</span><br><span class="line"> </span><br><span class="line">27.&lt;赋值语句&gt; ::= &lt;标识符&gt;[‘[’&lt;算术表达式&gt;‘]’]＝&lt;算术表达式&gt;</span><br><span class="line"> </span><br><span class="line">28.&lt;条件语句&gt; ::= if ‘(’&lt;布尔表达式&gt;‘)’&lt;语句&gt;［else&lt;语句&gt;］</span><br><span class="line"></span><br><span class="line">29.&lt;循环语句&gt; ::= while ‘(’&lt;布尔表达式&gt;‘)’&lt;语句&gt;| for‘(’&lt;赋值语句&gt;;&lt;布尔表达式&gt;;&lt;赋值语句&gt;‘)’&lt;语句&gt;</span><br><span class="line"></span><br><span class="line">for循环中的三个表达式：初始化表达式、循环变量测试表达式、循环变量修正表达式</span><br><span class="line"></span><br><span class="line">30.&lt;有返回值的函数调用语句&gt; ::= &lt;标识符&gt;‘(’&lt;值参数表&gt;‘)’</span><br><span class="line"></span><br><span class="line">31.&lt;无返回值的函数调用语句&gt; ::= &lt;标识符&gt;‘(’&lt;值参数表&gt;‘)’</span><br><span class="line"></span><br><span class="line">32.&lt;值参数表&gt; ::= &lt;算术表达式&gt;&#123;,&lt;算术表达式&gt;&#125;｜&lt;空&gt;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 空语句：这里也有一处空语句，但follow集只有&#x27;)&#x27;一个元素</span><br><span class="line"></span><br><span class="line">33.&lt;读语句&gt; ::= scanf ‘(’&lt;标识符&gt;&#123;,&lt;标识符&gt;&#125;‘)’</span><br><span class="line"> </span><br><span class="line">34.&lt;写语句&gt; ::= printf ‘(’&lt;字符串&gt;,&lt;算术表达式&gt;‘)’| printf ‘(’&lt;字符串&gt;‘)’| printf ‘(’&lt;算术表达式&gt;‘)’</span><br><span class="line"> </span><br><span class="line">定义写语句是以printf为起始的，后接圆括号括起来的字符串或表达式或者两者都有，若两者都存在，则字符串在先，以逗号隔开。</span><br><span class="line"> </span><br><span class="line">35.&lt;返回语句&gt; ::= return[‘(’&lt;算术表达式&gt;‘)’]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">36.&lt;算术表达式&gt; ::= ［＋｜－］&lt;项&gt;&#123;&lt;加法运算符&gt;&lt;项&gt;&#125;</span><br><span class="line"></span><br><span class="line">37.&lt;项&gt; ::= &lt;因子&gt;&#123;&lt;乘法运算符&gt;&lt;因子&gt;&#125;</span><br><span class="line"></span><br><span class="line">38.&lt;因子&gt; ::= &lt;标识符&gt;｜&lt;标识符&gt;‘[’&lt;算术表达式&gt;‘]’｜&lt;无符号整数&gt;|&lt;字符&gt;｜&lt;有返回值函数调用语句&gt;|‘(’&lt;算术表达式&gt;‘)’</span><br><span class="line"></span><br><span class="line">39.&lt;布尔表达式&gt; ::= &lt;布尔项&gt; &#123; ‘||’ &lt;布尔项&gt; &#125;</span><br><span class="line"></span><br><span class="line">40.&lt;布尔项&gt; ::= &lt;布因子&gt;&#123; &amp;&amp; &lt;布因子&gt; &#125;</span><br><span class="line"></span><br><span class="line">41.&lt;布因子&gt; ::= false | true | ! &lt;布因子&gt; | ‘(‘&lt;布尔表达式&gt;’)’ | &lt;条件因子&gt; [&lt;条件运算符&gt; &lt;条件因子&gt;]</span><br><span class="line"></span><br><span class="line">事实上，这里的 ！ 的优先级是比关系运算符低的</span><br><span class="line"></span><br><span class="line">42.&lt;条件因子&gt; ::= &lt;标识符&gt;[‘[’&lt;算术表达式&gt;‘]’]｜ &lt;无符号整数&gt; | &lt;字符&gt; | &lt;有返回值函数调用语句&gt;</span><br><span class="line"></span><br><span class="line">事实上，这里&lt;条件因子&gt;不像（算术）表达式中一样，这里不支持嵌套，不支持’()’，因为布尔表达式设计起来符合嵌套，主要是括号不好处理；暂时这么设计，然后如果真要表达式的话，可以在前面先计算赋值给一个变量</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 课程大作业 </category>
          
          <category> C0编译器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编译器 </tag>
            
            <tag> C0文法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>哈工大慕课《编译原理》笔记</title>
      <link href="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
      <url>/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="第一讲-绪论"><a href="#第一讲-绪论" class="headerlink" title="第一讲 绪论"></a>第一讲 绪论</h2><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200423233623380.png" alt="image-20200423233623380"></p><h3 id="语义分析"><a href="#语义分析" class="headerlink" title="语义分析"></a>语义分析</h3><blockquote><p>  语句主要分为：声明语句（数据对象和过程）、可执行语句</p></blockquote><h4 id="语义分析的主要任务"><a href="#语义分析的主要任务" class="headerlink" title="语义分析的主要任务"></a>语义分析的主要任务</h4><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200423233142555.png" alt="image-20200423233142555"></p><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200423233156751.png" alt="image-20200423233156751"></p><h2 id="第二讲-语言及其文法-2020-4-14"><a href="#第二讲-语言及其文法-2020-4-14" class="headerlink" title="第二讲 语言及其文法 2020-4-14"></a>第二讲 语言及其文法 2020-4-14</h2><h3 id="2-1-基本概念"><a href="#2-1-基本概念" class="headerlink" title="2.1 基本概念"></a>2.1 基本概念</h3><h4 id="字母表"><a href="#字母表" class="headerlink" title="字母表"></a>字母表</h4><p>字母表 ∑是一个有穷符号集合；</p><p>符号：字 母、数、标点符号、 …</p><h5 id="字母表上的运算"><a href="#字母表上的运算" class="headerlink" title="字母表上的运算"></a>字母表上的运算</h5><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200414155540833.png" alt="image-20200414155540833"></p><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200414155553074.png" alt="image-20200414155553074"></p><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200414155619372.png" alt="image-20200414155619372"></p><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200414155629719.png" alt="image-20200414155629719"></p><h4 id="串"><a href="#串" class="headerlink" title="串"></a>串</h4><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200414155719711.png" alt="image-20200414155719711"></p><h5 id="串的运算"><a href="#串的运算" class="headerlink" title="串的运算"></a>串的运算</h5><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200414155755221.png" alt="image-20200414155755221"></p><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200414155820504.png" alt="image-20200414155820504"></p><h3 id="2-2-文法定义"><a href="#2-2-文法定义" class="headerlink" title="2.2 文法定义"></a>2.2 文法定义</h3><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200414155944996.png" alt="image-20200414155944996"></p><h4 id="文法的形式化定义"><a href="#文法的形式化定义" class="headerlink" title="文法的形式化定义"></a>文法的形式化定义</h4><blockquote><p>  北航文法：|、（、[、{</p><p>  或、限定范围、可选、闭包</p></blockquote><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200414160013578.png" alt="image-20200414160013578"></p><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200414160031020.png" alt="image-20200414160031020"></p><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200414160043659.png" alt="image-20200414160043659"></p><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200414160208413.png" alt="image-20200414160208413"></p><blockquote><p>  如果不会引起误解，产生式就可以代表一种语言</p></blockquote><h4 id="产生式的简写-lt-gt"><a href="#产生式的简写-lt-gt" class="headerlink" title="产生式的简写&lt;!&gt;"></a>产生式的简写&lt;!&gt;</h4><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200414160300901.png" alt="image-20200414160300901"></p><h4 id="符号约定"><a href="#符号约定" class="headerlink" title="符号约定"></a>符号约定</h4><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200414160345306.png" alt="image-20200414160345306"></p><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200414160350493.png" alt="image-20200414160350493"></p><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200414160554641.png" alt="image-20200414160554641"></p><h3 id="2-3-语言的定义"><a href="#2-3-语言的定义" class="headerlink" title="2.3 语言的定义"></a>2.3 语言的定义</h3><blockquote><p>  有了规则，怎么识别是否是这种语言？</p></blockquote><h4 id="推导与规约"><a href="#推导与规约" class="headerlink" title="推导与规约"></a>推导与规约</h4><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200414160829977.png" alt="image-20200414160829977"></p><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200414160953530.png" alt="image-20200414160953530"></p><h4 id="句型和句子"><a href="#句型和句子" class="headerlink" title="句型和句子"></a>句型和句子</h4><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200414160931076.png" alt="image-20200414160931076"></p><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200414160944915.png" alt="image-20200414160944915"></p><h4 id="语言的形式化定义"><a href="#语言的形式化定义" class="headerlink" title="语言的形式化定义"></a>语言的形式化定义</h4><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200414161044167.png" alt="image-20200414161044167"></p><blockquote><p>  必须是句子，只有终结符</p></blockquote><h4 id="语言的运算"><a href="#语言的运算" class="headerlink" title="语言的运算"></a>语言的运算</h4><blockquote><p>  不是很理解，这里的运算是指语言的吗？</p></blockquote><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200414161258202.png" alt="image-20200414161258202"></p><blockquote><p>  举例：把集合看成一种语言，字母、数字的集合，看作是语言；然后语言运算，就是标识符了</p><p>  (这么看也没错，语言本就是一个集合)</p></blockquote><h3 id="2-4-文法的分类"><a href="#2-4-文法的分类" class="headerlink" title="2.4 文法的分类"></a>2.4 文法的分类</h3><h4 id="0型文法"><a href="#0型文法" class="headerlink" title="0型文法"></a>0型文法</h4><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200414162445423.png" alt="image-20200414162445423"></p><h4 id="1型文法"><a href="#1型文法" class="headerlink" title="1型文法"></a>1型文法</h4><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200414162552673.png" alt="image-20200414162552673"></p><h4 id="2型文法"><a href="#2型文法" class="headerlink" title="2型文法"></a>2型文法</h4><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200414162652255.png" alt="image-20200414162652255"></p><h4 id="3型文法"><a href="#3型文法" class="headerlink" title="3型文法"></a>3型文法</h4><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200414162702556.png" alt="image-20200414162702556"></p><h4 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h4><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200414162751558.png" alt="image-20200414162751558"></p><h3 id="2-5-CFG的语法分析树"><a href="#2-5-CFG的语法分析树" class="headerlink" title="2.5 CFG的语法分析树"></a>2.5 CFG的语法分析树</h3><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200414163058136.png" alt="image-20200414163058136"></p><h4 id="短语和直接短语"><a href="#短语和直接短语" class="headerlink" title="短语和直接短语"></a>短语和直接短语</h4><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200414163226489.png" alt="image-20200414163226489"></p><blockquote><p>  句柄：最左直接短语</p></blockquote><h4 id="二义性文法"><a href="#二义性文法" class="headerlink" title="二义性文法"></a>二义性文法</h4><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200414163259750.png" alt="image-20200414163259750"></p><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200414163421893.png" alt="image-20200414163421893"></p><h2 id="第三讲-词法分析-2020-4-14"><a href="#第三讲-词法分析-2020-4-14" class="headerlink" title="第三讲 词法分析 2020-4-14"></a>第三讲 词法分析 2020-4-14</h2><h3 id="3-1-正则表达式"><a href="#3-1-正则表达式" class="headerlink" title="3.1 正则表达式"></a>3.1 正则表达式</h3><p>正则表达式(Regular Expression，RE)是一种用来描述正则语言的更紧凑的表示方法</p><p>正则表达式可以由较小的正则表达式按照特定规则递归地构建。每个正则表达式r定义（表示）一个语言，记为L(r )。这个语言也是根据r的子表达式所表示的语言递归定义的</p><h4 id="正则表达式的定义"><a href="#正则表达式的定义" class="headerlink" title="正则表达式的定义"></a>正则表达式的定义</h4><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200414164516624.png" alt="image-20200414164516624"></p><blockquote><p>  空串是RE，表达的语言也是空串</p><p>  字母表上的任何一个符号，表示的语言只包含它本身</p><p>  集中运算：</p><ul><li>连接：</li><li>或：|</li><li>克林闭包：语言的克林闭包</li><li><p>括号可以消去</p><h4 id="正规式简化"><a href="#正规式简化" class="headerlink" title="正规式简化"></a>正规式简化</h4><p>正闭包</p><blockquote><p>r+ = rr<em> = r\</em>r，r*= r+|ε</p><p>+与*具有相同的运算优先级和结合性</p></blockquote><p>可选符</p><blockquote><p>r?=r |ε</p></blockquote><p>字符组</p><blockquote><p>字符组是或关系的缩写形式，它把所有存在或关系的字符集中在[ ]里面</p><p>枚举方式: 如[abc]，它等价于a|b|c<br>分段方式: 如[0-9a-z]，它等价于[0123456789abcdefghijklmnopqrstuvwxyz]<br>17</p></blockquote><p>非字符组</p><blockquote><p>若Σ={a,b,c,d,e,f,g}，则L([ ^abc ]) = { d, e, f, g }。</p></blockquote><p>串</p><blockquote><p>引入串的表示可以避免与正规式中运算符的冲突。例如：”a|b”=a”|”b≠a|b。</p></blockquote><h4 id="正规式简化2"><a href="#正规式简化2" class="headerlink" title="正规式简化2"></a>正规式简化2</h4><blockquote><p>转义符\，用于将特殊符号的含义取消<br>{m,n} 匹配其前面的字符至少出现m次，最多出现n次<br>{n} 匹配其前面的字符恰好出现n次<br>{n,}匹配其前面的字符出现不小于n次<br>首符号‘^’<br>尾符号‘$’<br>.匹配除了换行符外任意一个字符</p></blockquote></li></ul></blockquote><h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200414164845151.png" alt="image-20200414164845151"></p><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200414164906961.png" alt="image-20200414164906961"></p><h4 id="正则语言"><a href="#正则语言" class="headerlink" title="正则语言"></a>正则语言</h4><p>可以用RE定义的语言叫做正则语言(regular language)或正则集合(regular set)</p><p><strong>正则文法与正则表达式等价</strong></p><blockquote><p>  对任何正则文法G，存在定义同一语言的正则表达式r<br>  对任何正则表达式r，存在生成同一语言的正则文法G</p></blockquote><h4 id="RE的代数定律"><a href="#RE的代数定律" class="headerlink" title="RE的代数定律"></a>RE的代数定律</h4><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200414165056191.png" alt="image-20200414165056191"></p><h3 id="3-2-正则定义"><a href="#3-2-正则定义" class="headerlink" title="3.2 正则定义"></a>3.2 正则定义</h3><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200414165327823.png" alt="image-20200414165327823"></p><h4 id="举例-1"><a href="#举例-1" class="headerlink" title="举例"></a>举例</h4><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200414165359643.png" alt="image-20200414165359643"></p><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200414165428297.png" alt="image-20200414165428297"></p><h3 id="3-3-有穷自动机"><a href="#3-3-有穷自动机" class="headerlink" title="3.3 有穷自动机"></a>3.3 有穷自动机</h3><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200414165811306.png" alt="image-20200414165811306"></p><h4 id="FA的表示"><a href="#FA的表示" class="headerlink" title="FA的表示"></a>FA的表示</h4><h5 id="转换图"><a href="#转换图" class="headerlink" title="转换图"></a>转换图</h5><p>结点：FA的状态</p><blockquote><p>  初始状态（开始状态）：只有一个，由start箭头指向</p><p>  终止状态（接收状态）：可以有多个，用双圈表示</p></blockquote><p>带标记的有向边：如果对于输入a，存在一个从状态p到状态q的转换，就在p、q之间画一条有向边，并标记上a</p><h4 id="FA定义（接收）的语言"><a href="#FA定义（接收）的语言" class="headerlink" title="FA定义（接收）的语言"></a>FA定义（接收）的语言</h4><p>给定输入串x，如果存在一个对应于串x的从初始状态到某个终止状态的转换序列，则称串x被该FA接收</p><p>由一个有穷自动机M接收的所有串构成的集合称为是该FA定义（或接收）的语言，记为L(M )</p><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200414170141722.png" alt="image-20200414170141722"></p><h4 id="最长子串匹配原则-LongestString-MatchingPrinciple"><a href="#最长子串匹配原则-LongestString-MatchingPrinciple" class="headerlink" title="最长子串匹配原则(LongestString MatchingPrinciple)"></a>最长子串匹配原则(LongestString MatchingPrinciple)</h4><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200415171200826.png" alt="image-20200415171200826"></p><blockquote><p>  匹配到 &lt; 之后，只要还有符号，就继续匹配；即使到达某个终态</p><p>  ++ 可以也匹配+；但我们把他看作是++</p></blockquote><h3 id="3-4-有穷自动机的分类"><a href="#3-4-有穷自动机的分类" class="headerlink" title="3.4 有穷自动机的分类"></a>3.4 有穷自动机的分类</h3><h4 id="1、确定的有穷自动机-DFA"><a href="#1、确定的有穷自动机-DFA" class="headerlink" title="1、确定的有穷自动机(DFA)"></a>1、确定的有穷自动机(DFA)</h4><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200415165921727.png" alt="image-20200415165921727"></p><blockquote><p>  对应一个输入字母，只有一种转换</p></blockquote><h4 id="2、非确定的有穷自动机-NFA"><a href="#2、非确定的有穷自动机-NFA" class="headerlink" title="2、非确定的有穷自动机(NFA)"></a>2、非确定的有穷自动机(NFA)</h4><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200415170028879.png" alt="image-20200415170028879"></p><blockquote><p>  从状态出发，沿着标记出发，能到达的状态是个集合</p><p>  如果转换函数没有给出对应于某个状态-输入对的信息，就把Ø放入相应的表项中</p></blockquote><h4 id="DFA和NFA的等价性"><a href="#DFA和NFA的等价性" class="headerlink" title="DFA和NFA的等价性"></a>DFA和NFA的等价性</h4><ul><li><p>对任何非确定的有穷自动机N ，存在定义同一语言的确定的有穷自动机D</p></li><li><p>对任何确定的有穷自动机D ，存在定义同一语言的非确定的有穷自动机N</p></li></ul><h4 id="3、带有“ε-边”的NFA"><a href="#3、带有“ε-边”的NFA" class="headerlink" title="3、带有“ε-边”的NFA"></a>3、带有“ε-边”的NFA</h4><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200415170453075.png" alt="image-20200415170453075"></p><blockquote><p>  不是相同状态，例如有些东西不再接收</p></blockquote><h4 id="带有和不带有“ε-边”的NFA-的等价性"><a href="#带有和不带有“ε-边”的NFA-的等价性" class="headerlink" title="带有和不带有“ε-边”的NFA 的等价性"></a>带有和不带有“ε-边”的NFA 的等价性</h4><h4 id="4、DFA的算法实现-lt-lt-gt-gt"><a href="#4、DFA的算法实现-lt-lt-gt-gt" class="headerlink" title="4、DFA的算法实现 &lt;&lt;!!!&gt;&gt;"></a>4、DFA的算法实现 &lt;&lt;!!!&gt;&gt;</h4><blockquote><p>  NFA直观；但DFA实现简单</p></blockquote><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200415170708945.png" alt="image-20200415170708945"></p><h5 id="louden-书的实现"><a href="#louden-书的实现" class="headerlink" title="louden 书的实现"></a>louden 书的实现</h5><blockquote><p>  和博客类似</p></blockquote><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200415190003372.png" alt="image-20200415190003372"></p><h3 id="3-5-从正则表达式到有穷自动机"><a href="#3-5-从正则表达式到有穷自动机" class="headerlink" title="3.5 从正则表达式到有穷自动机"></a>3.5 从正则表达式到有穷自动机</h3><blockquote><p>  识别单词&gt;&gt; 正则表达式 ，因为直接从正则表达式到 DFA比较难；所以先到 NFA，再到DFA</p></blockquote><h4 id="根据RE-构造NFA"><a href="#根据RE-构造NFA" class="headerlink" title="根据RE 构造NFA"></a>根据RE 构造NFA</h4><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200415171605456.png" alt="image-20200415171605456"></p><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200415171617499.png" alt="image-20200415171617499"></p><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200415171626042.png" alt="image-20200415171626042"></p><h3 id="3-6-从NFA到DFA的转换"><a href="#3-6-从NFA到DFA的转换" class="headerlink" title="3.6 从NFA到DFA的转换"></a>3.6 从NFA到DFA的转换</h3><h4 id="从NFA到DFA的转换"><a href="#从NFA到DFA的转换" class="headerlink" title="从NFA到DFA的转换"></a>从NFA到DFA的转换</h4><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200415172247525.png" alt="image-20200415172247525"></p><h4 id="从带有ε-边的NFA到DFA的转换"><a href="#从带有ε-边的NFA到DFA的转换" class="headerlink" title="从带有ε-边的NFA到DFA的转换"></a>从带有ε-边的NFA到DFA的转换</h4><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200415172647950.png" alt="子集构造法（subset construction）"></p><h4 id="子集构造法（subset-construction）"><a href="#子集构造法（subset-construction）" class="headerlink" title="子集构造法（subset construction）"></a>子集构造法（subset construction）</h4><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200415175702434.png" alt="image-20200415175702434"></p><blockquote><p>  从初始状态求闭包开始（就是空转换能到达的状态集合）</p><p>  Dstates ： DFA 的 状态集合；一开始只有初始闭包；</p><p>  之后对每一个输入符号，状态转换，再求闭包；这是一个新状态；</p><p>  注意标记问题；就像dfs，visited数组一样</p></blockquote><h4 id="似乎没有最小化DFA"><a href="#似乎没有最小化DFA" class="headerlink" title="似乎没有最小化DFA"></a>似乎没有最小化DFA</h4><h3 id="3-7-识别单词的DFA"><a href="#3-7-识别单词的DFA" class="headerlink" title="3.7 识别单词的DFA"></a>3.7 识别单词的DFA</h3><h4 id="DFA举例"><a href="#DFA举例" class="headerlink" title="DFA举例"></a>DFA举例</h4><h5 id="1、识别标识符的DFA"><a href="#1、识别标识符的DFA" class="headerlink" title="1、识别标识符的DFA"></a>1、识别标识符的DFA</h5><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200415181335170.png" alt="image-20200415181335170"></p><blockquote><p>  慕课提示：识别关键字和标识符是一样的；有一个关键字的表</p></blockquote><h5 id="2、识别无符号数的DFA"><a href="#2、识别无符号数的DFA" class="headerlink" title="2、识别无符号数的DFA"></a>2、识别无符号数的DFA</h5><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200415181350273.png" alt="image-20200415181350273"></p><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200415181355997.png" alt="image-20200415181355997"></p><h5 id="3、识别各进制无符号整数的DFA"><a href="#3、识别各进制无符号整数的DFA" class="headerlink" title="3、识别各进制无符号整数的DFA"></a>3、识别各进制无符号整数的DFA</h5><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200415181412342.png" alt="image-20200415181412342"></p><h5 id="4、识别注释的DFA"><a href="#4、识别注释的DFA" class="headerlink" title="4、识别注释的DFA"></a>4、识别注释的DFA</h5><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200415181430167.png" alt="image-20200415181430167"></p><h5 id="5、识别Token"><a href="#5、识别Token" class="headerlink" title="5、识别Token"></a>5、识别Token</h5><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200415181437461.png" alt="image-20200415181437461"></p><h4 id="词法分析阶段的错误处理-lt-lt-gt-gt"><a href="#词法分析阶段的错误处理-lt-lt-gt-gt" class="headerlink" title="词法分析阶段的错误处理&lt;&lt;!!!&gt;&gt;"></a>词法分析阶段的错误处理&lt;&lt;!!!&gt;&gt;</h4><h5 id="词法分析阶段可检测错误的类型"><a href="#词法分析阶段可检测错误的类型" class="headerlink" title="词法分析阶段可检测错误的类型"></a>词法分析阶段可检测错误的类型</h5><ul><li>单词拼写错误</li><li>非法字符</li></ul><h5 id="词法错误检测"><a href="#词法错误检测" class="headerlink" title="词法错误检测"></a>词法错误检测</h5><p>如果当前状态与当前输入符号在<strong>转换表对应项中的信息为空</strong>，而当前状态又<strong>不是终止状态</strong>，则调用错误处理程序</p><h5 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h5><blockquote><p>  不是很理解他说的</p></blockquote><h2 id="第四讲-语法分析1-2020-4-3"><a href="#第四讲-语法分析1-2020-4-3" class="headerlink" title="第四讲 语法分析1 2020-4-3"></a>第四讲 语法分析1 2020-4-3</h2><h3 id="4-1-自顶向下分析概述"><a href="#4-1-自顶向下分析概述" class="headerlink" title="4.1 自顶向下分析概述"></a>4.1 自顶向下分析概述</h3><h3 id="4-2-文法转换"><a href="#4-2-文法转换" class="headerlink" title="4.2 文法转换"></a>4.2 文法转换</h3><h4 id="1、消除直接左递归"><a href="#1、消除直接左递归" class="headerlink" title="1、消除直接左递归"></a>1、消除直接左递归</h4><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200404134548259.png" alt="image-20200404134548259"></p><blockquote><p>  事实上，这种消除过程就是把左递归转换成了右递归</p></blockquote><p>举例：</p><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200404134613236.png" alt="image-20200404134613236"></p><h4 id="2、消除间接左递归"><a href="#2、消除间接左递归" class="headerlink" title="2、消除间接左递归"></a>2、消除间接左递归</h4><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200404134800513.png" alt="image-20200404134800513"></p><h5 id="消除左递归算法："><a href="#消除左递归算法：" class="headerlink" title="消除左递归算法："></a>消除左递归算法：</h5><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200404134813667.png" alt="image-20200404134813667"></p><h4 id="3、提取左公因子算法"><a href="#3、提取左公因子算法" class="headerlink" title="3、提取左公因子算法"></a>3、提取左公因子算法</h4><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200404134924349.png" alt="image-20200404134924349"></p><blockquote><p>  应该是解决有多个候选式导致的回溯问题</p></blockquote><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><blockquote><p>  没有矩阵消除左递归方法</p><p>  但没有曾老师讲的详细：</p><p>  情况1：同一非终结符有多个候选式</p><p>  情况2： e和可能句型片断的后续符号相同</p><p>  但注意到，内容可能放在后面，如FIRST集合</p></blockquote><h3 id="4-3-LL-1-文法"><a href="#4-3-LL-1-文法" class="headerlink" title="4.3 LL(1)文法"></a>4.3 LL(1)文法</h3><h4 id="S-文法"><a href="#S-文法" class="headerlink" title="S_文法"></a>S_文法</h4><p>要求相当严格</p><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200404140257287.png" alt="image-20200404140257287"></p><p>（有空产生式）什么时候使用ε产生式？</p><blockquote><p>  如果当前某非终结符A与当前输入符a不匹配时，若存在A→ε，可以通过检查a是否可以出现在A的后面，来决定是否使用产生式A→ε（若文法中无A→ε ，则应报错）</p></blockquote><p>所以就有了下面的FOLLOW集合：</p><h4 id="非终结符A的后继符号集-FOLLOW"><a href="#非终结符A的后继符号集-FOLLOW" class="headerlink" title="非终结符A的后继符号集 FOLLOW"></a>非终结符A的后继符号集 FOLLOW</h4><p>可能在某个句型中紧跟在A后边的终结符a的集合，记为FOLLOW(A)</p><blockquote><p>  当A选择空语句的时候，接下来的终结符可能是什么</p></blockquote><h4 id="产生式的可选集-SELECT"><a href="#产生式的可选集-SELECT" class="headerlink" title="产生式的可选集 SELECT"></a>产生式的可选集 SELECT</h4><blockquote><p>  确定下一个字符是什么的时候可以选择</p></blockquote><p>产生式A→β的可选集是指可以选用该产生式进行推导时对应的输入符号的集合，记为SELECT( A→β )</p><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200404140719308.png" alt="image-20200404140719308"></p><p>虽然可以空串，但仍然要终结符开始：</p><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200404140745781.png" alt="image-20200404140745781"></p><h4 id="串首终结符集-FIRST"><a href="#串首终结符集-FIRST" class="headerlink" title="串首终结符集 FIRST"></a>串首终结符集 FIRST</h4><p>给定一个文法符号串α， α的串首终结符集FIRST(α)被定义为可以从α推导出的所有串首终结符构成的集合。如果α * ε，那么ε也在FIRST(α)中</p><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200404143306248.png" alt="image-20200404143306248"></p><blockquote><p>  很好理解，符号串可以推出的第一个终结符</p><p>  没空串，可选集就是串首；有，就要加上Follow减去空</p></blockquote><h4 id="LL-1-文法"><a href="#LL-1-文法" class="headerlink" title="LL(1)文法"></a>LL(1)文法</h4><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200404143034875.png" alt="image-20200404143034875"></p><blockquote><p>  和曾老师讲的内容一样，即：</p><p>  （1）不考虑ε-产生式的情况</p><p>  根据产生式的首字符进行判断，首字符不能相同</p><p>  （2）含ε-产生式的情况</p><p>  在使用ε-产生式推导时，需考虑非终结符的后续符号串的首字符；不能相同</p></blockquote><h3 id="4-4-FIRST集和FOLLOW集的计算"><a href="#4-4-FIRST集和FOLLOW集的计算" class="headerlink" title="4.4 FIRST集和FOLLOW集的计算"></a>4.4 FIRST集和FOLLOW集的计算</h3><h4 id="FIRST集合"><a href="#FIRST集合" class="headerlink" title="FIRST集合"></a>FIRST集合</h4><p>以下是符号X的集合计算：</p><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200404145838814.png" alt="image-20200404145838814"></p><blockquote><p>  注意：第二步，需要直到yk都能推出空串，才能加入空串到集合中；前面能推出空串，吧yi+1的first加入集合中</p></blockquote><p>符号串的集合计算，如下图所示：</p><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200404150037297.png" alt="image-20200404150037297"></p><h4 id="非终结符的Follow集计算"><a href="#非终结符的Follow集计算" class="headerlink" title="非终结符的Follow集计算"></a>非终结符的Follow集计算</h4><p>不断应用下列规则，直到没有新的终结符可以被加入到任何FOLLOW集合中为止：</p><ul><li>将$放入FOLLOW( S )中，其中S是开始符号，$是输入右端的结束标记</li></ul><blockquote><p>  即开始的符号，有$ 符号/初始化</p><p>   逐个产生式分析；每个产生的右部逐个非终结符分析</p></blockquote><ul><li>如果存在一个产生式A→αBβ，那么FIRST ( β )中除ε 之外的所有符号都在FOLLOW( B )中</li><li>如果存在一个产生式A→αB，或存在产生式A→αBβ且FIRST ( β ) 包含ε，那么FOLLOW( A )中的所有符号都在FOLLOW( B )中</li></ul><blockquote><p>  哈工大课程里面说要不断重试，直到不刷新</p><p>  但曾老师好像先看右部有几个符号，把相同的符号一次看完</p></blockquote><h4 id="SELECT-集合计算"><a href="#SELECT-集合计算" class="headerlink" title="SELECT 集合计算"></a>SELECT 集合计算</h4><blockquote><p>  对于表达式而言</p></blockquote><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200404155904455.png" alt="image-20200404155904455"></p><blockquote><p>  似乎可以根据 同一非终结符 的select集合是否相交推出是否 是LL(1)文法</p><p>  曾老师的课:first+集合和select差不多；根据是否相交判断文法</p></blockquote><h2 id="第五讲-语法分析2-2020-4-3"><a href="#第五讲-语法分析2-2020-4-3" class="headerlink" title="第五讲 语法分析2 2020-4-3"></a>第五讲 语法分析2 2020-4-3</h2><h3 id="4-5-递归的预测分析法"><a href="#4-5-递归的预测分析法" class="headerlink" title="4.5 递归的预测分析法"></a>4.5 递归的预测分析法</h3><blockquote><p>  有伪代码例子</p></blockquote><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200411121239298.png" alt="image-20200411121239298"></p><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200411121149410.png" alt="image-20200411121149410"></p><p>取下一个<code>token</code>来分析，</p><h3 id="4-6-非递归的预测分析法"><a href="#4-6-非递归的预测分析法" class="headerlink" title="4.6 非递归的预测分析法"></a>4.6 非递归的预测分析法</h3><blockquote><p>   下推自动机，栈的思想</p></blockquote><p>下推自动机比有穷自动机的识别能力更强，有穷自动机的识别能力不强是因为它的记忆功能不强</p><blockquote><p>  举例</p></blockquote><p>非递归的预测分析不需要为每个非终结符编写递归下降过程，而是根据预测分析表构造一个自动机，也叫表驱动的预测分析</p><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200404162400238.png" alt="image-20200404162400238"></p><h5 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h5><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200404162839493.png" alt="image-20200404162839493"></p><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200404162848783.png" alt="image-20200404162848783"></p><h3 id="4-7-预测分析中的错误处理"><a href="#4-7-预测分析中的错误处理" class="headerlink" title="4.7 预测分析中的错误处理"></a>4.7 预测分析中的错误处理</h3><p>两种错误：</p><ul><li>栈顶的终结符和当前输入符号不匹配</li><li>栈顶非终结符与当前输入符号在预测分析表对应项中的信息为空</li></ul><h4 id="恐慌模式"><a href="#恐慌模式" class="headerlink" title="恐慌模式"></a>恐慌模式</h4><ul><li>忽略输入中的一些符号，直到输入中出现由设计者选定的同步词法单元(synchronizing token)集合中的某个词法单元</li></ul><blockquote><p>  例如可以把FOLLOW(A)中的所有终结符放入非终结符A的同步记号集合</p></blockquote><ul><li>如果终结符在栈顶而不能匹配，一个简单的办法就是弹出此终结符</li></ul><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200410180512605.png" alt="image-20200410180512605"></p><h2 id="第六讲-语法分析3-2020-4-10"><a href="#第六讲-语法分析3-2020-4-10" class="headerlink" title="第六讲 语法分析3 2020-4-10"></a>第六讲 语法分析3 2020-4-10</h2><h3 id="4-8-自底向上的语法分析"><a href="#4-8-自底向上的语法分析" class="headerlink" title="4-8 自底向上的语法分析"></a>4-8 自底向上的语法分析</h3><ul><li><p>从分析树的底部(叶节点)向顶部(根节点)方向构造分析树</p></li><li><p>可以看成是将输入串w归约为文法开始符号S的过程</p></li><li><p>自顶向下的语法分析采用最左推导方式<br>自底向上的语法分析采用最左归约方式（反向构造最右推导）</p></li><li><p>自底向上语法分析的通用框架：移入-归约分析(Shift-Reduce Parsing)</p></li></ul><h4 id="移入-归约分析器"><a href="#移入-归约分析器" class="headerlink" title="移入-归约分析器"></a>移入-归约分析器</h4><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200410184846731.png" alt="image-20200410184846731"></p><h4 id="移入-归约分析中存在的问题"><a href="#移入-归约分析中存在的问题" class="headerlink" title="移入-归约分析中存在的问题"></a>移入-归约分析中存在的问题</h4><ul><li>错误地识别了句柄</li></ul><h3 id="4-9-LR-分析法概述"><a href="#4-9-LR-分析法概述" class="headerlink" title="4-9 LR 分析法概述"></a>4-9 LR 分析法概述</h3><p>L: 对输入进行从左到右的扫描<br>R: 反向构造出一个最右推导序列</p><ul><li>LR(k)分析<br>需要向前查看k个输入符号的LR分析</li></ul><blockquote><p>  k = 0 和k = 1 这两种情况具有实践意义<br>  当省略(k)时，表示k =1</p></blockquote><h4 id="LR-分析法的基本原理"><a href="#LR-分析法的基本原理" class="headerlink" title="LR 分析法的基本原理"></a>LR 分析法的基本原理</h4><ul><li>自底向上分析的关键问题是什么？</li></ul><p>如何正确地识别句柄</p><ul><li>句柄是逐步形成的，用“状态”表示句柄识别的进展程度</li></ul><h4 id="LR-分析器（自动机）的总体结构"><a href="#LR-分析器（自动机）的总体结构" class="headerlink" title="LR 分析器（自动机）的总体结构"></a>LR 分析器（自动机）的总体结构</h4><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200410210053928.png" alt="image-20200410210053928"></p><h4 id="LR-分析表的结构"><a href="#LR-分析表的结构" class="headerlink" title="LR 分析表的结构"></a>LR 分析表的结构</h4><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200410210115484.png" alt="image-20200410210115484"></p><p>注意：</p><ul><li><p>规约的时候 当前状态出栈、符号出栈、新符号入栈；接下来要根据新的状态栈顶状态goto新状态；</p></li><li><p>似乎一个符号都会对应一个状态，规约的时候出去几个符号，就出去几个状态</p></li></ul><h4 id="LR-分析器的工作过程"><a href="#LR-分析器的工作过程" class="headerlink" title="LR 分析器的工作过程"></a>LR 分析器的工作过程</h4><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200410211257748.png" alt="image-20200410211257748"></p><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200410211309966.png" alt="image-20200410211309966" style="zoom: 80%;"></p><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200410211338050.png" alt="image-20200410211338050"></p><h4 id="LR-分析算法"><a href="#LR-分析算法" class="headerlink" title="LR 分析算法"></a>LR 分析算法</h4><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200410211412609.png" alt="image-20200410211412609"></p><blockquote><p>  算法简单、主要是构建分析表复杂</p></blockquote><h3 id="4-10-LR-0-分析"><a href="#4-10-LR-0-分析" class="headerlink" title="4-10 LR(0)分析"></a>4-10 LR(0)分析</h3><h4 id="LR-0-项目"><a href="#LR-0-项目" class="headerlink" title="LR(0) 项目"></a>LR(0) 项目</h4><p>右部某位置标有圆点的产生式称为相应文法的一个LR(0)项目（简称为项目）</p><h4 id="增广文法"><a href="#增广文法" class="headerlink" title="增广文法"></a>增广文法</h4><p>如果G 是一个以S为开始符号的文法，则G的增广文法G’ 就是在G中加上新开始符号S’ 和产生式S’ → S而得到的文法</p><blockquote><p>  引入这个新的开始产生式的目的是使得文法开始符号仅出现在一个产生式的左边，从而使得分析器只有一个接受状态</p></blockquote><h4 id="文法中的项目"><a href="#文法中的项目" class="headerlink" title="文法中的项目"></a>文法中的项目</h4><h5 id="后继项目"><a href="#后继项目" class="headerlink" title="后继项目"></a>后继项目</h5><p>同属于一个产生式的项目，但圆点的位置只相差一个符号，则称后者是前者的后继项目</p><p>A→α· Xβ的后继项目是A→αX·β</p><p>可以把等价的项目组成一个项目集( I ) ，称为项目集闭包(Closure of Item Sets)，每个项目集闭包对应着自动机的一个状态</p><h4 id="举例：构造LR-0-自动机"><a href="#举例：构造LR-0-自动机" class="headerlink" title="举例：构造LR(0)自动机"></a>举例：构造LR(0)自动机</h4><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200410213749916.png" alt="image-20200410213749916"></p><h3 id="4-11-LR-0-分析表的构造"><a href="#4-11-LR-0-分析表的构造" class="headerlink" title="4-11 LR(0)分析表的构造"></a>4-11 LR(0)分析表的构造</h3><h4 id="CLOSURE-函数"><a href="#CLOSURE-函数" class="headerlink" title="CLOSURE( )函数"></a>CLOSURE( )函数</h4><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200411190418423.png" alt="image-20200411190418423"></p><blockquote><p>很好理解：期待B，那么B的产生式就进来，（点在前面</p></blockquote><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200411190532412.png" alt="image-20200411190532412"></p><blockquote><p>  求等价状态的集合</p></blockquote><h4 id="GOTO-函数"><a href="#GOTO-函数" class="headerlink" title="GOTO ( )函数"></a>GOTO ( )函数</h4><p>返回项目集I对应于文法符号X的后继项目集闭包</p><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200411190614356.png" alt="image-20200411190614356"></p><p>X的后继项目 集合；再求闭包</p><blockquote><p>  也就是在求后继项目集合，然后还需要求闭包</p></blockquote><h4 id="规范LR-0-项集族"><a href="#规范LR-0-项集族" class="headerlink" title="规范LR(0) 项集族"></a>规范LR(0) 项集族</h4><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200411190952175.png" alt="image-20200411190952175"></p><blockquote><p>  这样就出来了很多个项目集，就是不同的状态集</p></blockquote><h4 id="LR-0-分析表构造算法"><a href="#LR-0-分析表构造算法" class="headerlink" title="LR(0)分析表构造算法"></a>LR(0)分析表构造算法</h4><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200411191129405.png" alt="image-20200411191129405"></p><blockquote><p>  先求出项集族；然后再填表：action；goto；规约；acc</p></blockquote><h4 id="LR-0-分析过程中的冲突"><a href="#LR-0-分析过程中的冲突" class="headerlink" title="LR(0) 分析过程中的冲突"></a>LR(0) 分析过程中的冲突</h4><ul><li>移进/归约冲突</li></ul><p>即有移进又有规约</p><ul><li>归约/归约冲突</li></ul><p>多种规约</p><blockquote><p>  接下来的算法解决这些问题</p></blockquote><h2 id="第七讲-语法分析4-2020-4-11"><a href="#第七讲-语法分析4-2020-4-11" class="headerlink" title="第七讲 语法分析4 2020-4-11"></a>第七讲 语法分析4 2020-4-11</h2><h3 id="4-12-SLR分析"><a href="#4-12-SLR分析" class="headerlink" title="4-12 SLR分析"></a>4-12 SLR分析</h3><blockquote><p>  归根结底，正确识别句柄</p></blockquote><h4 id="SLR分析法的基本思想"><a href="#SLR分析法的基本思想" class="headerlink" title="SLR分析法的基本思想"></a>SLR分析法的基本思想</h4><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200411191910317.png" alt="image-20200411191910317"></p><blockquote><p>  也叫SLR(1)；因为1可以省略，也叫SLR</p><p>  多看一个符号，根据下一个符号，仅用FOLLOW集合就可以判断是否规约</p></blockquote><h4 id="SLR分析表"><a href="#SLR分析表" class="headerlink" title="SLR分析表"></a>SLR分析表</h4><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200411204902385.png" alt="image-20200411204902385"></p><blockquote><p>  有点不同，黄色行，本来LR(0)是全r的，规约；现在有的要继续移入</p></blockquote><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200411205434054.png" alt="image-20200411205434054"></p><blockquote><p>  移入的地方变成规约；规约主要是由空产生式规约</p></blockquote><h4 id="SLR-分析表构造算法"><a href="#SLR-分析表构造算法" class="headerlink" title="SLR 分析表构造算法"></a>SLR 分析表构造算法</h4><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200411205841591.png" alt="image-20200411205841591"></p><blockquote><p>  也就是看下一个字符是否规约；因为如果规约，下个字符那么必在follow集合中；否则不在</p></blockquote><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200411213452666.png" alt="image-20200411213452666"></p><h4 id="SLR-分析中的冲突"><a href="#SLR-分析中的冲突" class="headerlink" title="SLR 分析中的冲突"></a>SLR 分析中的冲突</h4><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200411213724444.png" alt="image-20200411213724444"></p><h3 id="4-13-LR-1-分析"><a href="#4-13-LR-1-分析" class="headerlink" title="4-13 LR(1)分析"></a>4-13 LR(1)分析</h3><h4 id="LR-1-分析法的提出"><a href="#LR-1-分析法的提出" class="headerlink" title="LR(1)分析法的提出"></a>LR(1)分析法的提出</h4><p>SLR分析存在的问题</p><blockquote><p>  SLR只是简单地考察下一个输入符号b是否属于与归约项目A→α相关联的FOLLOW(A)，但b∈FOLLOW(A)只是归约α的一个必要条件，而非充分条件</p></blockquote><p>对于产生式A→α的归约，在不同使用位置，A会要求不同的后继符号</p><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200411215122958.png" alt="image-20200411215122958"></p><p>在特定位置，A的后继符集合是FOLLOW(A)的子集</p><h4 id="规范LR-1-项目"><a href="#规范LR-1-项目" class="headerlink" title="规范LR(1)项目"></a>规范LR(1)项目</h4><p>将一般形式为[A→α·β, a]的项称为LR(1) 项，其中A→αβ 是一个产生式，a 是一个终结符(这里将$视为一个特殊的终结符)它表示在当前状态下，A后面必须紧跟的终结符，称为该项的展望符(lookahead)</p><ul><li>LR(1) 中的1指的是项的第二个分量的长度</li></ul><blockquote><p>  LR(k)向前展望k个符号</p></blockquote><ul><li>在形如[A→α·β, a]且β ≠ ε的项中，展望符a没有任何作用</li></ul><blockquote><p>  移入项目、待约项目是没有任何作用的</p></blockquote><ul><li>但是一个形如[A→α·, a]的项在只有在下一个输入符号等于a时才可以按照A→α 进行归约</li></ul><blockquote><p>  这样的a的集合总是FOLLOW(A)的子集，而且它通常是一个真子集</p></blockquote><h4 id="等价LR-1-项目"><a href="#等价LR-1-项目" class="headerlink" title="等价LR(1)项目"></a>等价LR(1)项目</h4><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200411224525016.png" alt="image-20200411224525016"></p><blockquote><p>  也就是说 ，有非终结符 就要加入等价项目</p></blockquote><h4 id="举例-2"><a href="#举例-2" class="headerlink" title="举例"></a>举例</h4><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200411224541548.png" alt="image-20200411224541548"></p><blockquote><p>  有些状态有相同的项目，但是状态中的语句数目等不同、展望符不同，不是同一个状态，如10、8</p><p>  LR(0)：规约状态就规约</p><p>  SLR：下一个字符在FOLLOW集才能规约</p><p>  LR(1)：与展望符相同才能规约，Follow集的子集</p></blockquote><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200411225424852.png" alt="image-20200411225424852"></p><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200411225515536.png" alt="image-20200411225515536"></p><h4 id="CLOSURE、goto函数变化"><a href="#CLOSURE、goto函数变化" class="headerlink" title="CLOSURE、goto函数变化"></a>CLOSURE、goto函数变化</h4><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200411230156797.png" alt="image-20200411230156797"></p><blockquote><p>  强调：对于展望符，可以理解为规约时的条件，即，下个字符是什么；只有对规约项目有意义</p></blockquote><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200411230313391.png" alt="image-20200411230313391"></p><h4 id="LR分析表构造算法"><a href="#LR分析表构造算法" class="headerlink" title="LR分析表构造算法"></a>LR分析表构造算法</h4><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200411225704858.png" alt="image-20200411225704858"></p><h3 id="4-14-LALR分析"><a href="#4-14-LALR分析" class="headerlink" title="4-14 LALR分析"></a>4-14 LALR分析</h3><h2 id="第八讲-语法制导翻译1-2020-4-23"><a href="#第八讲-语法制导翻译1-2020-4-23" class="headerlink" title="第八讲 语法制导翻译1 2020-4-23"></a>第八讲 语法制导翻译1 2020-4-23</h2><h3 id="5-1-语法制导翻译概述"><a href="#5-1-语法制导翻译概述" class="headerlink" title="5-1 语法制导翻译概述"></a>5-1 语法制导翻译概述</h3><h4 id="什么是语法制导翻译"><a href="#什么是语法制导翻译" class="headerlink" title="什么是语法制导翻译"></a>什么是语法制导翻译</h4><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200423131037338.png" alt="image-20200423131037338"></p><h4 id="语法制导翻译的基本思想"><a href="#语法制导翻译的基本思想" class="headerlink" title="语法制导翻译的基本思想"></a>语法制导翻译的基本思想</h4><p>为CFG中的文法符号设置语义属性，用来表示语法成分对应的语义信息</p><p>文法符号的语义属性值是用与文法符号所在产生式（语法规则）相关联的语义规则来计算的</p><p>对于给定的输入串x ，构建x的语法分析树，并利用与产生式（语法规则）相关联的语义规则来计算分析树中各结点对应的语义属性值</p><h4 id="两个概念"><a href="#两个概念" class="headerlink" title="两个概念"></a>两个概念</h4><p>将语义规则同语法规则（产生式）联系起来要涉及两个概念</p><ul><li><p>语法制导定义(Syntax-Directed Definitions, SDD )</p></li><li><p>语法制导翻译方案(Syntax-Directed Translation Scheme , SDT )</p></li></ul><h4 id="语法制导定义-SDD"><a href="#语法制导定义-SDD" class="headerlink" title="语法制导定义(SDD)"></a>语法制导定义(SDD)</h4><p>SDD是对CFG的推广</p><ul><li><p>将每个文法符号和一个语义属性集合相关联</p></li><li><p>将每个产生式和一组语义规则相关联，这些规则用于计算该产生式中各文法符号的属性值</p></li></ul><p>例：如果X是一个文法符号，a是X的一个属性，则用X.a表示属性a在某个标号为X的分析树结点上的值</p><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200423131708248.png" alt="image-20200423131708248"></p><h4 id="语法制导翻译方案-SDT"><a href="#语法制导翻译方案-SDT" class="headerlink" title="语法制导翻译方案(SDT)"></a>语法制导翻译方案(SDT)</h4><p>SDT是在产生式右部嵌入了程序片段的CFG，这些程序片段称为<strong>语义动作</strong>。</p><p>按照惯例，语义动作放在花括号内</p><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200423131811998.png" alt="image-20200423131811998"></p><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200423131918185.png" alt="image-20200423131918185"></p><h3 id="5-2-语法制导定义SDD"><a href="#5-2-语法制导定义SDD" class="headerlink" title="5-2 语法制导定义SDD"></a>5-2 语法制导定义SDD</h3><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200423131956018.png" alt="image-20200423131956018"></p><h4 id="综合属性-synthesized-attribute"><a href="#综合属性-synthesized-attribute" class="headerlink" title="综合属性(synthesized attribute)"></a>综合属性(synthesized attribute)</h4><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200423132027206.png" alt="image-20200423132027206"></p><h4 id="继承属性-inherited-attribute"><a href="#继承属性-inherited-attribute" class="headerlink" title="继承属性(inherited attribute)"></a>继承属性(inherited attribute)</h4><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200423132051536.png" alt="image-20200423132051536"></p><h4 id="举例-3"><a href="#举例-3" class="headerlink" title="举例"></a>举例</h4><blockquote><p>  算术表达式</p></blockquote><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200423132128113.png" alt="image-20200423132128113"></p><blockquote><p>  声明语句</p></blockquote><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200423132133635.png" alt="image-20200423132133635"></p><h4 id="属性文法-Attribute-Grammar"><a href="#属性文法-Attribute-Grammar" class="headerlink" title="属性文法(Attribute Grammar)"></a>属性文法(Attribute Grammar)</h4><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200423132257281.png" alt="image-20200423132257281"></p><blockquote><p>  没有副作用的？</p></blockquote><h3 id="5-3-SDD的求值顺序"><a href="#5-3-SDD的求值顺序" class="headerlink" title="5-3 SDD的求值顺序"></a>5-3 SDD的求值顺序</h3><p>SDD为CFG中的文法符号设置语义属性。对于给定的输入串x，应用语义规则计算分析树中各结点对应的属性值</p><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200423132754444.png" alt="image-20200423132754444"></p><h4 id="依赖图-Dependency-Graph"><a href="#依赖图-Dependency-Graph" class="headerlink" title="依赖图(Dependency Graph)"></a>依赖图(Dependency Graph)</h4><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200423133014978.png" alt="image-20200423133014978"></p><blockquote><p>  综合属性在右边，继承属性在左边</p><p>  虚节点：</p></blockquote><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200423133102255.png" alt="image-20200423133102255"></p><h4 id="属性值的计算顺序"><a href="#属性值的计算顺序" class="headerlink" title="属性值的计算顺序"></a>属性值的计算顺序</h4><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200423133325543.png" alt="image-20200423133325543"></p><blockquote><p>  排序不止一种</p></blockquote><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200423133335976.png" alt="image-20200423133335976"></p><p>对于只具有综合属性的SDD ，可以按照任何自底向上的顺序计算它们的值</p><p>对于同时具有继承属性和综合属性的SDD，不能保证存在一个顺序来对各个节点上的属性进行求值</p><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200423133526296.png" alt="image-20200423133526296"></p><blockquote><p>  这里的前两点 不是很懂，但似乎不影响</p><p>  期望的是自顶向下的实现</p></blockquote><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200423133804545.png" alt="image-20200423133804545"></p><h3 id="5-4-S-属性定义与L-属性定义"><a href="#5-4-S-属性定义与L-属性定义" class="headerlink" title="5-4 S-属性定义与L-属性定义"></a>5-4 S-属性定义与L-属性定义</h3><h4 id="S-属性定义"><a href="#S-属性定义" class="headerlink" title="S-属性定义"></a>S-属性定义</h4><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200423133948671.png" alt="image-20200423133948671"></p><blockquote><p>  LR？</p></blockquote><h4 id="L-属性定义"><a href="#L-属性定义" class="headerlink" title="L-属性定义"></a>L-属性定义</h4><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200423134007809.png" alt="image-20200423134007809"></p><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200423134031790.png" alt="image-20200423134031790"></p><p>S-SDD只有综合属性，L-SDD没有限制综合属性</p><blockquote><p>  依赖的只有三种：</p><p>  父亲的继承属性、左边的属性、本身的属性</p></blockquote><p>A为什么不能是综合属性？</p><p>会造成循环依赖</p><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200423135338493.png" alt="image-20200423135338493"></p><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200423135431601.png" alt="image-20200423135431601"></p><h2 id="第九讲-语法制导翻译2-2020-4-23"><a href="#第九讲-语法制导翻译2-2020-4-23" class="headerlink" title="第九讲 语法制导翻译2 2020-4-23"></a>第九讲 语法制导翻译2 2020-4-23</h2><h3 id="5-5-语法制导翻译方案SDT"><a href="#5-5-语法制导翻译方案SDT" class="headerlink" title="5-5 语法制导翻译方案SDT"></a>5-5 语法制导翻译方案SDT</h3><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200423140556226.png" alt="image-20200423140556226"></p><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200423140615425.png" alt="image-20200423140615425"></p><h4 id="将S-SDD转换为SDT"><a href="#将S-SDD转换为SDT" class="headerlink" title="将S-SDD转换为SDT"></a>将S-SDD转换为SDT</h4><p>子节点都是综合属性，所以要放在最后</p><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200423140903983.png" alt="image-20200423140903983"></p><blockquote><p>  当规约发生的时候，执行语法动作</p><p>  需要扩展分析栈</p></blockquote><h4 id="将L-SDD转换为SDT"><a href="#将L-SDD转换为SDT" class="headerlink" title="将L-SDD转换为SDT"></a>将L-SDD转换为SDT</h4><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200423141602795.png" alt="image-20200423141602795"></p><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200423141613738.png" alt="image-20200423141613738"></p><h4 id="L-属性定义的SDT-实现"><a href="#L-属性定义的SDT-实现" class="headerlink" title="L-属性定义的SDT 实现"></a>L-属性定义的SDT 实现</h4><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200423142808970.png" alt="image-20200423142808970"></p><blockquote><p>  可以通过三种方式实现：</p><p>  前两种都是LL分析类型，LL文法</p><p>  最后是LR分析过程中翻译</p></blockquote><h3 id="5-6-在非递归的预测分析过程中进行翻译"><a href="#5-6-在非递归的预测分析过程中进行翻译" class="headerlink" title="5-6 在非递归的预测分析过程中进行翻译"></a>5-6 在非递归的预测分析过程中进行翻译</h3><blockquote><p>  L-SDD 的非递归实现，是自顶向下的方法</p></blockquote><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200423142929394.png" alt="image-20200423142929394"></p><blockquote><p>  例子：待续</p></blockquote><h2 id="第十讲-语法制导翻译3-2020-4-23"><a href="#第十讲-语法制导翻译3-2020-4-23" class="headerlink" title="第十讲 语法制导翻译3 2020-4-23"></a>第十讲 语法制导翻译3 2020-4-23</h2><h3 id="5-7-在递归的预测分析过程进行翻译"><a href="#5-7-在递归的预测分析过程进行翻译" class="headerlink" title="5-7 在递归的预测分析过程进行翻译"></a>5-7 在递归的预测分析过程进行翻译</h3><blockquote><p>  非终结符的过程进行扩展，与递归下降分析法对于</p></blockquote><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200423144842938.png" alt="image-20200423144842938"></p><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200423144858629.png" alt="image-20200423144858629"></p><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200423144904356.png" alt="image-20200423144904356"></p><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200423144910379.png" alt="image-20200423144910379"></p><h4 id="算法："><a href="#算法：" class="headerlink" title="算法："></a>算法：</h4><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200423144956734.png" alt="image-20200423144956734"></p><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200423150937355.png" alt="image-20200423150937355"></p><h3 id="5-8-L-属性定义的自底向上翻译"><a href="#5-8-L-属性定义的自底向上翻译" class="headerlink" title="5-8 L-属性定义的自底向上翻译"></a>5-8 L-属性定义的自底向上翻译</h3><blockquote><p>  毫无疑问：S-SDD 可以直接自底向上</p></blockquote><p>给定一个以LL文法为基础的L-SDD，可以修改这个文法，并在LR语法分析过程中计算这个新文法之上的SDD</p><blockquote><p>  也就是说LL文法，通过LR语法分析来建立SDD</p><p>  方法：就是替换；空产生式；</p><p>  我们会发现用到的属性不在产生式中，但LR用的是栈，可以找到</p><p>  举例：带续：</p></blockquote><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200423151156097.png" alt="image-20200423151156097"></p><h2 id="第十一讲-中间代码生成1"><a href="#第十一讲-中间代码生成1" class="headerlink" title="第十一讲 中间代码生成1"></a>第十一讲 中间代码生成1</h2>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编译器 </tag>
            
            <tag> 慕课 </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简单搜索引擎</title>
      <link href="/2020/06/26/SearchEngine/%E7%AE%80%E5%8D%95%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/"/>
      <url>/2020/06/26/SearchEngine/%E7%AE%80%E5%8D%95%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/</url>
      
        <content type="html"><![CDATA[<h1 id="简单搜索引擎"><a href="#简单搜索引擎" class="headerlink" title="简单搜索引擎"></a>简单搜索引擎</h1><blockquote><p>  来源：搜索引擎技术基础大作业</p><p>  地址：<a href="https://github.com/chen2511/SimpleSearchEngine">https://github.com/chen2511/SimpleSearchEngine</a></p></blockquote><h2 id="一、-概述"><a href="#一、-概述" class="headerlink" title="一、  概述"></a>一、  概述</h2><p>互联网信息复杂多样，因此想要迅速、快捷的找到所需要的信息内容，就需要搜索引擎来帮忙实现。</p><p>第一个现在意义上的搜索引擎是1994年Michael Mauldin创建的Lycos。是在网络爬虫的基础上加上索引程序，采用网络、数据库等关键技术来实现，检索速度也非常慢。</p><p>第二个阶段是1996年到1998年,这个期间,搜索引擎采用分布式检索方案,使用多个微型计算机来协同工作,其目的是为了提高数据规模和响应速度。一般可以响应千万次的用户检索请求。第三代搜索引擎,就当前所使用的搜索引擎,也是搜索引擎极为繁荣的时期。它拥有完整的索引数据库，除了一般的搜索，还有主题搜索和地域搜索。</p><p>​    本系统以西北工业大学的工大要闻为目标，使用python简单实现了搜索引擎的三个部分：网页搜集、对搜集网页的预处理、查询服务。并能满足其基本要求：在可以接受的时间内，输入一个查询词，输出符合条件的网页列表。</p><p><img src="/2020/06/26/SearchEngine/%E7%AE%80%E5%8D%95%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/image-20210511015317882.png" alt="搜索引擎简单体系结构"></p><h2 id="二、-页面获取与解析"><a href="#二、-页面获取与解析" class="headerlink" title="二、  页面获取与解析"></a>二、  页面获取与解析</h2><h3 id="2-1-理论基础"><a href="#2-1-理论基础" class="headerlink" title="2.1 理论基础"></a>2.1 理论基础</h3><p><strong>搜索引擎的页面获取流程如下：</strong></p><p>1、首先选取一部分精心挑选的种子URL，将这些URL放入待抓取URL队列</p><p>2、从待抓取URL队列中取出待抓取在URL</p><p>3、解析DNS，并且得到主机的ip</p><p>456、将URL对应的网页下载下来，存储进已下载网页库中</p><p>79、分析页面中的其他URL，并且将URL放入待抓取URL队列，从而进入下一个循环</p><p>8、将这些URL放进已抓取URL队列</p><p><img src="/2020/06/26/SearchEngine/%E7%AE%80%E5%8D%95%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/image-20210511015527220.png" alt="搜索引擎页面获取流程图"></p><h3 id="2-2-实践"><a href="#2-2-实践" class="headerlink" title="2.2 实践"></a>2.2 实践</h3><p>相关代码位于：<code>spider.py</code></p><p>本程序的搜集流程：挑选工大要闻的某些新闻列表页，作为种子；之后获取种子url的页面，分析其中存在的url（新闻）并加入待爬取列表（考虑不爬取过多页面，只爬取两级），然后再爬取列表里的所有url，之后再进行保存等。</p><p><img src="/2020/06/26/SearchEngine/%E7%AE%80%E5%8D%95%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/image-20210511015606901.png" alt="种子页面"></p><p>首先是页面内容获取，本程序借助的是模拟浏览器。下载chrome相关驱动程序，配合python selenium 包，即可完成页面内容获取。</p><p>部分代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 模拟浏览器，使用谷歌浏览器，将chromedriver.exe复制到谷歌浏览器的文件夹内</span></span><br><span class="line">chromedriver = <span class="string">r&quot;C:\Program Files (x86)\Google\Chrome\Application\chromedriver.exe&quot;</span></span><br><span class="line"><span class="comment"># 设置浏览器</span></span><br><span class="line">os.environ[<span class="string">&quot;webdriver.chrome.driver&quot;</span>] = chromedriver</span><br><span class="line">browser = webdriver.Chrome(chromedriver)</span><br><span class="line">browser.get(url_seed)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这样就获得了相应<code>url_seed</code>的原始网页。</p><p><img src="/2020/06/26/SearchEngine/%E7%AE%80%E5%8D%95%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/image-20210511015652536.png" alt="浏览器模拟器应用举例"></p><p>在获取到种子页面的内容后，需要解析其中存在的url（二级url），并加入待爬取列表，以便下一遍爬取。</p><p>​    解析html页面的内容可以通过xpath来解析，从而获得其中的url。</p><p>​    页面中某篇新闻对应的url所在位置如下图所示。</p><p><img src="/2020/06/26/SearchEngine/%E7%AE%80%E5%8D%95%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/image-20210511015710560.png" alt="某篇新闻对应的url在html中的位置"></p><p>实现方法如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">    path = <span class="string">&#x27;//*[@id=&quot;line_u12_&#x27;</span> + <span class="built_in">str</span>(i) + <span class="string">&#x27;&quot;]/div[2]/a&#x27;</span></span><br><span class="line">    url = browser.find_element_by_xpath(path).get_attribute(<span class="string">&#x27;href&#x27;</span>)</span><br><span class="line">    <span class="comment"># 如果未访问过，则加入url列表</span></span><br><span class="line">    <span class="keyword">if</span>(check_curent_visited(url)):</span><br><span class="line">        urls.append(url)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>首先可以通过在浏览器查看元素的界面中，右击相关元素可以获得其对应的xpath路径，通过<code>find_element_by_xpath</code>方法，即可在python代码中获得相关元素的内容，但是url是一个属性，则需要再次调用其get_attribute即可获得url。仍需注意，这里的url在浏览器中显示的是相对路径，但python提供的方法返回的是绝对路径。</p><p>​    不能将上一步获得的url直接加入待爬取列表中，还有很重要的一步，是检查页面是否已经被爬取过。使用一个词典记录新闻页是否已经被爬取，词典的键为url的序号（本来应该是url的哈希值，但注意到页面不多，且有规律，键值仅仅是url末尾的编号，值则是0或1，用来表示该url是否被访问过）。该词典通过读取<code>visited-set.json</code>文件初始化，再获取页面过程结束后，写回到<code>visited-set.json</code>文件。</p><p>​    具体见<code>spider.py</code>的<code>load.dic()</code>、<code>check_curent_visited(url)</code>和<code>save_dic()</code>方法。</p><p>​    最后再对获取到的所有url进行爬取，即完成了页面获取的全部内容。</p><h2 id="三、-页面存储"><a href="#三、-页面存储" class="headerlink" title="三、  页面存储"></a>三、  页面存储</h2><h3 id="3-1-网页信息存储的格式"><a href="#3-1-网页信息存储的格式" class="headerlink" title="3.1 网页信息存储的格式"></a>3.1 网页信息存储的格式</h3><p>将获取网页信息保存在磁盘中，需要按照规定的格式保存，便于后续处理和提供服务。这里的存储格式只是顺序保存网页信息，没有索引文件。</p><p>原始网页库（raw.txt）由若干记录组成，每个记录包含一个网页的原始数据，记录的存放是顺序追加的，记录之间没有分隔符；</p><p>每条记录由头部、数据和空行组成，顺序是：头部 + 空行 + 数据 + 空行；（html文件中有空行）</p><p>​    具体效果下图所示：</p><p><img src="/2020/06/26/SearchEngine/%E7%AE%80%E5%8D%95%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/image-20210511015817593.png" alt="原始网页库的最终效果"></p><p>具体见<code>spider.py</code>的<code>save_raw_page(data, rawfile, url)</code>方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">save_raw_page</span>(<span class="params">data, rawfile, url</span>):</span><br><span class="line">    <span class="comment"># data.replace(&#x27;\n&#x27;, &#x27;&#x27;)</span></span><br><span class="line">    rawfile.write(<span class="string">&#x27;\nversion: 1.0\n&#x27;</span>)</span><br><span class="line">    rawfile.write(<span class="string">&#x27;url: &#x27;</span> + url + <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    rawfile.write(<span class="string">&#x27;date: &#x27;</span> + time.strftime(<span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>, time.localtime()) + <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    rawfile.write(<span class="string">&#x27;length: &#x27;</span> + <span class="built_in">str</span>(<span class="built_in">len</span>(data)) + <span class="string">&#x27;\n\n&#x27;</span>)</span><br><span class="line">    rawfile.write(<span class="built_in">str</span>(data)) </span><br><span class="line">    <span class="comment"># 当前文件指针所在位置</span></span><br><span class="line">    <span class="comment"># print(rawfile.tell())</span></span><br><span class="line">    rawfile.write(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> rawfile.tell()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>值得一提的是，为了便于生成索引网页库，写完内容之后会返回当前的文件指针。</p><h3 id="3-2-建立索引网页库"><a href="#3-2-建立索引网页库" class="headerlink" title="3.2 建立索引网页库"></a>3.2 建立索引网页库</h3><p>至此，我们体系结构中的第一部分全部完成；下面将开始数据处理部分。首先是建立索引网页库：</p><p>索引网页库的任务就是完成给定一个 URL，在原始网页库中定位到该 URL 所指向的记录。如果不建立索引信息，只能通过顺序查找的方法，查找指定的记录，这样会消耗大量的I/O，数据量增大的时候不能够满足搜索引擎的快速响应要求。</p><p>​    所以我们一共建立两个文件：网页索引文件和URL索引文件。</p><p>​    网页索引文件：以 ISAM（索引顺序访问模式）存储，其中每一行不记录文档长度，因为文档长度可以通过后续文档起始位置的偏移和当前文档其位置的偏移的差获得。为了保证对最大文档号数据读取的一致性，在最后一行增加“哨兵”，它不对应实际的文档数据，其中文档摘要为空，表示文档索引的结束。如下图所示：</p><p><img src="/2020/06/26/SearchEngine/%E7%AE%80%E5%8D%95%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/image-20210511015859855.png" alt="网页索引文件：pageIndex.json"></p><p>URL索引文件：以 ISAM 存储，包含了 URL 的摘要和文档编号。为了能够快速的对给定 url 找到对应的文档编号，按照 URL摘要排序。</p><p><img src="/2020/06/26/SearchEngine/%E7%AE%80%E5%8D%95%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/image-20210511015923418.png" alt="URL索引文件：urlIndex.json"></p><p><strong>代码实现：</strong></p><p>​    首先是哈希值的计算：见<code>spider.py</code>的<code>get_md5()</code>方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_md5</span>(<span class="params">data</span>):</span><br><span class="line">    <span class="comment"># 应用MD5算法</span></span><br><span class="line">    md5 = hashlib.md5()</span><br><span class="line">    md5.update(data.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">    <span class="keyword">return</span> md5.hexdigest()</span><br></pre></td></tr></table></figure><p>输入字符串返回hash值</p><p>网页索引：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 原始网页索引列表添加新项</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">append_pageIndex</span>(<span class="params">data, cnt, index</span>):</span><br><span class="line">    data_md5 = get_md5(data)</span><br><span class="line"></span><br><span class="line">    pageIndex[-<span class="number">1</span>][<span class="string">&#x27;md5&#x27;</span>] = data_md5</span><br><span class="line">    <span class="comment">#pageIndex[-1][&#x27;pagelen&#x27;] = len(data)</span></span><br><span class="line">    pageIndex.append(&#123;<span class="string">&#x27;No&#x27;</span>: cnt, <span class="string">&#x27;offset&#x27;</span>:index, <span class="string">&#x27;md5&#x27;</span>: <span class="literal">None</span>&#125;)</span><br></pre></td></tr></table></figure><p>url索引：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 原始网页url索引列表添加新项</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">append_urlIndex</span>(<span class="params">url, cnt</span>):</span><br><span class="line">    url_md5 = get_md5(url)</span><br><span class="line">    urlIndex.append(&#123;<span class="string">&#x27;url&#x27;</span>:url_md5, <span class="string">&#x27;No&#x27;</span>:cnt&#125;)</span><br></pre></td></tr></table></figure><p>最后要对url索引列表根据url的hash值排序，加速查找速度。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">save_json(pageIndex, <span class="string">&#x27;pageIndex.json&#x27;</span>)</span><br><span class="line">   save_json(urlIndex, <span class="string">&#x27;urlIndex.json&#x27;</span>)</span><br></pre></td></tr></table></figure><p>最近结果保存到json格式的文件中。</p><h2 id="四、-页面解析"><a href="#四、-页面解析" class="headerlink" title="四、  页面解析"></a>四、  页面解析</h2><p>部分页面解析的内容在前面已经提到过，如获取网页中存在的URL。所以该部分内容还包括：网页编码识别和获取标题。</p><p>​    切词前需要识别网页的编码，编码格式不对，导致切出来的词没有意义。</p><p>我们可以在网页内容中得到网页的编码格式，即从http返回的head信息中的charset域得到，如下图所示：</p><p><img src="/2020/06/26/SearchEngine/%E7%AE%80%E5%8D%95%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/image-20210511020143019.png" alt="网页编码识别"></p><p>​    获取标题是显示结果时需要的必须步骤，本程序使用的是<code>BeautifulSoup</code>包来解析。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">soup = BeautifulSoup(data, <span class="string">&#x27;html.parser&#x27;</span>)</span><br><span class="line">title = soup.find(<span class="string">&quot;title&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="五、-切词"><a href="#五、-切词" class="headerlink" title="五、  切词"></a>五、  切词</h2><p>生成了所以网页库之后，需要分析网页，并进行分词。分词是网页分析的前提。</p><p>分词方法是按照一定的策略将待分析的汉字串与一个充分大的词典中的词条进行匹配，若在词典中找到某个字符串，则匹配成功。按照扫描方向不同，串匹配分词方法可以分为：正向匹配和逆向匹配。按照匹配长度可以分为最长/最大匹配和最短/最小匹配。</p><p><img src="/2020/06/26/SearchEngine/%E7%AE%80%E5%8D%95%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/image-20210511020220576.png" alt="数据处理流程"></p><p>本程序使用的是结巴分词。<code>jieba</code>是一个基于Python的中文分词工具。对于一长段文字，其分词原理大体可分为三步：</p><p>1.首先用正则表达式将中文段落粗略的分成一个个句子。</p><p>2.将每个句子构造成有向无环图，之后寻找最佳切分方案。</p><p>3.最后对于连续的单字，采用<code>HMM</code>模型将其再次划分</p><p><strong>程序实现：</strong></p><p>​    首先结合网页索引从原始网页库中读取一篇篇原始网页，逐网页进行分析。读取到一篇网页之后，根据正则表达式找出其中的中文内容，之后对这些内容进行切词，根据得到的切词结果，进一步构造倒排文件。</p><p><strong>部分代码如下：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">url, data = read_raw_info(rawfile, pageIndex[<span class="string">&#x27;offset&#x27;</span>])</span><br><span class="line">            <span class="comment">#data = data.decode(&#x27;utf-8&#x27;)</span></span><br><span class="line">data_list = re.findall(<span class="string">&#x27;[\u4e00-\u9fa5]&#x27;</span>, data)</span><br><span class="line">data_str = <span class="string">&quot;&quot;</span>.join(data_list)</span><br><span class="line">token = jieba.tokenize(data_str, mode=<span class="string">&#x27;search&#x27;</span>)</span><br></pre></td></tr></table></figure><p>搜索引擎的模糊查询。同时还会返回一个分词结果列表，不仅存储分词结果，还存储分的词的起始位置和结束位置。如下图所示：</p><p><img src="/2020/06/26/SearchEngine/%E7%AE%80%E5%8D%95%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/image-20210511020306137.png" alt="分词结果"></p><h2 id="六、-倒排文件"><a href="#六、-倒排文件" class="headerlink" title="六、  倒排文件"></a>六、  倒排文件</h2><p>我们切词之后得到的结果是正向索引，为了提高查找效率，我们需要生成倒排文件。</p><p><img src="/2020/06/26/SearchEngine/%E7%AE%80%E5%8D%95%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/image-20210511020353671.png" alt="分析网页流程"></p><p><img src="/2020/06/26/SearchEngine/%E7%AE%80%E5%8D%95%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/image-20210511020402280.png" alt="倒排文件格式举例"></p><p>本程序中使用的是字典存储倒排索引，键是一个个关键词，值对应的是一个列表，列表中的每一项都是一个列表（列表的元素按顺序是：文档编号、关键词在该篇文档中出现的次数，最后是每次出现的位置），其对应一个网页。如上图所示。这样一个二维列表就存储了该关键词在所有文档中出现的次数与位置。</p><p><strong>编程实现：见process.py</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将一篇文档的所有token加入倒排文件</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">insert_invertion</span>(<span class="params">token, <span class="built_in">id</span></span>):</span><br><span class="line">    <span class="keyword">for</span> tk <span class="keyword">in</span> token:</span><br><span class="line">        <span class="keyword">if</span> tk[<span class="number">0</span>] <span class="keyword">in</span> invert_dic:</span><br><span class="line">            <span class="comment"># 当前词在字典已经出现过</span></span><br><span class="line">            <span class="comment"># print(invert_dic[tk[0]])</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">id</span> == invert_dic[tk[<span class="number">0</span>]][-<span class="number">1</span>][<span class="number">0</span>]:</span><br><span class="line">                invert_dic[tk[<span class="number">0</span>]][-<span class="number">1</span>][<span class="number">1</span>] += <span class="number">1</span></span><br><span class="line">                invert_dic[tk[<span class="number">0</span>]][-<span class="number">1</span>].append(tk[<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                invert_dic[tk[<span class="number">0</span>]].append([<span class="built_in">id</span>, <span class="number">1</span>, tk[<span class="number">1</span>]])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            invert_dic[tk[<span class="number">0</span>]] = []</span><br><span class="line">            invert_dic[tk[<span class="number">0</span>]].append([<span class="built_in">id</span>, <span class="number">1</span>, tk[<span class="number">1</span>]])</span><br></pre></td></tr></table></figure><p>上述算法是将一篇文档建立倒排文件，之后遍历所有文档即可建立所有的倒排文件。</p><p><img src="/2020/06/26/SearchEngine/%E7%AE%80%E5%8D%95%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/clip_image002.jpg" alt="倒排索引示例"></p><p>​    还要将倒排索引进行排序（这样便于显示搜索结果），遍历每个关键词，按照每个文档中当前关键词出现的频次进行排序，这样在搜索该关键词时，显示的结果将会是提前排好序的。</p><p>​    最后调用之前写好的方法，将字典写如json格式的文件中：<code>invert.json</code>。</p><h2 id="七、-查询服务"><a href="#七、-查询服务" class="headerlink" title="七、  查询服务"></a>七、  查询服务</h2><p>查询服务包括接受用户输入的查询短语、检索、获得相应的匹配结果并显示给用户。搜索引擎三段式工作流程的最后一个环节。</p><p>​    实现流程：首先接受输入的词汇，之后读取倒排文件，找到相关词汇的文档序号。由于生成倒排文件时已经按照词频排好序，又因为查询结果排序我使用的就是词频，所以得到相关文档的序号的列表之后即是我们需要显示的内容。有时相关文章太多，那么将显示部分网页。</p><p>​    根据要显示的网页的序号，我们还需要读取原始网页库，获取url和标题和摘要。获取url和标题较为简单，摘要的生成是截取关键词前后的一定词，词的数量通过程序中abstract_ahead_offset和abstract_len参数来实现，其表示关键词前多少个字和一共取得长度。</p><p><strong>程序实现：search.py</strong></p><p><code>general_pageinfo（）</code>：</p><p>输入：倒排索引关键词对应的列表数组里的一个列表，也就是一篇文档的倒排索引：<code>[文档id，词频, 索引词每次出现的位置……]</code></p><p>输出：标题、url，摘要</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">general_pageinfo</span>(<span class="params">page</span>):</span><br><span class="line">    no = page[<span class="number">0</span>]</span><br><span class="line">    <span class="comment"># time = page[1]</span></span><br><span class="line">    pos = page[<span class="number">2</span>:]</span><br><span class="line">    raw_offset = pageIndexs[no][<span class="string">&#x27;offset&#x27;</span>]</span><br><span class="line">    rawfile = <span class="built_in">open</span>(<span class="string">&#x27;raw.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;UTF-8&#x27;</span>)</span><br><span class="line">    url, data = process.read_raw_info(rawfile, raw_offset)</span><br><span class="line">    soup = BeautifulSoup(data, <span class="string">&#x27;html.parser&#x27;</span>)</span><br><span class="line">    title = soup.find(<span class="string">&quot;title&quot;</span>)</span><br><span class="line">    data_list = re.findall(<span class="string">&#x27;[\u4e00-\u9fa5]&#x27;</span>, data)</span><br><span class="line">    data_str = <span class="string">&quot;&quot;</span>.join(data_list)</span><br><span class="line">    abstract = get_abstract(data_str, pos[<span class="number">0</span>])</span><br><span class="line">    rawfile.close()</span><br><span class="line">    <span class="keyword">return</span> title.text, url, abstract</span><br></pre></td></tr></table></figure><p>生成摘要：<code>get_abstract（）</code></p><p>注意：生成的摘要的内容仅包括关键词第一次出现位置的前后文。</p><p>输入：原始网页正文，关键词偏移</p><p>输出：关键词前后的一定长度的上下文</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_abstract</span>(<span class="params">data, offset</span>):</span><br><span class="line">    <span class="keyword">if</span>(offset &gt; abstract_ahead_offset):</span><br><span class="line">        offset -= abstract_ahead_offset</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        offset = <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> data[offset : offset + abstract_len]</span><br></pre></td></tr></table></figure><h2 id="八、-Web页面"><a href="#八、-Web页面" class="headerlink" title="八、  Web页面"></a>八、  Web页面</h2><p>Web页面用的是<code>Flask</code>。运行<code>web.py</code>，然后就可以打开浏览器访问<a href="http://127.0.0.1:5000/。">http://127.0.0.1:5000/。</a></p><p>Web页面只有两部分。一部分是主页<code>index.html</code>，一部分是搜索结果显示页面<code>search.html</code>。在主页输入搜索词，然后点击搜索，就会跳转到显示结果界面。关于网页的css用的是仿百度的。</p><p>​    全部代码见<code>web.py</code>，关键函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/&quot;</span>, methods=[<span class="string">&#x27;POST&#x27;</span>, <span class="string">&#x27;GET&#x27;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">mainpage</span>():</span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">&#x27;POST&#x27;</span> <span class="keyword">and</span> request.form.get(<span class="string">&#x27;inputs&#x27;</span>):</span><br><span class="line">        inputs = request.form[<span class="string">&#x27;inputs&#x27;</span>]</span><br><span class="line">        <span class="keyword">return</span> redirect(url_for(<span class="string">&#x27;search&#x27;</span>, inputs=inputs))</span><br><span class="line">    <span class="keyword">return</span> render_template(<span class="string">&#x27;index.html&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/search/&lt;inputs&gt;&quot;</span>, methods=[<span class="string">&#x27;POST&#x27;</span>, <span class="string">&#x27;GET&#x27;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">inputs</span>):</span><br><span class="line">    results = SE.search(inputs)</span><br><span class="line">    highlight_results = highlight(results, inputs)</span><br><span class="line">    <span class="keyword">return</span> render_template(<span class="string">&#x27;search.html&#x27;</span>, results=highlight_results, value=inputs, length=<span class="built_in">len</span>(results))</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​    首先是根地址，是搜索页面<code>index.html</code>，点击搜索按钮之后会发送POST请求到本地5000端口，并将搜索词作为表单上传。之后会运行<code>mainpage</code>函数，重定向到search，在本地搜索引擎搜索，之后再用模板<code>search.html</code>显示结果。</p><p>页面源代码和css见/templates下的html文件</p><h2 id="九、-使用说明："><a href="#九、-使用说明：" class="headerlink" title="九、  使用说明："></a>九、  使用说明：</h2><h3 id="9-1-终端显示"><a href="#9-1-终端显示" class="headerlink" title="9.1 终端显示"></a>9.1 终端显示</h3><p>首先在终端（推荐vscode执行，因为url可以点击）执行：<code>python .\search.py</code></p><p>​    之后会提示输入查询词，若有查询结果，则显示相关结果，否则提示未找到相关词汇。</p><p><img src="/2020/06/26/SearchEngine/%E7%AE%80%E5%8D%95%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/clip_image002-1620670027564.jpg" alt="搜索“西北工业大学”示例"></p><h3 id="9-2-Web"><a href="#9-2-Web" class="headerlink" title="9.2 Web"></a>9.2 Web</h3><p>​    首先打开终端，运行：<code>python web.py</code></p><p><img src="/2020/06/26/SearchEngine/%E7%AE%80%E5%8D%95%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/clip_image005.jpg" alt="img"></p><p>之后打开<a href="http://127.0.0.1:5000/即可，就有如下画面：">http://127.0.0.1:5000/即可，就有如下画面：</a></p><p><img src="/2020/06/26/SearchEngine/%E7%AE%80%E5%8D%95%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/clip_image007.jpg" alt="Web首页"></p><p>之后就可以开始搜索，如“融水县”</p><p><img src="/2020/06/26/SearchEngine/%E7%AE%80%E5%8D%95%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/clip_image009.jpg" alt="“融水县”搜索结果"></p><p>再次点击搜索会返回主页。搜索框还会显示搜索记录。</p><p><img src="/2020/06/26/SearchEngine/%E7%AE%80%E5%8D%95%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/clip_image011.jpg" alt="搜索记录"></p>]]></content>
      
      
      <categories>
          
          <category> 课程大作业 </category>
          
          <category> 搜索引擎 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 搜索引擎 </tag>
            
            <tag> python </tag>
            
            <tag> flask </tag>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>服务器(Ubuntu)搭建Code-Server</title>
      <link href="/2020/06/08/%E5%B7%A5%E5%85%B7/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BACode-Server/"/>
      <url>/2020/06/08/%E5%B7%A5%E5%85%B7/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BACode-Server/</url>
      
        <content type="html"><![CDATA[<h1 id="服务器-Ubuntu-搭建Code-Server"><a href="#服务器-Ubuntu-搭建Code-Server" class="headerlink" title="服务器(Ubuntu)搭建Code-Server"></a>服务器(Ubuntu)搭建Code-Server</h1><p>code-server：能够支持远程部署自己的vscode，不要求远程服务器上要有图形界面，命令行即可。然后就可以在浏览器/iPad中写代码了。</p><h2 id="1-、准备服务器"><a href="#1-、准备服务器" class="headerlink" title="1.、准备服务器"></a>1.、准备服务器</h2><p>ubuntu18.04</p><h2 id="2、下载项目"><a href="#2、下载项目" class="headerlink" title="2、下载项目"></a>2、下载项目</h2><p><a href="https://github.com/cdr/code-server">github下载地址，进入release下载</a></p><p><img src="/2020/06/08/%E5%B7%A5%E5%85%B7/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BACode-Server/image-20200608012538955.png" alt="image-20200608012538955"></p><p>可以选择浏览器下载，之后使用WinSCP上传；或者<code>wget *****(下载地址)</code></p><p>接下来解压</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xzf code-xxx</span><br></pre></td></tr></table></figure><p><img src="/2020/06/08/%E5%B7%A5%E5%85%B7/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BACode-Server/image-20200608012923198.png" alt="image-20200608012923198"></p><p>关键的就是code-server了。</p><h2 id="3、直接运行"><a href="#3、直接运行" class="headerlink" title="3、直接运行"></a>3、直接运行</h2><p>当然可以<code>./code-server</code>直接运行（别急，看完下面内容再说），但是有一些缺点：</p><ul><li>运行之后会输出一串比较长的密码（如果要自定义密码，就需要定义环境变量<code>$PASSWORD</code>）</li><li>默认监听的端口是8080，我们也可以指定一个其他的；</li><li>只能够监听本地地址，也就是 127.0.0.1；监听地址可以传入参数 —host 0.0.0.0</li></ul><p>总结起来就是：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> PASSWORD=<span class="string">&quot;你自己的密码&quot;</span> &amp;&amp; ./code-server --host 0.0.0.0 --port 6007</span><br></pre></td></tr></table></figure><p>进入浏览器访问服务器公网ip:端口号</p><p>局域网ip也是可以的</p><h3 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h3><p>也可以通过配置文件配置运行，那样的话就不用输入那么多参数了</p><p>位置：<code>~/.config/code-server/config.yaml</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">bind-addr:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:portNum</span></span><br><span class="line"><span class="attr">auth:</span> <span class="string">password</span></span><br><span class="line"><span class="attr">password:</span> <span class="string">yourpassword</span></span><br><span class="line"><span class="attr">cert:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>修改你想要的密码和端口号即可</p><p>然后直接<code>./coder-server</code>即可，无需配置其他参数</p><h2 id="4、后台运行"><a href="#4、后台运行" class="headerlink" title="4、后台运行"></a>4、后台运行</h2><p>当你断开ssh连接之后，你会发现你连接不上服务器了。因为终端断掉项目就终止运行了。</p><blockquote><p>  一开始使用的是， nohup <em>*</em> &amp; ，但是失败了</p></blockquote><h3 id="screen"><a href="#screen" class="headerlink" title="screen"></a>screen</h3><p>后来使用的是screen后台运行</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开启新会话</span></span><br><span class="line">screen -S server</span><br><span class="line"></span><br><span class="line"><span class="comment"># 之后运行启动服务脚本: startserver.sh</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 开启jupyter-botebook服务</span></span><br><span class="line"><span class="comment"># nohup jupyter-notebook &gt; ~/.nohup.out &amp;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 开启VSCode</span></span><br><span class="line"><span class="built_in">cd</span> code-server</span><br><span class="line"><span class="built_in">nohup</span> ./code-server --host 0.0.0.0 --port 6007 &gt; ~/.nohup.out &amp;</span><br><span class="line"><span class="built_in">cd</span> -</span><br><span class="line"></span><br><span class="line"><span class="comment"># 最后 ctrl + A， D 退出</span></span><br></pre></td></tr></table></figure><p>最后就是开心的编程啦！</p><p><img src="/2020/06/08/%E5%B7%A5%E5%85%B7/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BACode-Server/image-20200608021556233.png" alt="image-20200608021556233"></p><p>iPad端：</p><p><img src="/2020/06/08/%E5%B7%A5%E5%85%B7/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BACode-Server/IMG_0039-1591553907391.PNG" alt="IMG_0039"></p><p>连上蓝牙键盘就很舒服了。</p><h3 id="tmux"><a href="#tmux" class="headerlink" title="tmux"></a>tmux</h3><p>使用tmux运行也可以</p><p>tmux简介：<a href="https://www.ruanyifeng.com/blog/2019/10/tmux.html">Tmux 使用教程 - 阮一峰的网络日志 (ruanyifeng.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 服务器 </tag>
            
            <tag> Code-Server </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2018/01/01/hello-world/"/>
      <url>/2018/01/01/hello-world/</url>
      
        <content type="html"><![CDATA[<p>这是模板文件</p><p><img src="/2018/01/01/hello-world/image-20210509141043030.png" alt="image-20210509141043030"></p><p><img src="/2018/01/01/hello-world/image-20210509141345390.png" alt="image-20210509141345390"></p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
