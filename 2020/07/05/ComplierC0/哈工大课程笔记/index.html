<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>哈工大慕课《编译原理》笔记 | MomoChen</title><meta name="keywords" content="编译器,慕课,笔记"><meta name="author" content="MomoChen"><meta name="copyright" content="MomoChen"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="哈工大慕课笔记">
<meta property="og:type" content="article">
<meta property="og:title" content="哈工大慕课《编译原理》笔记">
<meta property="og:url" content="https://chen2511.github.io/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="MomoChen">
<meta property="og:description" content="哈工大慕课笔记">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://chen2511.github.io/img/1575009542094.jpg">
<meta property="article:published_time" content="2020-07-04T16:00:00.000Z">
<meta property="article:modified_time" content="2022-04-18T11:51:21.653Z">
<meta property="article:author" content="MomoChen">
<meta property="article:tag" content="编译器">
<meta property="article:tag" content="慕课">
<meta property="article:tag" content="笔记">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://chen2511.github.io/img/1575009542094.jpg"><link rel="shortcut icon" href="/img/favicon.jpg"><link rel="canonical" href="https://chen2511.github.io/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":1,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":800},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: true
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":500,"languages":{"author":"作者: MomoChen","link":"链接: ","source":"来源: MomoChen","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'mediumZoom',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '哈工大慕课《编译原理》笔记',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-04-18 19:51:21'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.2"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/favicon.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">34</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">24</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我的</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/1574999290770.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">MomoChen</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我的</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">哈工大慕课《编译原理》笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-07-04T16:00:00.000Z" title="发表于 2020-07-05 00:00:00">2020-07-05</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-04-18T11:51:21.653Z" title="更新于 2022-04-18 19:51:21">2022-04-18</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">5.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>17分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="哈工大慕课《编译原理》笔记"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="第一讲-绪论"><a href="#第一讲-绪论" class="headerlink" title="第一讲 绪论"></a>第一讲 绪论</h2><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200423233623380.png" alt="image-20200423233623380"></p>
<h3 id="语义分析"><a href="#语义分析" class="headerlink" title="语义分析"></a>语义分析</h3><blockquote>
<p>  语句主要分为：声明语句（数据对象和过程）、可执行语句</p>
</blockquote>
<h4 id="语义分析的主要任务"><a href="#语义分析的主要任务" class="headerlink" title="语义分析的主要任务"></a>语义分析的主要任务</h4><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200423233142555.png" alt="image-20200423233142555"></p>
<p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200423233156751.png" alt="image-20200423233156751"></p>
<h2 id="第二讲-语言及其文法-2020-4-14"><a href="#第二讲-语言及其文法-2020-4-14" class="headerlink" title="第二讲 语言及其文法 2020-4-14"></a>第二讲 语言及其文法 2020-4-14</h2><h3 id="2-1-基本概念"><a href="#2-1-基本概念" class="headerlink" title="2.1 基本概念"></a>2.1 基本概念</h3><h4 id="字母表"><a href="#字母表" class="headerlink" title="字母表"></a>字母表</h4><p>字母表 ∑是一个有穷符号集合；</p>
<p>符号：字 母、数、标点符号、 …</p>
<h5 id="字母表上的运算"><a href="#字母表上的运算" class="headerlink" title="字母表上的运算"></a>字母表上的运算</h5><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200414155540833.png" alt="image-20200414155540833"></p>
<p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200414155553074.png" alt="image-20200414155553074"></p>
<p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200414155619372.png" alt="image-20200414155619372"></p>
<p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200414155629719.png" alt="image-20200414155629719"></p>
<h4 id="串"><a href="#串" class="headerlink" title="串"></a>串</h4><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200414155719711.png" alt="image-20200414155719711"></p>
<h5 id="串的运算"><a href="#串的运算" class="headerlink" title="串的运算"></a>串的运算</h5><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200414155755221.png" alt="image-20200414155755221"></p>
<p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200414155820504.png" alt="image-20200414155820504"></p>
<h3 id="2-2-文法定义"><a href="#2-2-文法定义" class="headerlink" title="2.2 文法定义"></a>2.2 文法定义</h3><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200414155944996.png" alt="image-20200414155944996"></p>
<h4 id="文法的形式化定义"><a href="#文法的形式化定义" class="headerlink" title="文法的形式化定义"></a>文法的形式化定义</h4><blockquote>
<p>  北航文法：|、（、[、{</p>
<p>  或、限定范围、可选、闭包</p>
</blockquote>
<p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200414160013578.png" alt="image-20200414160013578"></p>
<p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200414160031020.png" alt="image-20200414160031020"></p>
<p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200414160043659.png" alt="image-20200414160043659"></p>
<p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200414160208413.png" alt="image-20200414160208413"></p>
<blockquote>
<p>  如果不会引起误解，产生式就可以代表一种语言</p>
</blockquote>
<h4 id="产生式的简写-lt-gt"><a href="#产生式的简写-lt-gt" class="headerlink" title="产生式的简写&lt;!&gt;"></a>产生式的简写&lt;!&gt;</h4><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200414160300901.png" alt="image-20200414160300901"></p>
<h4 id="符号约定"><a href="#符号约定" class="headerlink" title="符号约定"></a>符号约定</h4><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200414160345306.png" alt="image-20200414160345306"></p>
<p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200414160350493.png" alt="image-20200414160350493"></p>
<p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200414160554641.png" alt="image-20200414160554641"></p>
<h3 id="2-3-语言的定义"><a href="#2-3-语言的定义" class="headerlink" title="2.3 语言的定义"></a>2.3 语言的定义</h3><blockquote>
<p>  有了规则，怎么识别是否是这种语言？</p>
</blockquote>
<h4 id="推导与规约"><a href="#推导与规约" class="headerlink" title="推导与规约"></a>推导与规约</h4><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200414160829977.png" alt="image-20200414160829977"></p>
<p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200414160953530.png" alt="image-20200414160953530"></p>
<h4 id="句型和句子"><a href="#句型和句子" class="headerlink" title="句型和句子"></a>句型和句子</h4><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200414160931076.png" alt="image-20200414160931076"></p>
<p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200414160944915.png" alt="image-20200414160944915"></p>
<h4 id="语言的形式化定义"><a href="#语言的形式化定义" class="headerlink" title="语言的形式化定义"></a>语言的形式化定义</h4><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200414161044167.png" alt="image-20200414161044167"></p>
<blockquote>
<p>  必须是句子，只有终结符</p>
</blockquote>
<h4 id="语言的运算"><a href="#语言的运算" class="headerlink" title="语言的运算"></a>语言的运算</h4><blockquote>
<p>  不是很理解，这里的运算是指语言的吗？</p>
</blockquote>
<p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200414161258202.png" alt="image-20200414161258202"></p>
<blockquote>
<p>  举例：把集合看成一种语言，字母、数字的集合，看作是语言；然后语言运算，就是标识符了</p>
<p>  (这么看也没错，语言本就是一个集合)</p>
</blockquote>
<h3 id="2-4-文法的分类"><a href="#2-4-文法的分类" class="headerlink" title="2.4 文法的分类"></a>2.4 文法的分类</h3><h4 id="0型文法"><a href="#0型文法" class="headerlink" title="0型文法"></a>0型文法</h4><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200414162445423.png" alt="image-20200414162445423"></p>
<h4 id="1型文法"><a href="#1型文法" class="headerlink" title="1型文法"></a>1型文法</h4><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200414162552673.png" alt="image-20200414162552673"></p>
<h4 id="2型文法"><a href="#2型文法" class="headerlink" title="2型文法"></a>2型文法</h4><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200414162652255.png" alt="image-20200414162652255"></p>
<h4 id="3型文法"><a href="#3型文法" class="headerlink" title="3型文法"></a>3型文法</h4><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200414162702556.png" alt="image-20200414162702556"></p>
<h4 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h4><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200414162751558.png" alt="image-20200414162751558"></p>
<h3 id="2-5-CFG的语法分析树"><a href="#2-5-CFG的语法分析树" class="headerlink" title="2.5 CFG的语法分析树"></a>2.5 CFG的语法分析树</h3><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200414163058136.png" alt="image-20200414163058136"></p>
<h4 id="短语和直接短语"><a href="#短语和直接短语" class="headerlink" title="短语和直接短语"></a>短语和直接短语</h4><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200414163226489.png" alt="image-20200414163226489"></p>
<blockquote>
<p>  句柄：最左直接短语</p>
</blockquote>
<h4 id="二义性文法"><a href="#二义性文法" class="headerlink" title="二义性文法"></a>二义性文法</h4><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200414163259750.png" alt="image-20200414163259750"></p>
<p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200414163421893.png" alt="image-20200414163421893"></p>
<h2 id="第三讲-词法分析-2020-4-14"><a href="#第三讲-词法分析-2020-4-14" class="headerlink" title="第三讲 词法分析 2020-4-14"></a>第三讲 词法分析 2020-4-14</h2><h3 id="3-1-正则表达式"><a href="#3-1-正则表达式" class="headerlink" title="3.1 正则表达式"></a>3.1 正则表达式</h3><p>正则表达式(Regular Expression，RE)是一种用来描述正则语言的更紧凑的表示方法</p>
<p>正则表达式可以由较小的正则表达式按照特定规则递归地构建。每个正则表达式r定义（表示）一个语言，记为L(r )。这个语言也是根据r的子表达式所表示的语言递归定义的</p>
<h4 id="正则表达式的定义"><a href="#正则表达式的定义" class="headerlink" title="正则表达式的定义"></a>正则表达式的定义</h4><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200414164516624.png" alt="image-20200414164516624"></p>
<blockquote>
<p>  空串是RE，表达的语言也是空串</p>
<p>  字母表上的任何一个符号，表示的语言只包含它本身</p>
<p>  集中运算：</p>
<ul>
<li>连接：</li>
<li>或：|</li>
<li>克林闭包：语言的克林闭包</li>
<li><p>括号可以消去</p>
<h4 id="正规式简化"><a href="#正规式简化" class="headerlink" title="正规式简化"></a>正规式简化</h4><p>正闭包</p>
<blockquote>
<p>r+ = rr<em> = r\</em>r，r*= r+|ε</p>
<p>+与*具有相同的运算优先级和结合性</p>
</blockquote>
<p>可选符</p>
<blockquote>
<p>r?=r |ε</p>
</blockquote>
<p>字符组</p>
<blockquote>
<p>字符组是或关系的缩写形式，它把所有存在或关系的字符集中在[ ]里面</p>
<p>枚举方式: 如[abc]，它等价于a|b|c<br>分段方式: 如[0-9a-z]，它等价于[0123456789abcdefghijklmnopqrstuvwxyz]<br>17</p>
</blockquote>
<p>非字符组</p>
<blockquote>
<p>若Σ={a,b,c,d,e,f,g}，则L([ ^abc ]) = { d, e, f, g }。</p>
</blockquote>
<p>串</p>
<blockquote>
<p>引入串的表示可以避免与正规式中运算符的冲突。例如：”a|b”=a”|”b≠a|b。</p>
</blockquote>
<h4 id="正规式简化2"><a href="#正规式简化2" class="headerlink" title="正规式简化2"></a>正规式简化2</h4><blockquote>
<p>转义符\，用于将特殊符号的含义取消<br>{m,n} 匹配其前面的字符至少出现m次，最多出现n次<br>{n} 匹配其前面的字符恰好出现n次<br>{n,}匹配其前面的字符出现不小于n次<br>首符号‘^’<br>尾符号‘$’<br>.匹配除了换行符外任意一个字符</p>
</blockquote>
</li>
</ul>
</blockquote>
<h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200414164845151.png" alt="image-20200414164845151"></p>
<p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200414164906961.png" alt="image-20200414164906961"></p>
<h4 id="正则语言"><a href="#正则语言" class="headerlink" title="正则语言"></a>正则语言</h4><p>可以用RE定义的语言叫做正则语言(regular language)或正则集合(regular set)</p>
<p><strong>正则文法与正则表达式等价</strong></p>
<blockquote>
<p>  对任何正则文法G，存在定义同一语言的正则表达式r<br>  对任何正则表达式r，存在生成同一语言的正则文法G</p>
</blockquote>
<h4 id="RE的代数定律"><a href="#RE的代数定律" class="headerlink" title="RE的代数定律"></a>RE的代数定律</h4><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200414165056191.png" alt="image-20200414165056191"></p>
<h3 id="3-2-正则定义"><a href="#3-2-正则定义" class="headerlink" title="3.2 正则定义"></a>3.2 正则定义</h3><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200414165327823.png" alt="image-20200414165327823"></p>
<h4 id="举例-1"><a href="#举例-1" class="headerlink" title="举例"></a>举例</h4><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200414165359643.png" alt="image-20200414165359643"></p>
<p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200414165428297.png" alt="image-20200414165428297"></p>
<h3 id="3-3-有穷自动机"><a href="#3-3-有穷自动机" class="headerlink" title="3.3 有穷自动机"></a>3.3 有穷自动机</h3><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200414165811306.png" alt="image-20200414165811306"></p>
<h4 id="FA的表示"><a href="#FA的表示" class="headerlink" title="FA的表示"></a>FA的表示</h4><h5 id="转换图"><a href="#转换图" class="headerlink" title="转换图"></a>转换图</h5><p>结点：FA的状态</p>
<blockquote>
<p>  初始状态（开始状态）：只有一个，由start箭头指向</p>
<p>  终止状态（接收状态）：可以有多个，用双圈表示</p>
</blockquote>
<p>带标记的有向边：如果对于输入a，存在一个从状态p到状态q的转换，就在p、q之间画一条有向边，并标记上a</p>
<h4 id="FA定义（接收）的语言"><a href="#FA定义（接收）的语言" class="headerlink" title="FA定义（接收）的语言"></a>FA定义（接收）的语言</h4><p>给定输入串x，如果存在一个对应于串x的从初始状态到某个终止状态的转换序列，则称串x被该FA接收</p>
<p>由一个有穷自动机M接收的所有串构成的集合称为是该FA定义（或接收）的语言，记为L(M )</p>
<p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200414170141722.png" alt="image-20200414170141722"></p>
<h4 id="最长子串匹配原则-LongestString-MatchingPrinciple"><a href="#最长子串匹配原则-LongestString-MatchingPrinciple" class="headerlink" title="最长子串匹配原则(LongestString MatchingPrinciple)"></a>最长子串匹配原则(LongestString MatchingPrinciple)</h4><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200415171200826.png" alt="image-20200415171200826"></p>
<blockquote>
<p>  匹配到 &lt; 之后，只要还有符号，就继续匹配；即使到达某个终态</p>
<p>  ++ 可以也匹配+；但我们把他看作是++</p>
</blockquote>
<h3 id="3-4-有穷自动机的分类"><a href="#3-4-有穷自动机的分类" class="headerlink" title="3.4 有穷自动机的分类"></a>3.4 有穷自动机的分类</h3><h4 id="1、确定的有穷自动机-DFA"><a href="#1、确定的有穷自动机-DFA" class="headerlink" title="1、确定的有穷自动机(DFA)"></a>1、确定的有穷自动机(DFA)</h4><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200415165921727.png" alt="image-20200415165921727"></p>
<blockquote>
<p>  对应一个输入字母，只有一种转换</p>
</blockquote>
<h4 id="2、非确定的有穷自动机-NFA"><a href="#2、非确定的有穷自动机-NFA" class="headerlink" title="2、非确定的有穷自动机(NFA)"></a>2、非确定的有穷自动机(NFA)</h4><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200415170028879.png" alt="image-20200415170028879"></p>
<blockquote>
<p>  从状态出发，沿着标记出发，能到达的状态是个集合</p>
<p>  如果转换函数没有给出对应于某个状态-输入对的信息，就把Ø放入相应的表项中</p>
</blockquote>
<h4 id="DFA和NFA的等价性"><a href="#DFA和NFA的等价性" class="headerlink" title="DFA和NFA的等价性"></a>DFA和NFA的等价性</h4><ul>
<li><p>对任何非确定的有穷自动机N ，存在定义同一语言的确定的有穷自动机D</p>
</li>
<li><p>对任何确定的有穷自动机D ，存在定义同一语言的非确定的有穷自动机N</p>
</li>
</ul>
<h4 id="3、带有“ε-边”的NFA"><a href="#3、带有“ε-边”的NFA" class="headerlink" title="3、带有“ε-边”的NFA"></a>3、带有“ε-边”的NFA</h4><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200415170453075.png" alt="image-20200415170453075"></p>
<blockquote>
<p>  不是相同状态，例如有些东西不再接收</p>
</blockquote>
<h4 id="带有和不带有“ε-边”的NFA-的等价性"><a href="#带有和不带有“ε-边”的NFA-的等价性" class="headerlink" title="带有和不带有“ε-边”的NFA 的等价性"></a>带有和不带有“ε-边”的NFA 的等价性</h4><h4 id="4、DFA的算法实现-lt-lt-gt-gt"><a href="#4、DFA的算法实现-lt-lt-gt-gt" class="headerlink" title="4、DFA的算法实现 &lt;&lt;!!!&gt;&gt;"></a>4、DFA的算法实现 &lt;&lt;!!!&gt;&gt;</h4><blockquote>
<p>  NFA直观；但DFA实现简单</p>
</blockquote>
<p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200415170708945.png" alt="image-20200415170708945"></p>
<h5 id="louden-书的实现"><a href="#louden-书的实现" class="headerlink" title="louden 书的实现"></a>louden 书的实现</h5><blockquote>
<p>  和博客类似</p>
</blockquote>
<p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200415190003372.png" alt="image-20200415190003372"></p>
<h3 id="3-5-从正则表达式到有穷自动机"><a href="#3-5-从正则表达式到有穷自动机" class="headerlink" title="3.5 从正则表达式到有穷自动机"></a>3.5 从正则表达式到有穷自动机</h3><blockquote>
<p>  识别单词&gt;&gt; 正则表达式 ，因为直接从正则表达式到 DFA比较难；所以先到 NFA，再到DFA</p>
</blockquote>
<h4 id="根据RE-构造NFA"><a href="#根据RE-构造NFA" class="headerlink" title="根据RE 构造NFA"></a>根据RE 构造NFA</h4><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200415171605456.png" alt="image-20200415171605456"></p>
<p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200415171617499.png" alt="image-20200415171617499"></p>
<p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200415171626042.png" alt="image-20200415171626042"></p>
<h3 id="3-6-从NFA到DFA的转换"><a href="#3-6-从NFA到DFA的转换" class="headerlink" title="3.6 从NFA到DFA的转换"></a>3.6 从NFA到DFA的转换</h3><h4 id="从NFA到DFA的转换"><a href="#从NFA到DFA的转换" class="headerlink" title="从NFA到DFA的转换"></a>从NFA到DFA的转换</h4><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200415172247525.png" alt="image-20200415172247525"></p>
<h4 id="从带有ε-边的NFA到DFA的转换"><a href="#从带有ε-边的NFA到DFA的转换" class="headerlink" title="从带有ε-边的NFA到DFA的转换"></a>从带有ε-边的NFA到DFA的转换</h4><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200415172647950.png" alt="子集构造法（subset construction）"></p>
<h4 id="子集构造法（subset-construction）"><a href="#子集构造法（subset-construction）" class="headerlink" title="子集构造法（subset construction）"></a>子集构造法（subset construction）</h4><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200415175702434.png" alt="image-20200415175702434"></p>
<blockquote>
<p>  从初始状态求闭包开始（就是空转换能到达的状态集合）</p>
<p>  Dstates ： DFA 的 状态集合；一开始只有初始闭包；</p>
<p>  之后对每一个输入符号，状态转换，再求闭包；这是一个新状态；</p>
<p>  注意标记问题；就像dfs，visited数组一样</p>
</blockquote>
<h4 id="似乎没有最小化DFA"><a href="#似乎没有最小化DFA" class="headerlink" title="似乎没有最小化DFA"></a>似乎没有最小化DFA</h4><h3 id="3-7-识别单词的DFA"><a href="#3-7-识别单词的DFA" class="headerlink" title="3.7 识别单词的DFA"></a>3.7 识别单词的DFA</h3><h4 id="DFA举例"><a href="#DFA举例" class="headerlink" title="DFA举例"></a>DFA举例</h4><h5 id="1、识别标识符的DFA"><a href="#1、识别标识符的DFA" class="headerlink" title="1、识别标识符的DFA"></a>1、识别标识符的DFA</h5><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200415181335170.png" alt="image-20200415181335170"></p>
<blockquote>
<p>  慕课提示：识别关键字和标识符是一样的；有一个关键字的表</p>
</blockquote>
<h5 id="2、识别无符号数的DFA"><a href="#2、识别无符号数的DFA" class="headerlink" title="2、识别无符号数的DFA"></a>2、识别无符号数的DFA</h5><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200415181350273.png" alt="image-20200415181350273"></p>
<p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200415181355997.png" alt="image-20200415181355997"></p>
<h5 id="3、识别各进制无符号整数的DFA"><a href="#3、识别各进制无符号整数的DFA" class="headerlink" title="3、识别各进制无符号整数的DFA"></a>3、识别各进制无符号整数的DFA</h5><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200415181412342.png" alt="image-20200415181412342"></p>
<h5 id="4、识别注释的DFA"><a href="#4、识别注释的DFA" class="headerlink" title="4、识别注释的DFA"></a>4、识别注释的DFA</h5><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200415181430167.png" alt="image-20200415181430167"></p>
<h5 id="5、识别Token"><a href="#5、识别Token" class="headerlink" title="5、识别Token"></a>5、识别Token</h5><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200415181437461.png" alt="image-20200415181437461"></p>
<h4 id="词法分析阶段的错误处理-lt-lt-gt-gt"><a href="#词法分析阶段的错误处理-lt-lt-gt-gt" class="headerlink" title="词法分析阶段的错误处理&lt;&lt;!!!&gt;&gt;"></a>词法分析阶段的错误处理&lt;&lt;!!!&gt;&gt;</h4><h5 id="词法分析阶段可检测错误的类型"><a href="#词法分析阶段可检测错误的类型" class="headerlink" title="词法分析阶段可检测错误的类型"></a>词法分析阶段可检测错误的类型</h5><ul>
<li>单词拼写错误</li>
<li>非法字符</li>
</ul>
<h5 id="词法错误检测"><a href="#词法错误检测" class="headerlink" title="词法错误检测"></a>词法错误检测</h5><p>如果当前状态与当前输入符号在<strong>转换表对应项中的信息为空</strong>，而当前状态又<strong>不是终止状态</strong>，则调用错误处理程序</p>
<h5 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h5><blockquote>
<p>  不是很理解他说的</p>
</blockquote>
<h2 id="第四讲-语法分析1-2020-4-3"><a href="#第四讲-语法分析1-2020-4-3" class="headerlink" title="第四讲 语法分析1 2020-4-3"></a>第四讲 语法分析1 2020-4-3</h2><h3 id="4-1-自顶向下分析概述"><a href="#4-1-自顶向下分析概述" class="headerlink" title="4.1 自顶向下分析概述"></a>4.1 自顶向下分析概述</h3><h3 id="4-2-文法转换"><a href="#4-2-文法转换" class="headerlink" title="4.2 文法转换"></a>4.2 文法转换</h3><h4 id="1、消除直接左递归"><a href="#1、消除直接左递归" class="headerlink" title="1、消除直接左递归"></a>1、消除直接左递归</h4><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200404134548259.png" alt="image-20200404134548259"></p>
<blockquote>
<p>  事实上，这种消除过程就是把左递归转换成了右递归</p>
</blockquote>
<p>举例：</p>
<p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200404134613236.png" alt="image-20200404134613236"></p>
<h4 id="2、消除间接左递归"><a href="#2、消除间接左递归" class="headerlink" title="2、消除间接左递归"></a>2、消除间接左递归</h4><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200404134800513.png" alt="image-20200404134800513"></p>
<h5 id="消除左递归算法："><a href="#消除左递归算法：" class="headerlink" title="消除左递归算法："></a>消除左递归算法：</h5><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200404134813667.png" alt="image-20200404134813667"></p>
<h4 id="3、提取左公因子算法"><a href="#3、提取左公因子算法" class="headerlink" title="3、提取左公因子算法"></a>3、提取左公因子算法</h4><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200404134924349.png" alt="image-20200404134924349"></p>
<blockquote>
<p>  应该是解决有多个候选式导致的回溯问题</p>
</blockquote>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><blockquote>
<p>  没有矩阵消除左递归方法</p>
<p>  但没有曾老师讲的详细：</p>
<p>  情况1：同一非终结符有多个候选式</p>
<p>  情况2： e和可能句型片断的后续符号相同</p>
<p>  但注意到，内容可能放在后面，如FIRST集合</p>
</blockquote>
<h3 id="4-3-LL-1-文法"><a href="#4-3-LL-1-文法" class="headerlink" title="4.3 LL(1)文法"></a>4.3 LL(1)文法</h3><h4 id="S-文法"><a href="#S-文法" class="headerlink" title="S_文法"></a>S_文法</h4><p>要求相当严格</p>
<p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200404140257287.png" alt="image-20200404140257287"></p>
<p>（有空产生式）什么时候使用ε产生式？</p>
<blockquote>
<p>  如果当前某非终结符A与当前输入符a不匹配时，若存在A→ε，可以通过检查a是否可以出现在A的后面，来决定是否使用产生式A→ε（若文法中无A→ε ，则应报错）</p>
</blockquote>
<p>所以就有了下面的FOLLOW集合：</p>
<h4 id="非终结符A的后继符号集-FOLLOW"><a href="#非终结符A的后继符号集-FOLLOW" class="headerlink" title="非终结符A的后继符号集 FOLLOW"></a>非终结符A的后继符号集 FOLLOW</h4><p>可能在某个句型中紧跟在A后边的终结符a的集合，记为FOLLOW(A)</p>
<blockquote>
<p>  当A选择空语句的时候，接下来的终结符可能是什么</p>
</blockquote>
<h4 id="产生式的可选集-SELECT"><a href="#产生式的可选集-SELECT" class="headerlink" title="产生式的可选集 SELECT"></a>产生式的可选集 SELECT</h4><blockquote>
<p>  确定下一个字符是什么的时候可以选择</p>
</blockquote>
<p>产生式A→β的可选集是指可以选用该产生式进行推导时对应的输入符号的集合，记为SELECT( A→β )</p>
<p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200404140719308.png" alt="image-20200404140719308"></p>
<p>虽然可以空串，但仍然要终结符开始：</p>
<p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200404140745781.png" alt="image-20200404140745781"></p>
<h4 id="串首终结符集-FIRST"><a href="#串首终结符集-FIRST" class="headerlink" title="串首终结符集 FIRST"></a>串首终结符集 FIRST</h4><p>给定一个文法符号串α， α的串首终结符集FIRST(α)被定义为可以从α推导出的所有串首终结符构成的集合。如果α * ε，那么ε也在FIRST(α)中</p>
<p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200404143306248.png" alt="image-20200404143306248"></p>
<blockquote>
<p>  很好理解，符号串可以推出的第一个终结符</p>
<p>  没空串，可选集就是串首；有，就要加上Follow减去空</p>
</blockquote>
<h4 id="LL-1-文法"><a href="#LL-1-文法" class="headerlink" title="LL(1)文法"></a>LL(1)文法</h4><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200404143034875.png" alt="image-20200404143034875"></p>
<blockquote>
<p>  和曾老师讲的内容一样，即：</p>
<p>  （1）不考虑ε-产生式的情况</p>
<p>  根据产生式的首字符进行判断，首字符不能相同</p>
<p>  （2）含ε-产生式的情况</p>
<p>  在使用ε-产生式推导时，需考虑非终结符的后续符号串的首字符；不能相同</p>
</blockquote>
<h3 id="4-4-FIRST集和FOLLOW集的计算"><a href="#4-4-FIRST集和FOLLOW集的计算" class="headerlink" title="4.4 FIRST集和FOLLOW集的计算"></a>4.4 FIRST集和FOLLOW集的计算</h3><h4 id="FIRST集合"><a href="#FIRST集合" class="headerlink" title="FIRST集合"></a>FIRST集合</h4><p>以下是符号X的集合计算：</p>
<p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200404145838814.png" alt="image-20200404145838814"></p>
<blockquote>
<p>  注意：第二步，需要直到yk都能推出空串，才能加入空串到集合中；前面能推出空串，吧yi+1的first加入集合中</p>
</blockquote>
<p>符号串的集合计算，如下图所示：</p>
<p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200404150037297.png" alt="image-20200404150037297"></p>
<h4 id="非终结符的Follow集计算"><a href="#非终结符的Follow集计算" class="headerlink" title="非终结符的Follow集计算"></a>非终结符的Follow集计算</h4><p>不断应用下列规则，直到没有新的终结符可以被加入到任何FOLLOW集合中为止：</p>
<ul>
<li>将$放入FOLLOW( S )中，其中S是开始符号，$是输入右端的结束标记</li>
</ul>
<blockquote>
<p>  即开始的符号，有$ 符号/初始化</p>
<p>   逐个产生式分析；每个产生的右部逐个非终结符分析</p>
</blockquote>
<ul>
<li>如果存在一个产生式A→αBβ，那么FIRST ( β )中除ε 之外的所有符号都在FOLLOW( B )中</li>
<li>如果存在一个产生式A→αB，或存在产生式A→αBβ且FIRST ( β ) 包含ε，那么FOLLOW( A )中的所有符号都在FOLLOW( B )中</li>
</ul>
<blockquote>
<p>  哈工大课程里面说要不断重试，直到不刷新</p>
<p>  但曾老师好像先看右部有几个符号，把相同的符号一次看完</p>
</blockquote>
<h4 id="SELECT-集合计算"><a href="#SELECT-集合计算" class="headerlink" title="SELECT 集合计算"></a>SELECT 集合计算</h4><blockquote>
<p>  对于表达式而言</p>
</blockquote>
<p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200404155904455.png" alt="image-20200404155904455"></p>
<blockquote>
<p>  似乎可以根据 同一非终结符 的select集合是否相交推出是否 是LL(1)文法</p>
<p>  曾老师的课:first+集合和select差不多；根据是否相交判断文法</p>
</blockquote>
<h2 id="第五讲-语法分析2-2020-4-3"><a href="#第五讲-语法分析2-2020-4-3" class="headerlink" title="第五讲 语法分析2 2020-4-3"></a>第五讲 语法分析2 2020-4-3</h2><h3 id="4-5-递归的预测分析法"><a href="#4-5-递归的预测分析法" class="headerlink" title="4.5 递归的预测分析法"></a>4.5 递归的预测分析法</h3><blockquote>
<p>  有伪代码例子</p>
</blockquote>
<p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200411121239298.png" alt="image-20200411121239298"></p>
<p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200411121149410.png" alt="image-20200411121149410"></p>
<p>取下一个<code>token</code>来分析，</p>
<h3 id="4-6-非递归的预测分析法"><a href="#4-6-非递归的预测分析法" class="headerlink" title="4.6 非递归的预测分析法"></a>4.6 非递归的预测分析法</h3><blockquote>
<p>   下推自动机，栈的思想</p>
</blockquote>
<p>下推自动机比有穷自动机的识别能力更强，有穷自动机的识别能力不强是因为它的记忆功能不强</p>
<blockquote>
<p>  举例</p>
</blockquote>
<p>非递归的预测分析不需要为每个非终结符编写递归下降过程，而是根据预测分析表构造一个自动机，也叫表驱动的预测分析</p>
<p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200404162400238.png" alt="image-20200404162400238"></p>
<h5 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h5><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200404162839493.png" alt="image-20200404162839493"></p>
<p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200404162848783.png" alt="image-20200404162848783"></p>
<h3 id="4-7-预测分析中的错误处理"><a href="#4-7-预测分析中的错误处理" class="headerlink" title="4.7 预测分析中的错误处理"></a>4.7 预测分析中的错误处理</h3><p>两种错误：</p>
<ul>
<li>栈顶的终结符和当前输入符号不匹配</li>
<li>栈顶非终结符与当前输入符号在预测分析表对应项中的信息为空</li>
</ul>
<h4 id="恐慌模式"><a href="#恐慌模式" class="headerlink" title="恐慌模式"></a>恐慌模式</h4><ul>
<li>忽略输入中的一些符号，直到输入中出现由设计者选定的同步词法单元(synchronizing token)集合中的某个词法单元</li>
</ul>
<blockquote>
<p>  例如可以把FOLLOW(A)中的所有终结符放入非终结符A的同步记号集合</p>
</blockquote>
<ul>
<li>如果终结符在栈顶而不能匹配，一个简单的办法就是弹出此终结符</li>
</ul>
<p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200410180512605.png" alt="image-20200410180512605"></p>
<h2 id="第六讲-语法分析3-2020-4-10"><a href="#第六讲-语法分析3-2020-4-10" class="headerlink" title="第六讲 语法分析3 2020-4-10"></a>第六讲 语法分析3 2020-4-10</h2><h3 id="4-8-自底向上的语法分析"><a href="#4-8-自底向上的语法分析" class="headerlink" title="4-8 自底向上的语法分析"></a>4-8 自底向上的语法分析</h3><ul>
<li><p>从分析树的底部(叶节点)向顶部(根节点)方向构造分析树</p>
</li>
<li><p>可以看成是将输入串w归约为文法开始符号S的过程</p>
</li>
<li><p>自顶向下的语法分析采用最左推导方式<br>自底向上的语法分析采用最左归约方式（反向构造最右推导）</p>
</li>
<li><p>自底向上语法分析的通用框架：移入-归约分析(Shift-Reduce Parsing)</p>
</li>
</ul>
<h4 id="移入-归约分析器"><a href="#移入-归约分析器" class="headerlink" title="移入-归约分析器"></a>移入-归约分析器</h4><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200410184846731.png" alt="image-20200410184846731"></p>
<h4 id="移入-归约分析中存在的问题"><a href="#移入-归约分析中存在的问题" class="headerlink" title="移入-归约分析中存在的问题"></a>移入-归约分析中存在的问题</h4><ul>
<li>错误地识别了句柄</li>
</ul>
<h3 id="4-9-LR-分析法概述"><a href="#4-9-LR-分析法概述" class="headerlink" title="4-9 LR 分析法概述"></a>4-9 LR 分析法概述</h3><p>L: 对输入进行从左到右的扫描<br>R: 反向构造出一个最右推导序列</p>
<ul>
<li>LR(k)分析<br>需要向前查看k个输入符号的LR分析</li>
</ul>
<blockquote>
<p>  k = 0 和k = 1 这两种情况具有实践意义<br>  当省略(k)时，表示k =1</p>
</blockquote>
<h4 id="LR-分析法的基本原理"><a href="#LR-分析法的基本原理" class="headerlink" title="LR 分析法的基本原理"></a>LR 分析法的基本原理</h4><ul>
<li>自底向上分析的关键问题是什么？</li>
</ul>
<p>如何正确地识别句柄</p>
<ul>
<li>句柄是逐步形成的，用“状态”表示句柄识别的进展程度</li>
</ul>
<h4 id="LR-分析器（自动机）的总体结构"><a href="#LR-分析器（自动机）的总体结构" class="headerlink" title="LR 分析器（自动机）的总体结构"></a>LR 分析器（自动机）的总体结构</h4><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200410210053928.png" alt="image-20200410210053928"></p>
<h4 id="LR-分析表的结构"><a href="#LR-分析表的结构" class="headerlink" title="LR 分析表的结构"></a>LR 分析表的结构</h4><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200410210115484.png" alt="image-20200410210115484"></p>
<p>注意：</p>
<ul>
<li><p>规约的时候 当前状态出栈、符号出栈、新符号入栈；接下来要根据新的状态栈顶状态goto新状态；</p>
</li>
<li><p>似乎一个符号都会对应一个状态，规约的时候出去几个符号，就出去几个状态</p>
</li>
</ul>
<h4 id="LR-分析器的工作过程"><a href="#LR-分析器的工作过程" class="headerlink" title="LR 分析器的工作过程"></a>LR 分析器的工作过程</h4><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200410211257748.png" alt="image-20200410211257748"></p>
<p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200410211309966.png" alt="image-20200410211309966" style="zoom: 80%;"></p>
<p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200410211338050.png" alt="image-20200410211338050"></p>
<h4 id="LR-分析算法"><a href="#LR-分析算法" class="headerlink" title="LR 分析算法"></a>LR 分析算法</h4><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200410211412609.png" alt="image-20200410211412609"></p>
<blockquote>
<p>  算法简单、主要是构建分析表复杂</p>
</blockquote>
<h3 id="4-10-LR-0-分析"><a href="#4-10-LR-0-分析" class="headerlink" title="4-10 LR(0)分析"></a>4-10 LR(0)分析</h3><h4 id="LR-0-项目"><a href="#LR-0-项目" class="headerlink" title="LR(0) 项目"></a>LR(0) 项目</h4><p>右部某位置标有圆点的产生式称为相应文法的一个LR(0)项目（简称为项目）</p>
<h4 id="增广文法"><a href="#增广文法" class="headerlink" title="增广文法"></a>增广文法</h4><p>如果G 是一个以S为开始符号的文法，则G的增广文法G’ 就是在G中加上新开始符号S’ 和产生式S’ → S而得到的文法</p>
<blockquote>
<p>  引入这个新的开始产生式的目的是使得文法开始符号仅出现在一个产生式的左边，从而使得分析器只有一个接受状态</p>
</blockquote>
<h4 id="文法中的项目"><a href="#文法中的项目" class="headerlink" title="文法中的项目"></a>文法中的项目</h4><h5 id="后继项目"><a href="#后继项目" class="headerlink" title="后继项目"></a>后继项目</h5><p>同属于一个产生式的项目，但圆点的位置只相差一个符号，则称后者是前者的后继项目</p>
<p>A→α· Xβ的后继项目是A→αX·β</p>
<p>可以把等价的项目组成一个项目集( I ) ，称为项目集闭包(Closure of Item Sets)，每个项目集闭包对应着自动机的一个状态</p>
<h4 id="举例：构造LR-0-自动机"><a href="#举例：构造LR-0-自动机" class="headerlink" title="举例：构造LR(0)自动机"></a>举例：构造LR(0)自动机</h4><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200410213749916.png" alt="image-20200410213749916"></p>
<h3 id="4-11-LR-0-分析表的构造"><a href="#4-11-LR-0-分析表的构造" class="headerlink" title="4-11 LR(0)分析表的构造"></a>4-11 LR(0)分析表的构造</h3><h4 id="CLOSURE-函数"><a href="#CLOSURE-函数" class="headerlink" title="CLOSURE( )函数"></a>CLOSURE( )函数</h4><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200411190418423.png" alt="image-20200411190418423"></p>
<blockquote>
<p>很好理解：期待B，那么B的产生式就进来，（点在前面</p>
</blockquote>
<p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200411190532412.png" alt="image-20200411190532412"></p>
<blockquote>
<p>  求等价状态的集合</p>
</blockquote>
<h4 id="GOTO-函数"><a href="#GOTO-函数" class="headerlink" title="GOTO ( )函数"></a>GOTO ( )函数</h4><p>返回项目集I对应于文法符号X的后继项目集闭包</p>
<p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200411190614356.png" alt="image-20200411190614356"></p>
<p>X的后继项目 集合；再求闭包</p>
<blockquote>
<p>  也就是在求后继项目集合，然后还需要求闭包</p>
</blockquote>
<h4 id="规范LR-0-项集族"><a href="#规范LR-0-项集族" class="headerlink" title="规范LR(0) 项集族"></a>规范LR(0) 项集族</h4><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200411190952175.png" alt="image-20200411190952175"></p>
<blockquote>
<p>  这样就出来了很多个项目集，就是不同的状态集</p>
</blockquote>
<h4 id="LR-0-分析表构造算法"><a href="#LR-0-分析表构造算法" class="headerlink" title="LR(0)分析表构造算法"></a>LR(0)分析表构造算法</h4><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200411191129405.png" alt="image-20200411191129405"></p>
<blockquote>
<p>  先求出项集族；然后再填表：action；goto；规约；acc</p>
</blockquote>
<h4 id="LR-0-分析过程中的冲突"><a href="#LR-0-分析过程中的冲突" class="headerlink" title="LR(0) 分析过程中的冲突"></a>LR(0) 分析过程中的冲突</h4><ul>
<li>移进/归约冲突</li>
</ul>
<p>即有移进又有规约</p>
<ul>
<li>归约/归约冲突</li>
</ul>
<p>多种规约</p>
<blockquote>
<p>  接下来的算法解决这些问题</p>
</blockquote>
<h2 id="第七讲-语法分析4-2020-4-11"><a href="#第七讲-语法分析4-2020-4-11" class="headerlink" title="第七讲 语法分析4 2020-4-11"></a>第七讲 语法分析4 2020-4-11</h2><h3 id="4-12-SLR分析"><a href="#4-12-SLR分析" class="headerlink" title="4-12 SLR分析"></a>4-12 SLR分析</h3><blockquote>
<p>  归根结底，正确识别句柄</p>
</blockquote>
<h4 id="SLR分析法的基本思想"><a href="#SLR分析法的基本思想" class="headerlink" title="SLR分析法的基本思想"></a>SLR分析法的基本思想</h4><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200411191910317.png" alt="image-20200411191910317"></p>
<blockquote>
<p>  也叫SLR(1)；因为1可以省略，也叫SLR</p>
<p>  多看一个符号，根据下一个符号，仅用FOLLOW集合就可以判断是否规约</p>
</blockquote>
<h4 id="SLR分析表"><a href="#SLR分析表" class="headerlink" title="SLR分析表"></a>SLR分析表</h4><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200411204902385.png" alt="image-20200411204902385"></p>
<blockquote>
<p>  有点不同，黄色行，本来LR(0)是全r的，规约；现在有的要继续移入</p>
</blockquote>
<p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200411205434054.png" alt="image-20200411205434054"></p>
<blockquote>
<p>  移入的地方变成规约；规约主要是由空产生式规约</p>
</blockquote>
<h4 id="SLR-分析表构造算法"><a href="#SLR-分析表构造算法" class="headerlink" title="SLR 分析表构造算法"></a>SLR 分析表构造算法</h4><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200411205841591.png" alt="image-20200411205841591"></p>
<blockquote>
<p>  也就是看下一个字符是否规约；因为如果规约，下个字符那么必在follow集合中；否则不在</p>
</blockquote>
<p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200411213452666.png" alt="image-20200411213452666"></p>
<h4 id="SLR-分析中的冲突"><a href="#SLR-分析中的冲突" class="headerlink" title="SLR 分析中的冲突"></a>SLR 分析中的冲突</h4><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200411213724444.png" alt="image-20200411213724444"></p>
<h3 id="4-13-LR-1-分析"><a href="#4-13-LR-1-分析" class="headerlink" title="4-13 LR(1)分析"></a>4-13 LR(1)分析</h3><h4 id="LR-1-分析法的提出"><a href="#LR-1-分析法的提出" class="headerlink" title="LR(1)分析法的提出"></a>LR(1)分析法的提出</h4><p>SLR分析存在的问题</p>
<blockquote>
<p>  SLR只是简单地考察下一个输入符号b是否属于与归约项目A→α相关联的FOLLOW(A)，但b∈FOLLOW(A)只是归约α的一个必要条件，而非充分条件</p>
</blockquote>
<p>对于产生式A→α的归约，在不同使用位置，A会要求不同的后继符号</p>
<p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200411215122958.png" alt="image-20200411215122958"></p>
<p>在特定位置，A的后继符集合是FOLLOW(A)的子集</p>
<h4 id="规范LR-1-项目"><a href="#规范LR-1-项目" class="headerlink" title="规范LR(1)项目"></a>规范LR(1)项目</h4><p>将一般形式为[A→α·β, a]的项称为LR(1) 项，其中A→αβ 是一个产生式，a 是一个终结符(这里将$视为一个特殊的终结符)它表示在当前状态下，A后面必须紧跟的终结符，称为该项的展望符(lookahead)</p>
<ul>
<li>LR(1) 中的1指的是项的第二个分量的长度</li>
</ul>
<blockquote>
<p>  LR(k)向前展望k个符号</p>
</blockquote>
<ul>
<li>在形如[A→α·β, a]且β ≠ ε的项中，展望符a没有任何作用</li>
</ul>
<blockquote>
<p>  移入项目、待约项目是没有任何作用的</p>
</blockquote>
<ul>
<li>但是一个形如[A→α·, a]的项在只有在下一个输入符号等于a时才可以按照A→α 进行归约</li>
</ul>
<blockquote>
<p>  这样的a的集合总是FOLLOW(A)的子集，而且它通常是一个真子集</p>
</blockquote>
<h4 id="等价LR-1-项目"><a href="#等价LR-1-项目" class="headerlink" title="等价LR(1)项目"></a>等价LR(1)项目</h4><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200411224525016.png" alt="image-20200411224525016"></p>
<blockquote>
<p>  也就是说 ，有非终结符 就要加入等价项目</p>
</blockquote>
<h4 id="举例-2"><a href="#举例-2" class="headerlink" title="举例"></a>举例</h4><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200411224541548.png" alt="image-20200411224541548"></p>
<blockquote>
<p>  有些状态有相同的项目，但是状态中的语句数目等不同、展望符不同，不是同一个状态，如10、8</p>
<p>  LR(0)：规约状态就规约</p>
<p>  SLR：下一个字符在FOLLOW集才能规约</p>
<p>  LR(1)：与展望符相同才能规约，Follow集的子集</p>
</blockquote>
<p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200411225424852.png" alt="image-20200411225424852"></p>
<p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200411225515536.png" alt="image-20200411225515536"></p>
<h4 id="CLOSURE、goto函数变化"><a href="#CLOSURE、goto函数变化" class="headerlink" title="CLOSURE、goto函数变化"></a>CLOSURE、goto函数变化</h4><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200411230156797.png" alt="image-20200411230156797"></p>
<blockquote>
<p>  强调：对于展望符，可以理解为规约时的条件，即，下个字符是什么；只有对规约项目有意义</p>
</blockquote>
<p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200411230313391.png" alt="image-20200411230313391"></p>
<h4 id="LR分析表构造算法"><a href="#LR分析表构造算法" class="headerlink" title="LR分析表构造算法"></a>LR分析表构造算法</h4><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200411225704858.png" alt="image-20200411225704858"></p>
<h3 id="4-14-LALR分析"><a href="#4-14-LALR分析" class="headerlink" title="4-14 LALR分析"></a>4-14 LALR分析</h3><h2 id="第八讲-语法制导翻译1-2020-4-23"><a href="#第八讲-语法制导翻译1-2020-4-23" class="headerlink" title="第八讲 语法制导翻译1 2020-4-23"></a>第八讲 语法制导翻译1 2020-4-23</h2><h3 id="5-1-语法制导翻译概述"><a href="#5-1-语法制导翻译概述" class="headerlink" title="5-1 语法制导翻译概述"></a>5-1 语法制导翻译概述</h3><h4 id="什么是语法制导翻译"><a href="#什么是语法制导翻译" class="headerlink" title="什么是语法制导翻译"></a>什么是语法制导翻译</h4><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200423131037338.png" alt="image-20200423131037338"></p>
<h4 id="语法制导翻译的基本思想"><a href="#语法制导翻译的基本思想" class="headerlink" title="语法制导翻译的基本思想"></a>语法制导翻译的基本思想</h4><p>为CFG中的文法符号设置语义属性，用来表示语法成分对应的语义信息</p>
<p>文法符号的语义属性值是用与文法符号所在产生式（语法规则）相关联的语义规则来计算的</p>
<p>对于给定的输入串x ，构建x的语法分析树，并利用与产生式（语法规则）相关联的语义规则来计算分析树中各结点对应的语义属性值</p>
<h4 id="两个概念"><a href="#两个概念" class="headerlink" title="两个概念"></a>两个概念</h4><p>将语义规则同语法规则（产生式）联系起来要涉及两个概念</p>
<ul>
<li><p>语法制导定义(Syntax-Directed Definitions, SDD )</p>
</li>
<li><p>语法制导翻译方案(Syntax-Directed Translation Scheme , SDT )</p>
</li>
</ul>
<h4 id="语法制导定义-SDD"><a href="#语法制导定义-SDD" class="headerlink" title="语法制导定义(SDD)"></a>语法制导定义(SDD)</h4><p>SDD是对CFG的推广</p>
<ul>
<li><p>将每个文法符号和一个语义属性集合相关联</p>
</li>
<li><p>将每个产生式和一组语义规则相关联，这些规则用于计算该产生式中各文法符号的属性值</p>
</li>
</ul>
<p>例：如果X是一个文法符号，a是X的一个属性，则用X.a表示属性a在某个标号为X的分析树结点上的值</p>
<p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200423131708248.png" alt="image-20200423131708248"></p>
<h4 id="语法制导翻译方案-SDT"><a href="#语法制导翻译方案-SDT" class="headerlink" title="语法制导翻译方案(SDT)"></a>语法制导翻译方案(SDT)</h4><p>SDT是在产生式右部嵌入了程序片段的CFG，这些程序片段称为<strong>语义动作</strong>。</p>
<p>按照惯例，语义动作放在花括号内</p>
<p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200423131811998.png" alt="image-20200423131811998"></p>
<p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200423131918185.png" alt="image-20200423131918185"></p>
<h3 id="5-2-语法制导定义SDD"><a href="#5-2-语法制导定义SDD" class="headerlink" title="5-2 语法制导定义SDD"></a>5-2 语法制导定义SDD</h3><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200423131956018.png" alt="image-20200423131956018"></p>
<h4 id="综合属性-synthesized-attribute"><a href="#综合属性-synthesized-attribute" class="headerlink" title="综合属性(synthesized attribute)"></a>综合属性(synthesized attribute)</h4><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200423132027206.png" alt="image-20200423132027206"></p>
<h4 id="继承属性-inherited-attribute"><a href="#继承属性-inherited-attribute" class="headerlink" title="继承属性(inherited attribute)"></a>继承属性(inherited attribute)</h4><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200423132051536.png" alt="image-20200423132051536"></p>
<h4 id="举例-3"><a href="#举例-3" class="headerlink" title="举例"></a>举例</h4><blockquote>
<p>  算术表达式</p>
</blockquote>
<p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200423132128113.png" alt="image-20200423132128113"></p>
<blockquote>
<p>  声明语句</p>
</blockquote>
<p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200423132133635.png" alt="image-20200423132133635"></p>
<h4 id="属性文法-Attribute-Grammar"><a href="#属性文法-Attribute-Grammar" class="headerlink" title="属性文法(Attribute Grammar)"></a>属性文法(Attribute Grammar)</h4><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200423132257281.png" alt="image-20200423132257281"></p>
<blockquote>
<p>  没有副作用的？</p>
</blockquote>
<h3 id="5-3-SDD的求值顺序"><a href="#5-3-SDD的求值顺序" class="headerlink" title="5-3 SDD的求值顺序"></a>5-3 SDD的求值顺序</h3><p>SDD为CFG中的文法符号设置语义属性。对于给定的输入串x，应用语义规则计算分析树中各结点对应的属性值</p>
<p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200423132754444.png" alt="image-20200423132754444"></p>
<h4 id="依赖图-Dependency-Graph"><a href="#依赖图-Dependency-Graph" class="headerlink" title="依赖图(Dependency Graph)"></a>依赖图(Dependency Graph)</h4><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200423133014978.png" alt="image-20200423133014978"></p>
<blockquote>
<p>  综合属性在右边，继承属性在左边</p>
<p>  虚节点：</p>
</blockquote>
<p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200423133102255.png" alt="image-20200423133102255"></p>
<h4 id="属性值的计算顺序"><a href="#属性值的计算顺序" class="headerlink" title="属性值的计算顺序"></a>属性值的计算顺序</h4><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200423133325543.png" alt="image-20200423133325543"></p>
<blockquote>
<p>  排序不止一种</p>
</blockquote>
<p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200423133335976.png" alt="image-20200423133335976"></p>
<p>对于只具有综合属性的SDD ，可以按照任何自底向上的顺序计算它们的值</p>
<p>对于同时具有继承属性和综合属性的SDD，不能保证存在一个顺序来对各个节点上的属性进行求值</p>
<p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200423133526296.png" alt="image-20200423133526296"></p>
<blockquote>
<p>  这里的前两点 不是很懂，但似乎不影响</p>
<p>  期望的是自顶向下的实现</p>
</blockquote>
<p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200423133804545.png" alt="image-20200423133804545"></p>
<h3 id="5-4-S-属性定义与L-属性定义"><a href="#5-4-S-属性定义与L-属性定义" class="headerlink" title="5-4 S-属性定义与L-属性定义"></a>5-4 S-属性定义与L-属性定义</h3><h4 id="S-属性定义"><a href="#S-属性定义" class="headerlink" title="S-属性定义"></a>S-属性定义</h4><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200423133948671.png" alt="image-20200423133948671"></p>
<blockquote>
<p>  LR？</p>
</blockquote>
<h4 id="L-属性定义"><a href="#L-属性定义" class="headerlink" title="L-属性定义"></a>L-属性定义</h4><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200423134007809.png" alt="image-20200423134007809"></p>
<p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200423134031790.png" alt="image-20200423134031790"></p>
<p>S-SDD只有综合属性，L-SDD没有限制综合属性</p>
<blockquote>
<p>  依赖的只有三种：</p>
<p>  父亲的继承属性、左边的属性、本身的属性</p>
</blockquote>
<p>A为什么不能是综合属性？</p>
<p>会造成循环依赖</p>
<p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200423135338493.png" alt="image-20200423135338493"></p>
<p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200423135431601.png" alt="image-20200423135431601"></p>
<h2 id="第九讲-语法制导翻译2-2020-4-23"><a href="#第九讲-语法制导翻译2-2020-4-23" class="headerlink" title="第九讲 语法制导翻译2 2020-4-23"></a>第九讲 语法制导翻译2 2020-4-23</h2><h3 id="5-5-语法制导翻译方案SDT"><a href="#5-5-语法制导翻译方案SDT" class="headerlink" title="5-5 语法制导翻译方案SDT"></a>5-5 语法制导翻译方案SDT</h3><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200423140556226.png" alt="image-20200423140556226"></p>
<p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200423140615425.png" alt="image-20200423140615425"></p>
<h4 id="将S-SDD转换为SDT"><a href="#将S-SDD转换为SDT" class="headerlink" title="将S-SDD转换为SDT"></a>将S-SDD转换为SDT</h4><p>子节点都是综合属性，所以要放在最后</p>
<p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200423140903983.png" alt="image-20200423140903983"></p>
<blockquote>
<p>  当规约发生的时候，执行语法动作</p>
<p>  需要扩展分析栈</p>
</blockquote>
<h4 id="将L-SDD转换为SDT"><a href="#将L-SDD转换为SDT" class="headerlink" title="将L-SDD转换为SDT"></a>将L-SDD转换为SDT</h4><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200423141602795.png" alt="image-20200423141602795"></p>
<p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200423141613738.png" alt="image-20200423141613738"></p>
<h4 id="L-属性定义的SDT-实现"><a href="#L-属性定义的SDT-实现" class="headerlink" title="L-属性定义的SDT 实现"></a>L-属性定义的SDT 实现</h4><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200423142808970.png" alt="image-20200423142808970"></p>
<blockquote>
<p>  可以通过三种方式实现：</p>
<p>  前两种都是LL分析类型，LL文法</p>
<p>  最后是LR分析过程中翻译</p>
</blockquote>
<h3 id="5-6-在非递归的预测分析过程中进行翻译"><a href="#5-6-在非递归的预测分析过程中进行翻译" class="headerlink" title="5-6 在非递归的预测分析过程中进行翻译"></a>5-6 在非递归的预测分析过程中进行翻译</h3><blockquote>
<p>  L-SDD 的非递归实现，是自顶向下的方法</p>
</blockquote>
<p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200423142929394.png" alt="image-20200423142929394"></p>
<blockquote>
<p>  例子：待续</p>
</blockquote>
<h2 id="第十讲-语法制导翻译3-2020-4-23"><a href="#第十讲-语法制导翻译3-2020-4-23" class="headerlink" title="第十讲 语法制导翻译3 2020-4-23"></a>第十讲 语法制导翻译3 2020-4-23</h2><h3 id="5-7-在递归的预测分析过程进行翻译"><a href="#5-7-在递归的预测分析过程进行翻译" class="headerlink" title="5-7 在递归的预测分析过程进行翻译"></a>5-7 在递归的预测分析过程进行翻译</h3><blockquote>
<p>  非终结符的过程进行扩展，与递归下降分析法对于</p>
</blockquote>
<p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200423144842938.png" alt="image-20200423144842938"></p>
<p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200423144858629.png" alt="image-20200423144858629"></p>
<p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200423144904356.png" alt="image-20200423144904356"></p>
<p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200423144910379.png" alt="image-20200423144910379"></p>
<h4 id="算法："><a href="#算法：" class="headerlink" title="算法："></a>算法：</h4><p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200423144956734.png" alt="image-20200423144956734"></p>
<p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200423150937355.png" alt="image-20200423150937355"></p>
<h3 id="5-8-L-属性定义的自底向上翻译"><a href="#5-8-L-属性定义的自底向上翻译" class="headerlink" title="5-8 L-属性定义的自底向上翻译"></a>5-8 L-属性定义的自底向上翻译</h3><blockquote>
<p>  毫无疑问：S-SDD 可以直接自底向上</p>
</blockquote>
<p>给定一个以LL文法为基础的L-SDD，可以修改这个文法，并在LR语法分析过程中计算这个新文法之上的SDD</p>
<blockquote>
<p>  也就是说LL文法，通过LR语法分析来建立SDD</p>
<p>  方法：就是替换；空产生式；</p>
<p>  我们会发现用到的属性不在产生式中，但LR用的是栈，可以找到</p>
<p>  举例：带续：</p>
</blockquote>
<p><img src="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20200423151156097.png" alt="image-20200423151156097"></p>
<h2 id="第十一讲-中间代码生成1"><a href="#第十一讲-中间代码生成1" class="headerlink" title="第十一讲 中间代码生成1"></a>第十一讲 中间代码生成1</h2></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://chen2511.github.io/">MomoChen</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://chen2511.github.io/">http://chen2511.github.io/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">此文章版权归 MomoChen 所有，如有转载，请注明来自原作者</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%BC%96%E8%AF%91%E5%99%A8/">编译器</a><a class="post-meta__tags" href="/tags/%E6%85%95%E8%AF%BE/">慕课</a><a class="post-meta__tags" href="/tags/%E7%AC%94%E8%AE%B0/">笔记</a></div><div class="post_share"><div class="social-share" data-image="/img/1575009542094.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/gh/overtrue/share.js@master/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2020/07/05/ComplierC0/C0%E6%96%87%E6%B3%95/"><img class="prev-cover" src="/img/1575009542094.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">C0文法</div></div></a></div><div class="next-post pull-right"><a href="/2020/06/26/SearchEngine/%E7%AE%80%E5%8D%95%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/"><img class="next-cover" src="/img/003-%E5%A4%A9%E7%A9%BA%E4%B9%8B%E5%A2%83.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">简单搜索引擎</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2020/07/05/ComplierC0/C0%E6%96%87%E6%B3%95/" title="C0文法"><img class="cover" src="/img/1575009542094.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-07-05</div><div class="title">C0文法</div></div></a></div><div><a href="/2020/07/06/ComplierC0/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%B4%E6%98%8E/" title="ComplierC0"><img class="cover" src="/img/complier.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-07-06</div><div class="title">ComplierC0</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E8%AE%B2-%E7%BB%AA%E8%AE%BA"><span class="toc-text">第一讲 绪论</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%AD%E4%B9%89%E5%88%86%E6%9E%90"><span class="toc-text">语义分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%AD%E4%B9%89%E5%88%86%E6%9E%90%E7%9A%84%E4%B8%BB%E8%A6%81%E4%BB%BB%E5%8A%A1"><span class="toc-text">语义分析的主要任务</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E8%AE%B2-%E8%AF%AD%E8%A8%80%E5%8F%8A%E5%85%B6%E6%96%87%E6%B3%95-2020-4-14"><span class="toc-text">第二讲 语言及其文法 2020-4-14</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-text">2.1 基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E6%AF%8D%E8%A1%A8"><span class="toc-text">字母表</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AD%97%E6%AF%8D%E8%A1%A8%E4%B8%8A%E7%9A%84%E8%BF%90%E7%AE%97"><span class="toc-text">字母表上的运算</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%B2"><span class="toc-text">串</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%B2%E7%9A%84%E8%BF%90%E7%AE%97"><span class="toc-text">串的运算</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E6%96%87%E6%B3%95%E5%AE%9A%E4%B9%89"><span class="toc-text">2.2 文法定义</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E6%B3%95%E7%9A%84%E5%BD%A2%E5%BC%8F%E5%8C%96%E5%AE%9A%E4%B9%89"><span class="toc-text">文法的形式化定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%A7%E7%94%9F%E5%BC%8F%E7%9A%84%E7%AE%80%E5%86%99-lt-gt"><span class="toc-text">产生式的简写&lt;!&gt;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%A6%E5%8F%B7%E7%BA%A6%E5%AE%9A"><span class="toc-text">符号约定</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E8%AF%AD%E8%A8%80%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-text">2.3 语言的定义</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A8%E5%AF%BC%E4%B8%8E%E8%A7%84%E7%BA%A6"><span class="toc-text">推导与规约</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%A5%E5%9E%8B%E5%92%8C%E5%8F%A5%E5%AD%90"><span class="toc-text">句型和句子</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%AD%E8%A8%80%E7%9A%84%E5%BD%A2%E5%BC%8F%E5%8C%96%E5%AE%9A%E4%B9%89"><span class="toc-text">语言的形式化定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%AD%E8%A8%80%E7%9A%84%E8%BF%90%E7%AE%97"><span class="toc-text">语言的运算</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E6%96%87%E6%B3%95%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-text">2.4 文法的分类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#0%E5%9E%8B%E6%96%87%E6%B3%95"><span class="toc-text">0型文法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E5%9E%8B%E6%96%87%E6%B3%95"><span class="toc-text">1型文法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E5%9E%8B%E6%96%87%E6%B3%95"><span class="toc-text">2型文法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E5%9E%8B%E6%96%87%E6%B3%95"><span class="toc-text">3型文法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E7%B3%BB"><span class="toc-text">关系</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-CFG%E7%9A%84%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E6%A0%91"><span class="toc-text">2.5 CFG的语法分析树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9F%AD%E8%AF%AD%E5%92%8C%E7%9B%B4%E6%8E%A5%E7%9F%AD%E8%AF%AD"><span class="toc-text">短语和直接短语</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E4%B9%89%E6%80%A7%E6%96%87%E6%B3%95"><span class="toc-text">二义性文法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E8%AE%B2-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90-2020-4-14"><span class="toc-text">第三讲 词法分析 2020-4-14</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-text">3.1 正则表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-text">正则表达式的定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%A3%E8%A7%84%E5%BC%8F%E7%AE%80%E5%8C%96"><span class="toc-text">正规式简化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%A3%E8%A7%84%E5%BC%8F%E7%AE%80%E5%8C%962"><span class="toc-text">正规式简化2</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BE%E4%BE%8B"><span class="toc-text">举例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%A3%E5%88%99%E8%AF%AD%E8%A8%80"><span class="toc-text">正则语言</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RE%E7%9A%84%E4%BB%A3%E6%95%B0%E5%AE%9A%E5%BE%8B"><span class="toc-text">RE的代数定律</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E6%AD%A3%E5%88%99%E5%AE%9A%E4%B9%89"><span class="toc-text">3.2 正则定义</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BE%E4%BE%8B-1"><span class="toc-text">举例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E6%9C%89%E7%A9%B7%E8%87%AA%E5%8A%A8%E6%9C%BA"><span class="toc-text">3.3 有穷自动机</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#FA%E7%9A%84%E8%A1%A8%E7%A4%BA"><span class="toc-text">FA的表示</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BD%AC%E6%8D%A2%E5%9B%BE"><span class="toc-text">转换图</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#FA%E5%AE%9A%E4%B9%89%EF%BC%88%E6%8E%A5%E6%94%B6%EF%BC%89%E7%9A%84%E8%AF%AD%E8%A8%80"><span class="toc-text">FA定义（接收）的语言</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2%E5%8C%B9%E9%85%8D%E5%8E%9F%E5%88%99-LongestString-MatchingPrinciple"><span class="toc-text">最长子串匹配原则(LongestString MatchingPrinciple)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-%E6%9C%89%E7%A9%B7%E8%87%AA%E5%8A%A8%E6%9C%BA%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-text">3.4 有穷自动机的分类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E7%A1%AE%E5%AE%9A%E7%9A%84%E6%9C%89%E7%A9%B7%E8%87%AA%E5%8A%A8%E6%9C%BA-DFA"><span class="toc-text">1、确定的有穷自动机(DFA)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E9%9D%9E%E7%A1%AE%E5%AE%9A%E7%9A%84%E6%9C%89%E7%A9%B7%E8%87%AA%E5%8A%A8%E6%9C%BA-NFA"><span class="toc-text">2、非确定的有穷自动机(NFA)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DFA%E5%92%8CNFA%E7%9A%84%E7%AD%89%E4%BB%B7%E6%80%A7"><span class="toc-text">DFA和NFA的等价性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81%E5%B8%A6%E6%9C%89%E2%80%9C%CE%B5-%E8%BE%B9%E2%80%9D%E7%9A%84NFA"><span class="toc-text">3、带有“ε-边”的NFA</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%A6%E6%9C%89%E5%92%8C%E4%B8%8D%E5%B8%A6%E6%9C%89%E2%80%9C%CE%B5-%E8%BE%B9%E2%80%9D%E7%9A%84NFA-%E7%9A%84%E7%AD%89%E4%BB%B7%E6%80%A7"><span class="toc-text">带有和不带有“ε-边”的NFA 的等价性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E3%80%81DFA%E7%9A%84%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0-lt-lt-gt-gt"><span class="toc-text">4、DFA的算法实现 &lt;&lt;!!!&gt;&gt;</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#louden-%E4%B9%A6%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-text">louden 书的实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-%E4%BB%8E%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%88%B0%E6%9C%89%E7%A9%B7%E8%87%AA%E5%8A%A8%E6%9C%BA"><span class="toc-text">3.5 从正则表达式到有穷自动机</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B9%E6%8D%AERE-%E6%9E%84%E9%80%A0NFA"><span class="toc-text">根据RE 构造NFA</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-%E4%BB%8ENFA%E5%88%B0DFA%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-text">3.6 从NFA到DFA的转换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8ENFA%E5%88%B0DFA%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-text">从NFA到DFA的转换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8E%E5%B8%A6%E6%9C%89%CE%B5-%E8%BE%B9%E7%9A%84NFA%E5%88%B0DFA%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-text">从带有ε-边的NFA到DFA的转换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%90%E9%9B%86%E6%9E%84%E9%80%A0%E6%B3%95%EF%BC%88subset-construction%EF%BC%89"><span class="toc-text">子集构造法（subset construction）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%BC%E4%B9%8E%E6%B2%A1%E6%9C%89%E6%9C%80%E5%B0%8F%E5%8C%96DFA"><span class="toc-text">似乎没有最小化DFA</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-7-%E8%AF%86%E5%88%AB%E5%8D%95%E8%AF%8D%E7%9A%84DFA"><span class="toc-text">3.7 识别单词的DFA</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#DFA%E4%B8%BE%E4%BE%8B"><span class="toc-text">DFA举例</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81%E8%AF%86%E5%88%AB%E6%A0%87%E8%AF%86%E7%AC%A6%E7%9A%84DFA"><span class="toc-text">1、识别标识符的DFA</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E3%80%81%E8%AF%86%E5%88%AB%E6%97%A0%E7%AC%A6%E5%8F%B7%E6%95%B0%E7%9A%84DFA"><span class="toc-text">2、识别无符号数的DFA</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%E3%80%81%E8%AF%86%E5%88%AB%E5%90%84%E8%BF%9B%E5%88%B6%E6%97%A0%E7%AC%A6%E5%8F%B7%E6%95%B4%E6%95%B0%E7%9A%84DFA"><span class="toc-text">3、识别各进制无符号整数的DFA</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4%E3%80%81%E8%AF%86%E5%88%AB%E6%B3%A8%E9%87%8A%E7%9A%84DFA"><span class="toc-text">4、识别注释的DFA</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5%E3%80%81%E8%AF%86%E5%88%ABToken"><span class="toc-text">5、识别Token</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%E9%98%B6%E6%AE%B5%E7%9A%84%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86-lt-lt-gt-gt"><span class="toc-text">词法分析阶段的错误处理&lt;&lt;!!!&gt;&gt;</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%E9%98%B6%E6%AE%B5%E5%8F%AF%E6%A3%80%E6%B5%8B%E9%94%99%E8%AF%AF%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-text">词法分析阶段可检测错误的类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AF%8D%E6%B3%95%E9%94%99%E8%AF%AF%E6%A3%80%E6%B5%8B"><span class="toc-text">词法错误检测</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86"><span class="toc-text">错误处理</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E8%AE%B2-%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%901-2020-4-3"><span class="toc-text">第四讲 语法分析1 2020-4-3</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E5%88%86%E6%9E%90%E6%A6%82%E8%BF%B0"><span class="toc-text">4.1 自顶向下分析概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E6%96%87%E6%B3%95%E8%BD%AC%E6%8D%A2"><span class="toc-text">4.2 文法转换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E6%B6%88%E9%99%A4%E7%9B%B4%E6%8E%A5%E5%B7%A6%E9%80%92%E5%BD%92"><span class="toc-text">1、消除直接左递归</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E6%B6%88%E9%99%A4%E9%97%B4%E6%8E%A5%E5%B7%A6%E9%80%92%E5%BD%92"><span class="toc-text">2、消除间接左递归</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B6%88%E9%99%A4%E5%B7%A6%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95%EF%BC%9A"><span class="toc-text">消除左递归算法：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81%E6%8F%90%E5%8F%96%E5%B7%A6%E5%85%AC%E5%9B%A0%E5%AD%90%E7%AE%97%E6%B3%95"><span class="toc-text">3、提取左公因子算法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-LL-1-%E6%96%87%E6%B3%95"><span class="toc-text">4.3 LL(1)文法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#S-%E6%96%87%E6%B3%95"><span class="toc-text">S_文法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%9E%E7%BB%88%E7%BB%93%E7%AC%A6A%E7%9A%84%E5%90%8E%E7%BB%A7%E7%AC%A6%E5%8F%B7%E9%9B%86-FOLLOW"><span class="toc-text">非终结符A的后继符号集 FOLLOW</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%A7%E7%94%9F%E5%BC%8F%E7%9A%84%E5%8F%AF%E9%80%89%E9%9B%86-SELECT"><span class="toc-text">产生式的可选集 SELECT</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%B2%E9%A6%96%E7%BB%88%E7%BB%93%E7%AC%A6%E9%9B%86-FIRST"><span class="toc-text">串首终结符集 FIRST</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LL-1-%E6%96%87%E6%B3%95"><span class="toc-text">LL(1)文法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-FIRST%E9%9B%86%E5%92%8CFOLLOW%E9%9B%86%E7%9A%84%E8%AE%A1%E7%AE%97"><span class="toc-text">4.4 FIRST集和FOLLOW集的计算</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#FIRST%E9%9B%86%E5%90%88"><span class="toc-text">FIRST集合</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%9E%E7%BB%88%E7%BB%93%E7%AC%A6%E7%9A%84Follow%E9%9B%86%E8%AE%A1%E7%AE%97"><span class="toc-text">非终结符的Follow集计算</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SELECT-%E9%9B%86%E5%90%88%E8%AE%A1%E7%AE%97"><span class="toc-text">SELECT 集合计算</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%94%E8%AE%B2-%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%902-2020-4-3"><span class="toc-text">第五讲 语法分析2 2020-4-3</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-%E9%80%92%E5%BD%92%E7%9A%84%E9%A2%84%E6%B5%8B%E5%88%86%E6%9E%90%E6%B3%95"><span class="toc-text">4.5 递归的预测分析法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-6-%E9%9D%9E%E9%80%92%E5%BD%92%E7%9A%84%E9%A2%84%E6%B5%8B%E5%88%86%E6%9E%90%E6%B3%95"><span class="toc-text">4.6 非递归的预测分析法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AF%B9%E6%AF%94"><span class="toc-text">对比</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-7-%E9%A2%84%E6%B5%8B%E5%88%86%E6%9E%90%E4%B8%AD%E7%9A%84%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86"><span class="toc-text">4.7 预测分析中的错误处理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%81%90%E6%85%8C%E6%A8%A1%E5%BC%8F"><span class="toc-text">恐慌模式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%85%AD%E8%AE%B2-%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%903-2020-4-10"><span class="toc-text">第六讲 语法分析3 2020-4-10</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-8-%E8%87%AA%E5%BA%95%E5%90%91%E4%B8%8A%E7%9A%84%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90"><span class="toc-text">4-8 自底向上的语法分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A7%BB%E5%85%A5-%E5%BD%92%E7%BA%A6%E5%88%86%E6%9E%90%E5%99%A8"><span class="toc-text">移入-归约分析器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A7%BB%E5%85%A5-%E5%BD%92%E7%BA%A6%E5%88%86%E6%9E%90%E4%B8%AD%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-text">移入-归约分析中存在的问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-9-LR-%E5%88%86%E6%9E%90%E6%B3%95%E6%A6%82%E8%BF%B0"><span class="toc-text">4-9 LR 分析法概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#LR-%E5%88%86%E6%9E%90%E6%B3%95%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="toc-text">LR 分析法的基本原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LR-%E5%88%86%E6%9E%90%E5%99%A8%EF%BC%88%E8%87%AA%E5%8A%A8%E6%9C%BA%EF%BC%89%E7%9A%84%E6%80%BB%E4%BD%93%E7%BB%93%E6%9E%84"><span class="toc-text">LR 分析器（自动机）的总体结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LR-%E5%88%86%E6%9E%90%E8%A1%A8%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-text">LR 分析表的结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LR-%E5%88%86%E6%9E%90%E5%99%A8%E7%9A%84%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B"><span class="toc-text">LR 分析器的工作过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LR-%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95"><span class="toc-text">LR 分析算法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-10-LR-0-%E5%88%86%E6%9E%90"><span class="toc-text">4-10 LR(0)分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#LR-0-%E9%A1%B9%E7%9B%AE"><span class="toc-text">LR(0) 项目</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A2%9E%E5%B9%BF%E6%96%87%E6%B3%95"><span class="toc-text">增广文法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E6%B3%95%E4%B8%AD%E7%9A%84%E9%A1%B9%E7%9B%AE"><span class="toc-text">文法中的项目</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%8E%E7%BB%A7%E9%A1%B9%E7%9B%AE"><span class="toc-text">后继项目</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BE%E4%BE%8B%EF%BC%9A%E6%9E%84%E9%80%A0LR-0-%E8%87%AA%E5%8A%A8%E6%9C%BA"><span class="toc-text">举例：构造LR(0)自动机</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-11-LR-0-%E5%88%86%E6%9E%90%E8%A1%A8%E7%9A%84%E6%9E%84%E9%80%A0"><span class="toc-text">4-11 LR(0)分析表的构造</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#CLOSURE-%E5%87%BD%E6%95%B0"><span class="toc-text">CLOSURE( )函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#GOTO-%E5%87%BD%E6%95%B0"><span class="toc-text">GOTO ( )函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%84%E8%8C%83LR-0-%E9%A1%B9%E9%9B%86%E6%97%8F"><span class="toc-text">规范LR(0) 项集族</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LR-0-%E5%88%86%E6%9E%90%E8%A1%A8%E6%9E%84%E9%80%A0%E7%AE%97%E6%B3%95"><span class="toc-text">LR(0)分析表构造算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LR-0-%E5%88%86%E6%9E%90%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E5%86%B2%E7%AA%81"><span class="toc-text">LR(0) 分析过程中的冲突</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%83%E8%AE%B2-%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%904-2020-4-11"><span class="toc-text">第七讲 语法分析4 2020-4-11</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-12-SLR%E5%88%86%E6%9E%90"><span class="toc-text">4-12 SLR分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#SLR%E5%88%86%E6%9E%90%E6%B3%95%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3"><span class="toc-text">SLR分析法的基本思想</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SLR%E5%88%86%E6%9E%90%E8%A1%A8"><span class="toc-text">SLR分析表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SLR-%E5%88%86%E6%9E%90%E8%A1%A8%E6%9E%84%E9%80%A0%E7%AE%97%E6%B3%95"><span class="toc-text">SLR 分析表构造算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SLR-%E5%88%86%E6%9E%90%E4%B8%AD%E7%9A%84%E5%86%B2%E7%AA%81"><span class="toc-text">SLR 分析中的冲突</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-13-LR-1-%E5%88%86%E6%9E%90"><span class="toc-text">4-13 LR(1)分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#LR-1-%E5%88%86%E6%9E%90%E6%B3%95%E7%9A%84%E6%8F%90%E5%87%BA"><span class="toc-text">LR(1)分析法的提出</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%84%E8%8C%83LR-1-%E9%A1%B9%E7%9B%AE"><span class="toc-text">规范LR(1)项目</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AD%89%E4%BB%B7LR-1-%E9%A1%B9%E7%9B%AE"><span class="toc-text">等价LR(1)项目</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BE%E4%BE%8B-2"><span class="toc-text">举例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CLOSURE%E3%80%81goto%E5%87%BD%E6%95%B0%E5%8F%98%E5%8C%96"><span class="toc-text">CLOSURE、goto函数变化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LR%E5%88%86%E6%9E%90%E8%A1%A8%E6%9E%84%E9%80%A0%E7%AE%97%E6%B3%95"><span class="toc-text">LR分析表构造算法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-14-LALR%E5%88%86%E6%9E%90"><span class="toc-text">4-14 LALR分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%85%AB%E8%AE%B2-%E8%AF%AD%E6%B3%95%E5%88%B6%E5%AF%BC%E7%BF%BB%E8%AF%911-2020-4-23"><span class="toc-text">第八讲 语法制导翻译1 2020-4-23</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-%E8%AF%AD%E6%B3%95%E5%88%B6%E5%AF%BC%E7%BF%BB%E8%AF%91%E6%A6%82%E8%BF%B0"><span class="toc-text">5-1 语法制导翻译概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%AF%AD%E6%B3%95%E5%88%B6%E5%AF%BC%E7%BF%BB%E8%AF%91"><span class="toc-text">什么是语法制导翻译</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95%E5%88%B6%E5%AF%BC%E7%BF%BB%E8%AF%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3"><span class="toc-text">语法制导翻译的基本思想</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%A4%E4%B8%AA%E6%A6%82%E5%BF%B5"><span class="toc-text">两个概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95%E5%88%B6%E5%AF%BC%E5%AE%9A%E4%B9%89-SDD"><span class="toc-text">语法制导定义(SDD)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95%E5%88%B6%E5%AF%BC%E7%BF%BB%E8%AF%91%E6%96%B9%E6%A1%88-SDT"><span class="toc-text">语法制导翻译方案(SDT)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-%E8%AF%AD%E6%B3%95%E5%88%B6%E5%AF%BC%E5%AE%9A%E4%B9%89SDD"><span class="toc-text">5-2 语法制导定义SDD</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%BC%E5%90%88%E5%B1%9E%E6%80%A7-synthesized-attribute"><span class="toc-text">综合属性(synthesized attribute)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E5%B1%9E%E6%80%A7-inherited-attribute"><span class="toc-text">继承属性(inherited attribute)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BE%E4%BE%8B-3"><span class="toc-text">举例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7%E6%96%87%E6%B3%95-Attribute-Grammar"><span class="toc-text">属性文法(Attribute Grammar)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-SDD%E7%9A%84%E6%B1%82%E5%80%BC%E9%A1%BA%E5%BA%8F"><span class="toc-text">5-3 SDD的求值顺序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E8%B5%96%E5%9B%BE-Dependency-Graph"><span class="toc-text">依赖图(Dependency Graph)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7%E5%80%BC%E7%9A%84%E8%AE%A1%E7%AE%97%E9%A1%BA%E5%BA%8F"><span class="toc-text">属性值的计算顺序</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-S-%E5%B1%9E%E6%80%A7%E5%AE%9A%E4%B9%89%E4%B8%8EL-%E5%B1%9E%E6%80%A7%E5%AE%9A%E4%B9%89"><span class="toc-text">5-4 S-属性定义与L-属性定义</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#S-%E5%B1%9E%E6%80%A7%E5%AE%9A%E4%B9%89"><span class="toc-text">S-属性定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#L-%E5%B1%9E%E6%80%A7%E5%AE%9A%E4%B9%89"><span class="toc-text">L-属性定义</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B9%9D%E8%AE%B2-%E8%AF%AD%E6%B3%95%E5%88%B6%E5%AF%BC%E7%BF%BB%E8%AF%912-2020-4-23"><span class="toc-text">第九讲 语法制导翻译2 2020-4-23</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-5-%E8%AF%AD%E6%B3%95%E5%88%B6%E5%AF%BC%E7%BF%BB%E8%AF%91%E6%96%B9%E6%A1%88SDT"><span class="toc-text">5-5 语法制导翻译方案SDT</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%86S-SDD%E8%BD%AC%E6%8D%A2%E4%B8%BASDT"><span class="toc-text">将S-SDD转换为SDT</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%86L-SDD%E8%BD%AC%E6%8D%A2%E4%B8%BASDT"><span class="toc-text">将L-SDD转换为SDT</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#L-%E5%B1%9E%E6%80%A7%E5%AE%9A%E4%B9%89%E7%9A%84SDT-%E5%AE%9E%E7%8E%B0"><span class="toc-text">L-属性定义的SDT 实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-6-%E5%9C%A8%E9%9D%9E%E9%80%92%E5%BD%92%E7%9A%84%E9%A2%84%E6%B5%8B%E5%88%86%E6%9E%90%E8%BF%87%E7%A8%8B%E4%B8%AD%E8%BF%9B%E8%A1%8C%E7%BF%BB%E8%AF%91"><span class="toc-text">5-6 在非递归的预测分析过程中进行翻译</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E8%AE%B2-%E8%AF%AD%E6%B3%95%E5%88%B6%E5%AF%BC%E7%BF%BB%E8%AF%913-2020-4-23"><span class="toc-text">第十讲 语法制导翻译3 2020-4-23</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-7-%E5%9C%A8%E9%80%92%E5%BD%92%E7%9A%84%E9%A2%84%E6%B5%8B%E5%88%86%E6%9E%90%E8%BF%87%E7%A8%8B%E8%BF%9B%E8%A1%8C%E7%BF%BB%E8%AF%91"><span class="toc-text">5-7 在递归的预测分析过程进行翻译</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%EF%BC%9A"><span class="toc-text">算法：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-8-L-%E5%B1%9E%E6%80%A7%E5%AE%9A%E4%B9%89%E7%9A%84%E8%87%AA%E5%BA%95%E5%90%91%E4%B8%8A%E7%BF%BB%E8%AF%91"><span class="toc-text">5-8 L-属性定义的自底向上翻译</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E4%B8%80%E8%AE%B2-%E4%B8%AD%E9%97%B4%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%901"><span class="toc-text">第十一讲 中间代码生成1</span></a></li></ol></div></div></div></div></main><footer id="footer" style="background-image: url('/img/20150525233356_zkayE.png')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By MomoChen</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">欢迎来到漠漠的博客</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu@4/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>function addGitalkSource () {
  const ele = document.createElement('link')
  ele.rel = 'stylesheet'
  ele.href= 'https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css'
  document.getElementsByTagName('head')[0].appendChild(ele)
}

function loadGitalk () {
  function initGitalk () {
    var gitalk = new Gitalk(Object.assign({
      clientID: 'de79d51950505839a9fe',
      clientSecret: '9461941e93326020b9e565d3ef15d8b9d0513548',
      repo: 'chen2511.github.io',
      owner: 'chen2511',
      admin: ['chen2511'],
      id: '952b194338aef0a1d5ae37504cebe39a',
      updateCountCallback: commentCount
    },null))

    gitalk.render('gitalk-container')
  }

  if (typeof Gitalk === 'function') initGitalk()
  else {
    addGitalkSource()
    getScript('https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js').then(initGitalk)
  }
}

function commentCount(n){
  let isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
  if (isCommentCount) {
    isCommentCount.innerHTML= n
  }
}

if ('Gitalk' === 'Gitalk' || !false) {
  if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
  else loadGitalk()
} else {
  function loadOtherComment () {
    loadGitalk()
  }
}</script></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-nest.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>