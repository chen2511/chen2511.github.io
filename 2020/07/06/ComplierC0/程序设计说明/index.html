<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>ComplierC0 | MomoChen</title><meta name="keywords" content="编译器,C0文法,C++"><meta name="author" content="MomoChen"><meta name="copyright" content="MomoChen"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="来自NWPU课程《编译原理》试点班作业：编写一个C0文法的编译器。以递归下降子程序实现语法分析，输出AST，符号表，优化中间表达式，最终生成MIPS汇编代码。">
<meta property="og:type" content="article">
<meta property="og:title" content="ComplierC0">
<meta property="og:url" content="https://chen2511.github.io/2020/07/06/ComplierC0/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%B4%E6%98%8E/index.html">
<meta property="og:site_name" content="MomoChen">
<meta property="og:description" content="来自NWPU课程《编译原理》试点班作业：编写一个C0文法的编译器。以递归下降子程序实现语法分析，输出AST，符号表，优化中间表达式，最终生成MIPS汇编代码。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://chen2511.github.io/img/complier.png">
<meta property="article:published_time" content="2020-07-05T16:00:00.000Z">
<meta property="article:modified_time" content="2023-03-09T13:56:20.088Z">
<meta property="article:author" content="MomoChen">
<meta property="article:tag" content="编译器">
<meta property="article:tag" content="C0文法">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://chen2511.github.io/img/complier.png"><link rel="shortcut icon" href="/img/favicon.jpg"><link rel="canonical" href="https://chen2511.github.io/2020/07/06/ComplierC0/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%B4%E6%98%8E/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":1,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":800},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: true
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":500,"languages":{"author":"作者: MomoChen","link":"链接: ","source":"来源: MomoChen","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'mediumZoom',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'ComplierC0',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-03-09 21:56:20'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.2"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/favicon.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">34</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">24</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我的</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/complier_all.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">MomoChen</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我的</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">ComplierC0</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-07-05T16:00:00.000Z" title="发表于 2020-07-06 00:00:00">2020-07-06</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-03-09T13:56:20.088Z" title="更新于 2023-03-09 21:56:20">2023-03-09</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AF%BE%E7%A8%8B%E5%A4%A7%E4%BD%9C%E4%B8%9A/">课程大作业</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AF%BE%E7%A8%8B%E5%A4%A7%E4%BD%9C%E4%B8%9A/C0%E7%BC%96%E8%AF%91%E5%99%A8/">C0编译器</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">12.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>48分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="ComplierC0"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="CompilerC0"><a href="#CompilerC0" class="headerlink" title="CompilerC0"></a>CompilerC0</h1><p>来自NWPU课程《编译原理》试点班作业【2020年上】：编写一个C0文法的编译器。以递归下降子程序实现语法分析，输出AST，构建符号表，优化中间表达式，最终生成MIPS汇编代码。</p>
<blockquote>
<p>  项目地址：<a target="_blank" rel="noopener" href="https://github.com/chen2511/CompilerC0">chen2511/CompilerC0: C0 文法编译器 Visual Studio2019 (github.com)</a></p>
</blockquote>
<h2 id="项目统计信息"><a href="#项目统计信息" class="headerlink" title="项目统计信息"></a>项目统计信息</h2><blockquote>
<p>总代码规模：<code>4047行</code>（不计空行），注释比例为<code>21.7%</code><br>Visual Studio 2019， C++</p>
</blockquote>
<ul>
<li>global.h：全局数据结构、全局变量</li>
<li>scan.h：</li>
<li>scan.cpp：词法分析实现</li>
<li>parser.h：</li>
<li>parser.cpp：语法分析：递归下降分析</li>
<li>ast.h：</li>
<li>ast.cpp：AST创建不同类型节点、输出AST</li>
<li>symtab.h：</li>
<li>symtab.cpp：符号表基本操作：插入、查找、初始化</li>
<li>semantic.h：</li>
<li>semantic.cpp：遍历AST，构建符号表、语义检查</li>
</ul>
<h2 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    processFileName(<span class="number">8</span>);</span><br><span class="line">    <span class="comment">//if (2 == argc) &#123;</span></span><br><span class="line">    <span class="comment">//    sourcefilename = argv[1];</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line">    <span class="comment">//else &#123;</span></span><br><span class="line">    <span class="comment">//    cout &lt;&lt; &quot;error argvs!&quot; &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">//    exit(-1);</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line">        </span><br><span class="line">    sourceFile = fopen(sourcefilename.c_str(), <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    AST_File = fopen(astfilename.c_str(), <span class="string">&quot;w+&quot;</span>);</span><br></pre></td></tr></table></figure>
<p><code>main.cpp</code>主函数需要调整，有两种方式：</p>
<p>1、调试项目时，使用第三行<code>processFileName(8);</code>代码，即处理input文件夹下<code>8.c0</code>文件</p>
<p>或者使用4-11行代码，或者命令行参数输入，处理源文件名字；</p>
<p>2、Visual Studio 采用Release x86 模式进行编译，生成可执行文件。</p>
<p>格式：执行文件 源文件</p>
<p>例如：<code>.\CompilerC0-vs2019.exe .\Test12.c0</code></p>
<p>即可生成目标代码asm.txt</p>
<h1 id="一、文法设计"><a href="#一、文法设计" class="headerlink" title="一、文法设计"></a>一、文法设计</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>&lt;加法运算符&gt; ::= +｜-</span><br><span class="line"><span class="number">2.</span>&lt;乘法运算符&gt; ::= *｜/</span><br><span class="line"><span class="number">3.</span>&lt;关系运算符&gt; ::= &lt;｜&lt;=｜&gt;｜&gt;=｜!=｜==</span><br><span class="line"><span class="number">4.</span>&lt;逻辑运算符&gt; ::= &amp;&amp;  |  <span class="string">&#x27;|| &#x27;</span>  |  !</span><br><span class="line"><span class="number">5.</span>&lt;字母&gt; ::= ＿｜a｜．．．｜z｜A｜．．．｜Z</span><br><span class="line"><span class="number">6.</span>&lt;非零数字&gt; ::= <span class="number">1</span>｜．．．｜<span class="number">9</span></span><br><span class="line"><span class="number">7.</span>&lt;数字&gt; ::= <span class="number">0</span>｜&lt;非零数字&gt;</span><br><span class="line"><span class="number">8.</span>&lt;无符号整数&gt; ::= &lt;非零数字&gt;｛&lt;数字&gt;｝｜<span class="number">0</span></span><br><span class="line"><span class="number">9.</span>&lt;整数&gt; ::= ［＋｜－］&lt;无符号整数&gt;</span><br><span class="line"><span class="number">10.</span>&lt;字符&gt; ::= <span class="string">&#x27;&lt;加法运算符&gt;&#x27;</span>｜<span class="string">&#x27;&lt;乘法运算符&gt;&#x27;</span>｜<span class="string">&#x27;&lt;字母&gt;&#x27;</span>｜<span class="string">&#x27;&lt;数字&gt;&#x27;</span></span><br><span class="line"><span class="number">11.</span>&lt;字符串&gt; ::= <span class="string">&quot;｛十进制编码为32,33,35-126的ASCII字符｝&quot;</span></span><br><span class="line"><span class="number">12.</span>&lt;标识符&gt; ::= &lt;字母&gt;｛&lt;字母&gt;｜&lt;数字&gt;｝</span><br><span class="line"><span class="number">13.</span>&lt;程序&gt; ::= ［&lt;常量说明&gt;］［&lt;变量说明&gt;］&#123;&lt;有返回值函数定义&gt;|&lt;无返回值函数定义&gt;&#125;&lt;主函数&gt;</span><br><span class="line"><span class="number">14.</span>&lt;常量说明&gt; ::= <span class="type">const</span>&lt;常量定义&gt;;&#123; <span class="type">const</span>&lt;常量定义&gt;;&#125;</span><br><span class="line"><span class="number">15.</span>&lt;常量定义&gt; ::= <span class="type">int</span>&lt;标识符&gt;＝&lt;整数&gt;&#123;,&lt;标识符&gt;＝&lt;整数&gt;&#125;| <span class="type">char</span>&lt;标识符&gt;＝&lt;字符&gt;&#123;,&lt;标识符&gt;＝&lt;字符&gt;&#125;</span><br><span class="line"><span class="number">16.</span>&lt;变量说明&gt; ::= &lt;变量定义&gt;;&#123;&lt;变量定义&gt;;&#125;</span><br><span class="line"><span class="number">17.</span>&lt;变量定义&gt; ::= &lt;类型标识符&gt;&lt;标识符&gt;[‘[’&lt;无符号整数&gt;‘]’] &#123;,&lt;标识符&gt;[‘[’&lt;无符号整数&gt;‘]’]&#125;</span><br><span class="line"><span class="number">18.</span>&lt;类型标识符&gt; ::= <span class="type">int</span> | <span class="type">char</span></span><br><span class="line"><span class="number">19.</span>&lt;有返回值函数定义&gt; ::= &lt;声明头部&gt;‘(’&lt;参数表&gt;‘)’ ‘&#123;’&lt;复合语句&gt;‘&#125;’</span><br><span class="line"><span class="number">20.</span>&lt;声明头部&gt; ::= <span class="type">int</span>&lt;标识符&gt; | <span class="type">char</span>&lt;标识符&gt;</span><br><span class="line"><span class="number">21.</span>&lt;无返回值函数定义&gt; ::= <span class="type">void</span>&lt;标识符&gt;‘(’&lt;参数表&gt;‘)’ ‘&#123;’&lt;复合语句&gt;‘&#125;’</span><br><span class="line"><span class="number">22.</span>&lt;参数表&gt; ::= &lt;类型标识符&gt;&lt;标识符&gt;&#123;,&lt;类型标识符&gt;&lt;标识符&gt;&#125;| &lt;空&gt;</span><br><span class="line"><span class="number">23.</span>&lt;复合语句&gt; ::= ［&lt;常量说明&gt;］［&lt;变量说明&gt;］&lt;语句列&gt;</span><br><span class="line"><span class="number">24.</span>&lt;主函数&gt; ::= <span class="type">void</span> main ‘(’ ‘)’ ‘&#123;’&lt;复合语句&gt;‘&#125;’</span><br><span class="line"><span class="number">25.</span>&lt;语句列&gt; ::= ｛&lt;语句&gt;｝</span><br><span class="line"><span class="number">26.</span>&lt;语句&gt; ::= &lt;条件语句&gt;｜&lt;循环语句&gt;｜‘&#123;’&lt;语句列&gt;‘&#125;’｜&lt;有返回值的函数调用语句&gt;;｜&lt;无返回值的函数调用语句&gt;;｜&lt;赋值语句&gt;;｜&lt;读语句&gt;;｜&lt;写语句&gt;;｜&lt;空&gt;;｜&lt;返回语句&gt;;</span><br><span class="line"><span class="number">27.</span>&lt;赋值语句&gt; ::= &lt;标识符&gt;[‘[’&lt;算术表达式&gt;‘]’]＝&lt;算术表达式&gt;</span><br><span class="line"><span class="number">28.</span>&lt;条件语句&gt; ::= <span class="keyword">if</span> ‘(’&lt;布尔表达式&gt;‘)’&lt;语句&gt;［<span class="keyword">else</span>&lt;语句&gt;］</span><br><span class="line"><span class="number">29.</span>&lt;循环语句&gt; ::= <span class="keyword">while</span> ‘(’&lt;布尔表达式&gt;‘)’&lt;语句&gt;| <span class="keyword">for</span>‘(’&lt;赋值语句&gt;;&lt;布尔表达式&gt;;&lt;赋值语句&gt;‘)’&lt;语句&gt;</span><br><span class="line"><span class="number">30.</span>&lt;有返回值的函数调用语句&gt; ::= &lt;标识符&gt;‘(’&lt;值参数表&gt;‘)’</span><br><span class="line"><span class="number">31.</span>&lt;无返回值的函数调用语句&gt; ::= &lt;标识符&gt;‘(’&lt;值参数表&gt;‘)’</span><br><span class="line"><span class="number">32.</span>&lt;值参数表&gt; ::= &lt;算术表达式&gt;&#123;,&lt;算术表达式&gt;&#125;｜&lt;空&gt;</span><br><span class="line"><span class="number">33.</span>&lt;读语句&gt; ::= scanf ‘(’&lt;标识符&gt;&#123;,&lt;标识符&gt;&#125;‘)’</span><br><span class="line"><span class="number">34.</span>&lt;写语句&gt; ::= printf ‘(’&lt;字符串&gt;,&lt;算术表达式&gt;‘)’| printf ‘(’&lt;字符串&gt;‘)’| printf ‘(’&lt;算术表达式&gt;‘)’</span><br><span class="line"><span class="number">35.</span>&lt;返回语句&gt; ::= <span class="keyword">return</span>[‘(’&lt;算术表达式&gt;‘)’]</span><br><span class="line"><span class="number">36.</span>&lt;算术表达式&gt; ::= ［＋｜－］&lt;项&gt;&#123;&lt;加法运算符&gt;&lt;项&gt;&#125;</span><br><span class="line"><span class="number">37.</span>&lt;项&gt; ::= &lt;因子&gt;&#123;&lt;乘法运算符&gt;&lt;因子&gt;&#125;</span><br><span class="line"><span class="number">38.</span>&lt;因子&gt; ::= &lt;标识符&gt;｜&lt;标识符&gt;‘[’&lt;算术表达式&gt;‘]’｜&lt;无符号整数&gt;|&lt;字符&gt;｜&lt;有返回值函数调用语句&gt;|‘(’&lt;算术表达式&gt;‘)’</span><br><span class="line"><span class="number">39.</span>&lt;布尔表达式&gt; ::= &lt;布尔项&gt; &#123; ‘||’ &lt;布尔项&gt; &#125;</span><br><span class="line"><span class="number">40.</span>&lt;布尔项&gt; ::= &lt;布因子&gt;&#123; &amp;&amp; &lt;布因子&gt; &#125;</span><br><span class="line"><span class="number">41.</span>&lt;布因子&gt; ::= <span class="literal">false</span> | <span class="literal">true</span> | ! &lt;布因子&gt; | ‘(‘&lt;布尔表达式&gt;’)’ | &lt;条件因子&gt; [&lt;条件运算符&gt; &lt;条件因子&gt;]</span><br><span class="line"><span class="number">42.</span>&lt;条件因子&gt; ::= &lt;标识符&gt;[‘[’&lt;算术表达式&gt;‘]’]｜ &lt;无符号整数&gt; | &lt;字符&gt; | &lt;有返回值函数调用语句&gt;</span><br></pre></td></tr></table></figure>
<h1 id="二、词法分析"><a href="#二、词法分析" class="headerlink" title="二、词法分析"></a>二、词<strong><strong>法分析</strong></strong></h1><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>词法分析<code>作用</code>是将<code>字符流</code>的源代码归纳成<code>单词流</code>。通过<code>状态机</code>出几种类型的词：</p>
<ul>
<li>标识符、保留字（保留字先归类到标识符）</li>
<li>无符号整数</li>
<li>特殊符号（包括运算符、括号等等）</li>
<li>字符、字符串</li>
</ul>
<p>正常的<code>分析过程</code>：</p>
<blockquote>
<p><code>文法-正则表达式</code>-NFA-DFA-DFA最小化-<code>编程实现</code>（如果文法设计的好，简单，中间几步可以简略）</p>
</blockquote>
<p>状态机<code>代码实现</code>一般有两种：</p>
<ul>
<li>隐藏状态：如果状态少，可以通过代码的选择和循环结构控制状态。</li>
<li>双重case（本文使用）：第一重判断当前状态，第二重根据当前字符执行不同代码</li>
</ul>
<p>注意的问题有：</p>
<ul>
<li>读入缓冲：不直接操作文件指针，易于回溯与错误定位</li>
<li>保留字识别：先识别为标识符</li>
<li>带符号数处理：除了常量定义位置，表达式中都是无符号整数，带符号数用<code>0-num</code>处理</li>
</ul>
<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a><strong>正则表达式</strong></h2><p>标识符：<code>[_a-zA-Z][_a-zA-Z0-9]*</code></p>
<blockquote>
<p>三种类型：下划线、小写字母和大写字母，非数字开头</p>
</blockquote>
<p>无符号整数：<code>[1-9][0-9]*|0</code></p>
<blockquote>
<p>一位整数0-9、非0开头的多位无符号整数</p>
</blockquote>
<p>特殊符号：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> + - * /</span><br><span class="line"> &amp;&amp;  &#x27;||&#x27;  !</span><br><span class="line"> &lt; &lt;= &gt; &gt;= != ==</span><br><span class="line"> = ： , ; [ ] &#123; &#125; ( )</span><br></pre></td></tr></table></figure>
<p>字符：<code>&#39;[&lt;加法运算符&gt;｜&lt;乘法运算符&gt;｜&lt;字母&gt;｜&lt;数字&gt;]&#39;</code></p>
<p>字符串：<code>&quot;｛十进制编码为32,33,35-126的ASCII字符｝&quot;</code></p>
<h2 id="NFA-不确定有限自动机"><a href="#NFA-不确定有限自动机" class="headerlink" title="NFA 不确定有限自动机"></a><strong>NFA 不确定有限自动机</strong></h2><blockquote>
<p>Nondeterministic Finite Automata</p>
<p>有限自动机是一个抽象的概念，可以用两种 直观的方式—状态转换图和状态转换矩阵来 表示。有限表示状态有限。</p>
<p><img src="/2020/07/06/ComplierC0/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%B4%E6%98%8E/Untitled.png" alt="Untitled"></p>
<p>状态转换图是一个有向图，NFA中的<code>每个状态</code>对应转换图中的一个<code>节点</code>；</p>
<p>NFA中的每个<code>f函数</code>对应转换图中的一条<code>有向边</code>，该有向边从si 节点出发，进入sj节点，字符ch(或ε)是<code>边上的标记</code>;</p>
<p>NFA的<code>初态</code>是状态转换图中没有前驱的节点;</p>
<p><code>节点</code>一般用一个圆圈表示，</p>
<p><code>终态</code>节点用一个双圈表示。</p>
<p>举例：</p>
<p><img src="/2020/07/06/ComplierC0/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%B4%E6%98%8E/Untitled 1.png" alt="Untitled"></p>
<p><img src="/2020/07/06/ComplierC0/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%B4%E6%98%8E/Untitled 2.png" alt="Untitled"></p>
<p>NFA的<code>特点</code>是它的不确定性，即在当前状态下，对同一个字符ch，可能有<code>多于一个</code>的下一<code>状态转移</code>。</p>
</blockquote>
<h2 id="DFA-确定的有限自动机"><a href="#DFA-确定的有限自动机" class="headerlink" title="DFA 确定的有限自动机"></a><strong>DFA 确定的有限自动机</strong></h2><blockquote>
<p>DFA是NFA的一个特例，其中：</p>
<ul>
<li>没有状态具有ε状态转移(ε-transition)，即状 态转换图中没有标记ε的边；</li>
<li>对每一个状态s和每一个符号a，最多有一 个下一状态。</li>
</ul>
</blockquote>
<p>特性：对一个状态遇到一个字符，状态转移是唯一确定的</p>
<p>定理：NFA必有DFA与之对应。</p>
<h2 id="DFA-最小化"><a href="#DFA-最小化" class="headerlink" title="DFA 最小化"></a><strong>DFA 最小化</strong></h2><p>在确定DFA之后，还可以进一步简化状态数。</p>
<p>是唯一的。</p>
<blockquote>
<p>PPT里面有简化方法和例子。</p>
<p>Ch3</p>
</blockquote>
<h2 id="词法分析编程实现"><a href="#词法分析编程实现" class="headerlink" title="词法分析编程实现"></a><strong>词法分析编程实现</strong></h2><p>由于我们文法设计没有很复杂而且将不同token转化成正则表达式也不复杂，所以没有NFA-DFA最小化等步骤。</p>
<p>可以直接画出状态转换图，再编程实现。</p>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a><strong>数据结构</strong></h3><h3 id="1-Token"><a href="#1-Token" class="headerlink" title="1 Token"></a><strong>1 Token</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> typedef struct&#123;</span><br><span class="line">     TokenType opType;</span><br><span class="line">     char * value;</span><br><span class="line"> &#125;Token;</span><br></pre></td></tr></table></figure>
<h3 id="2-TokenType"><a href="#2-TokenType" class="headerlink" title="2 TokenType"></a><strong>2 TokenType</strong></h3><p>枚举类型</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> typedef enum &#123;</span><br><span class="line">     //关键字：</span><br><span class="line">     CHAR, CONST, ELSE, FALSE, FOR,              //0-4</span><br><span class="line">     IF, INT, MAIN, PRINTF, RETURN,              //5-9</span><br><span class="line">     SCANF, TRUE, VOID, WHILE,                   //10-13</span><br><span class="line">     NUM, IDEN, LETTER, STRING,                  //14-17:数字、标识符、字符、字符串</span><br><span class="line">     PLUS, MINU, MULT, DIV,                      //18-21:+ - * /</span><br><span class="line">     AND, OR, NOT,                               //22-24:&amp;&amp; || !</span><br><span class="line">     LSS, LEQ, GRE, GEQ, NEQ, EQL,               //25-30关系运算符: &lt; &lt;= &gt; &gt;= != ==</span><br><span class="line">     ASSIGN, COLON, COMMA, SEMICOLON,            //31-34: =  :  ,  ;</span><br><span class="line">     LBRACE, RBRACE, LBRACKET, RBRACKET,         //35-38:&#123; &#125; [ ]</span><br><span class="line">     LPARENTHES, RPARENTHES,                     //39-40:( )</span><br><span class="line"> &#125;TokenType;</span><br></pre></td></tr></table></figure>
<h3 id="3-保留字表"><a href="#3-保留字表" class="headerlink" title="3 保留字表"></a><strong>3 保留字表</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> const char* reservedWords[] = &#123;</span><br><span class="line">     &quot;case&quot;, &quot;char&quot;, &quot;const&quot;, &quot;default&quot;, &quot;else&quot;,</span><br><span class="line">     &quot;false&quot;, &quot;for&quot;, &quot;if&quot;, &quot;int&quot;, &quot;main&quot;,</span><br><span class="line">     &quot;printf&quot;, &quot;return&quot;, &quot;scanf&quot;, &quot;switch&quot;, &quot;true&quot;,</span><br><span class="line">     &quot;void&quot;, &quot;while&quot;</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>
<h3 id="4-状态"><a href="#4-状态" class="headerlink" title="4 状态"></a><strong>4 状态</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> typedef enum &#123;</span><br><span class="line">     STATE_START, STATE_NUM, STATE_ID, STATE_CHAR, STATE_STRING, STATE_DONE</span><br><span class="line"> &#125;StateType;</span><br></pre></td></tr></table></figure>
<p>用Token表示每一个词（词法分析的一次处理结果），里面包括两部分，tokentype表示类型；用char *表示一些有值的类型（数字、字符串）。</p>
<h3 id="DFA编程思想"><a href="#DFA编程思想" class="headerlink" title="DFA编程思想"></a><strong>DFA编程思想</strong></h3><blockquote>
<p>来自Louden书《编译原理与实践》的思路</p>
</blockquote>
<h3 id="1-通过代码位置表示隐含状态"><a href="#1-通过代码位置表示隐含状态" class="headerlink" title="1 通过代码位置表示隐含状态"></a><strong>1 通过代码位置表示隐含状态</strong></h3><p>if判断不同符号进入不同分支；循环表示不断读入当前状态的循环字符。</p>
<blockquote>
<p>注意<code>advance the input</code>表示读入一个符号</p>
<p><img src="/2020/07/06/ComplierC0/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%B4%E6%98%8E/Untitled 3.png" alt="Untitled"></p>
<p><img src="/2020/07/06/ComplierC0/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%B4%E6%98%8E/Untitled 4.png" alt="Untitled"></p>
</blockquote>
<h3 id="2-双重case"><a href="#2-双重case" class="headerlink" title="2 双重case"></a><strong>2 双重case</strong></h3><blockquote>
<p>实际用的就是这个</p>
</blockquote>
<p>专门设置一个变量表示当前状态，循环判断非end状态，内部使用双重case语句，第一重测试状态，第二重测试当前字符（进行状态转换）。</p>
<p><img src="/2020/07/06/ComplierC0/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%B4%E6%98%8E/Untitled 5.png" alt="Untitled"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从文件中逐步读入字符，输出token</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getNextToken</span><span class="params">()</span> </span>&#123;</span><br><span class="line">string tmpstr;</span><br><span class="line"><span class="type">char</span> ch;</span><br><span class="line">StateType state = STATE_START;</span><br><span class="line">g_lexBegin = g_forward;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (STATE_DONE != state) &#123;</span><br><span class="line">    ch = <span class="built_in">getNextChar</span>();</span><br><span class="line">    <span class="keyword">if</span> (EOF == ch) &#123;</span><br><span class="line">        g_token.opType = END;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (state)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> STATE_START: &#123;      <span class="comment">/////////////////////start</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&#x27; &#x27;</span> == ch || <span class="string">&#x27;\\t&#x27;</span> == ch || <span class="string">&#x27;\\n&#x27;</span> == ch) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">isdigit</span>(ch)) &#123;                  <span class="comment">//digital</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&#x27;0&#x27;</span> == ch) &#123;</span><br><span class="line">                state = STATE_DONE;</span><br><span class="line">                tmpstr += ch;</span><br><span class="line">                g_token.opType = TokenType::NUM;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                state = STATE_NUM;</span><br><span class="line">                tmpstr += ch;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">isalpha</span>(ch) || <span class="string">&#x27;_&#x27;</span> == ch) &#123;</span><br><span class="line">            state = STATE_ID;    <span class="comment">//标识符</span></span><br><span class="line">            tmpstr += ch;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&#x27;\\&#x27;</span><span class="string">&#x27; == ch) &#123;              //字符</span></span><br><span class="line"><span class="string">            state = STATE_CHAR;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">        else if (&#x27;</span><span class="string">&quot;&#x27; == ch) &#123;               //字符串</span></span><br><span class="line"><span class="string">            state = STATE_STRING;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">        else &#123;                              //一个或两个字符就到终态</span></span><br><span class="line"><span class="string">            state = STATE_DONE;</span></span><br><span class="line"><span class="string">            tmpstr += ch;</span></span><br><span class="line"><span class="string">            switch (ch) &#123;</span></span><br><span class="line"><span class="string">            case &#x27;+&#x27;:                       // +</span></span><br><span class="line"><span class="string">                g_token.opType = TokenType::PLUS;</span></span><br><span class="line"><span class="string">                break;</span></span><br><span class="line"><span class="string">            case &#x27;-&#x27;:                       // -</span></span><br><span class="line"><span class="string">                g_token.opType = TokenType::MINU;</span></span><br><span class="line"><span class="string">                break;</span></span><br><span class="line"><span class="string">            case &#x27;*&#x27;:                       // *</span></span><br><span class="line"><span class="string">                g_token.opType = TokenType::MULT;</span></span><br><span class="line"><span class="string">                break;</span></span><br><span class="line"><span class="string">            case &#x27;/&#x27;:                       // /</span></span><br><span class="line"><span class="string">                g_token.opType = TokenType::DIV;</span></span><br><span class="line"><span class="string">                break;</span></span><br><span class="line"><span class="string">            case &#x27;&amp;&#x27;:                       // &amp;&amp;</span></span><br><span class="line"><span class="string">                ch = getNextChar();</span></span><br><span class="line"><span class="string">                if (&#x27;&amp;&#x27; == ch) &#123;</span></span><br><span class="line"><span class="string">                    g_token.opType = TokenType::AND;</span></span><br><span class="line"><span class="string">                    tmpstr += ch;</span></span><br><span class="line"><span class="string">                &#125;</span></span><br><span class="line"><span class="string">                else &#123;</span></span><br><span class="line"><span class="string">                    cout &lt;&lt; &quot;</span>lex error: &amp;&amp;\\n<span class="string">&quot;;</span></span><br><span class="line"><span class="string">                &#125;</span></span><br><span class="line"><span class="string">                break;</span></span><br><span class="line"><span class="string">            case &#x27;|&#x27;:                       //||</span></span><br><span class="line"><span class="string">                ch = getNextChar();</span></span><br><span class="line"><span class="string">                if (&#x27;|&#x27; == ch) &#123;</span></span><br><span class="line"><span class="string">                    g_token.opType = TokenType::OR;</span></span><br><span class="line"><span class="string">                    tmpstr += ch;</span></span><br><span class="line"><span class="string">                &#125;</span></span><br><span class="line"><span class="string">                else &#123;</span></span><br><span class="line"><span class="string">                    cout &lt;&lt; &quot;</span>lex error: ||\\n<span class="string">&quot;;</span></span><br><span class="line"><span class="string">                &#125;</span></span><br><span class="line"><span class="string">                break;</span></span><br><span class="line"><span class="string">            case &#x27;!&#x27;:                       // ! !=</span></span><br><span class="line"><span class="string">                ch = getNextChar();</span></span><br><span class="line"><span class="string">                if (&#x27;=&#x27; == ch) &#123;</span></span><br><span class="line"><span class="string">                    g_token.opType = TokenType::NEQ;</span></span><br><span class="line"><span class="string">                    tmpstr += ch;</span></span><br><span class="line"><span class="string">                &#125;</span></span><br><span class="line"><span class="string">                else &#123;</span></span><br><span class="line"><span class="string">                    backSpace();</span></span><br><span class="line"><span class="string">                    g_token.opType = TokenType::NOT;</span></span><br><span class="line"><span class="string">                &#125;</span></span><br><span class="line"><span class="string">                break;</span></span><br><span class="line"><span class="string">            case &#x27;&lt;&#x27;:                       // &lt; &lt;=</span></span><br><span class="line"><span class="string">                ch = getNextChar();</span></span><br><span class="line"><span class="string">                if (&#x27;=&#x27; == ch) &#123;</span></span><br><span class="line"><span class="string">                    g_token.opType = TokenType::LEQ;</span></span><br><span class="line"><span class="string">                    tmpstr += ch;</span></span><br><span class="line"><span class="string">                &#125;</span></span><br><span class="line"><span class="string">                else &#123;</span></span><br><span class="line"><span class="string">                    backSpace();</span></span><br><span class="line"><span class="string">                    g_token.opType = TokenType::LSS;</span></span><br><span class="line"><span class="string">                &#125;</span></span><br><span class="line"><span class="string">                break;</span></span><br><span class="line"><span class="string">            case &#x27;&gt;&#x27;:                       // &gt; &gt;=</span></span><br><span class="line"><span class="string">                ch = getNextChar();</span></span><br><span class="line"><span class="string">                if (&#x27;=&#x27; == ch) &#123;</span></span><br><span class="line"><span class="string">                    g_token.opType = TokenType::GEQ;</span></span><br><span class="line"><span class="string">                    tmpstr += ch;</span></span><br><span class="line"><span class="string">                &#125;</span></span><br><span class="line"><span class="string">                else &#123;</span></span><br><span class="line"><span class="string">                    backSpace();</span></span><br><span class="line"><span class="string">                    g_token.opType = TokenType::GRE;</span></span><br><span class="line"><span class="string">                &#125;</span></span><br><span class="line"><span class="string">                break;</span></span><br><span class="line"><span class="string">            case &#x27;=&#x27;:                       // = ==</span></span><br><span class="line"><span class="string">                ch = getNextChar();</span></span><br><span class="line"><span class="string">                if (&#x27;=&#x27; == ch) &#123;</span></span><br><span class="line"><span class="string">                    g_token.opType = TokenType::EQL;</span></span><br><span class="line"><span class="string">                    tmpstr += ch;</span></span><br><span class="line"><span class="string">                &#125;</span></span><br><span class="line"><span class="string">                else &#123;</span></span><br><span class="line"><span class="string">                    backSpace();</span></span><br><span class="line"><span class="string">                    g_token.opType = TokenType::ASSIGN;</span></span><br><span class="line"><span class="string">                &#125;</span></span><br><span class="line"><span class="string">                break;</span></span><br><span class="line"><span class="string">            case &#x27;,&#x27;:</span></span><br><span class="line"><span class="string">                g_token.opType = TokenType::COMMA;</span></span><br><span class="line"><span class="string">                break;</span></span><br><span class="line"><span class="string">            case &#x27;;&#x27;:</span></span><br><span class="line"><span class="string">                g_token.opType = TokenType::SEMICOLON;</span></span><br><span class="line"><span class="string">                break;</span></span><br><span class="line"><span class="string">            case &#x27;&#123;&#x27;:</span></span><br><span class="line"><span class="string">                g_token.opType = TokenType::LBRACE;</span></span><br><span class="line"><span class="string">                break;</span></span><br><span class="line"><span class="string">            case &#x27;&#125;&#x27;:</span></span><br><span class="line"><span class="string">                g_token.opType = TokenType::RBRACE;</span></span><br><span class="line"><span class="string">                break;</span></span><br><span class="line"><span class="string">            case &#x27;[&#x27;:</span></span><br><span class="line"><span class="string">                g_token.opType = TokenType::LBRACKET;</span></span><br><span class="line"><span class="string">                break;</span></span><br><span class="line"><span class="string">            case &#x27;]&#x27;:</span></span><br><span class="line"><span class="string">                g_token.opType = TokenType::RBRACKET;</span></span><br><span class="line"><span class="string">                break;</span></span><br><span class="line"><span class="string">            case &#x27;(&#x27;:</span></span><br><span class="line"><span class="string">                g_token.opType = TokenType::LPARENTHES;</span></span><br><span class="line"><span class="string">                break;</span></span><br><span class="line"><span class="string">            case &#x27;)&#x27;:</span></span><br><span class="line"><span class="string">                g_token.opType = TokenType::RPARENTHES;</span></span><br><span class="line"><span class="string">                break;</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">        break;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    case STATE_CHAR:</span></span><br><span class="line"><span class="string">        if (isdigit(ch) || isalpha(ch) || &#x27;+&#x27; == ch || &#x27;-&#x27; == ch || &#x27;*&#x27; == ch || &#x27;/&#x27; == ch) &#123;</span></span><br><span class="line"><span class="string">            tmpstr += ch;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">        else &#123;</span></span><br><span class="line"><span class="string">            cout &lt;&lt; &quot;</span>lex error:illegal character\\n<span class="string">&quot;;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        ch = getNextChar();</span></span><br><span class="line"><span class="string">        state = STATE_DONE;</span></span><br><span class="line"><span class="string">        // 有一处bug，下面这句忘记加了。。。</span></span><br><span class="line"><span class="string">        g_token.opType = TokenType::LETTER;</span></span><br><span class="line"><span class="string">        if (&#x27;\\&#x27;&#x27; != ch) &#123;</span></span><br><span class="line"><span class="string">            backSpace();</span></span><br><span class="line"><span class="string">            cout &lt;&lt; &quot;</span>lex error:<span class="keyword">not</span> <span class="string">&#x27;\\n&quot;;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        break;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    case STATE_ID:</span></span><br><span class="line"><span class="string">        if (isdigit(ch) || isalpha(ch) || &#x27;</span>_<span class="number">&#x27;</span> == ch) &#123;</span><br><span class="line">            tmpstr += ch;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            state = STATE_DONE;</span><br><span class="line">            <span class="built_in">backSpace</span>();</span><br><span class="line">            g_token.opType = TokenType::IDEN;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> STATE_NUM:</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">            tmpstr += ch;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            state = STATE_DONE;</span><br><span class="line">            <span class="built_in">backSpace</span>();</span><br><span class="line">            g_token.opType = TokenType::NUM;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> STATE_STRING:</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&#x27;&quot;&#x27;</span> == ch) &#123;</span><br><span class="line">            state = STATE_DONE;</span><br><span class="line">            g_token.opType = TokenType::STRING;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">32</span> &lt;= ch &amp;&amp; <span class="number">126</span> &gt;= ch) &#123;</span><br><span class="line">            tmpstr += ch;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;lex error: illegal character in string\\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="3-转换表"><a href="#3-转换表" class="headerlink" title="3 转换表"></a><strong>3 转换表</strong></h3><p>代码简单，易维护，但是表可能很大，不推荐</p>
<p><img src="/2020/07/06/ComplierC0/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%B4%E6%98%8E/Untitled 6.png" alt="Untitled"></p>
<p><img src="/2020/07/06/ComplierC0/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%B4%E6%98%8E/Untitled 7.png" alt="Untitled"></p>
<h2 id="注意问题（重点）"><a href="#注意问题（重点）" class="headerlink" title="注意问题（重点）"></a><strong>注意问题（重点）</strong></h2><h3 id="1、读入缓冲"><a href="#1、读入缓冲" class="headerlink" title="1、读入缓冲"></a><strong>1、读入缓冲</strong></h3><p>缓冲的意思是，不是直接通过指针操作文件，而是，先读进来一个数组的数据，在数组中操作；</p>
<p>便于定位错误的位置；简便</p>
<blockquote>
<p>然后有单缓冲和双缓冲的区别；</p>
<p>而<code>北航</code>是多了一个backup数组；</p>
<p><code>louden书</code>中的例子，也是有一个缓冲数组lineBuf</p>
</blockquote>
<h3 id="2、保留字的识别"><a href="#2、保留字的识别" class="headerlink" title="2、保留字的识别"></a><strong>2、保留字的识别</strong></h3><p>将保留字也先看做标识符，再识别保留字</p>
<blockquote>
<p>匹配保留字表，字典序查询（线性低效）</p>
</blockquote>
<h3 id="3、带符号数处理"><a href="#3、带符号数处理" class="headerlink" title="3、带符号数处理"></a><strong>3、带符号数处理</strong></h3><blockquote>
<p>+1+1</p>
<p><code>最长字串原则</code>：if32i 这种字符串时，我们将对整个字符串进行匹配，而不是匹配到if就返回类型IF。简单说是往最长的结果匹配。</p>
<p>但我们理解的：第二个 +1和第一个+1是有区别的，如果词法阶段就有带符号数，那么按照最长字符串原则会得到两个token，两个<code>+1</code></p>
<p>但实际我们想要的可能是：+1，+，1</p>
</blockquote>
<p>通过总结带符号数的规律，发现：其中要么带符号数要么在开头，要么有括号；其他情况数字都是无符号的</p>
<p>所以，总结来说，我们可以把这个符号当做<code>表达式来处理</code>，前面补一个0；</p>
<h3 id="4、冲突解决与错误处理（略）"><a href="#4、冲突解决与错误处理（略）" class="headerlink" title="4、冲突解决与错误处理（略）"></a><strong>4、冲突解决与错误处理（略）</strong></h3><h1 id="三、语法分析"><a href="#三、语法分析" class="headerlink" title="三、语法分析"></a>三、<strong><strong>语法分析</strong></strong></h1><h2 id="摘要-1"><a href="#摘要-1" class="headerlink" title="摘要"></a>摘要</h2><p>语法分析的作用是<code>单词归纳成句子</code>的序列；需要<code>生成抽象语法树（左孩子右兄弟）</code>。</p>
<blockquote>
<p>到生成AST这里算前端，<code>前端处理不同语言，后端统一处理AST</code></p>
</blockquote>
<p>工作流程分为两个部分：</p>
<p>1、先理论设计AST（设计分成<code>四个部分</code>程序、语句、算术表达式、布尔表达式）；程序实现构造AST（树的结构是什么样，存储哪些信息）</p>
<p>2、对于<code>语法（文法）</code>上，计划采用<code>递归下降</code>分析法（手写实现简单），文法最好满足<code>LL(1)文法</code>（大致理解是看到下一个token就知道用哪一个推导式）</p>
<blockquote>
<p>需要大量的设计和验证（这里废了很多功夫）</p>
</blockquote>
<p>在实现时，最好将文法转化为<code>EBNF范式</code>便于实现；</p>
<p><code>难点</code>：</p>
<ul>
<li><p>函数定义和变量定义的回溯保留</p>
</li>
<li><p>算术表达式的设计</p>
</li>
<li><p>布尔表达式的设计</p>
</li>
<li><p>二义性的解决（以if-else为例：就近原则；布尔表达式中的算术表达式无法使用括号嵌套）</p>
</li>
<li><p>语法分析是做什么？（通俗理解）</p>
<p>  词法是字符序列转成单词序列；（看一个单词是否合法）</p>
<p>  语法分析是<code>单词转成句子</code>的序列（看一个句子是否合法）。需要<code>生成抽象语法树</code></p>
<p>  <img src="/2020/07/06/ComplierC0/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%B4%E6%98%8E/Untitled 8.png" alt="Untitled"></p>
</li>
<li><p>LL分析法，LR分析法</p>
<p>  LL(k)文法：通过从左往右超前查看k个字符决定采用哪一个产生式。（分支预测）</p>
<p>  名字中第一个L表示从左往右扫描字符串，；第二个L表示最左推导，对于每一个产生式都要从左往右开始分析即可。</p>
<p>  提取左公因式的方法，转化为LL(k)的文法。</p>
</li>
<li><p>递归子程序（递归下降法）</p>
<p>  好用程序实现，对语言所用的文法有一些限制（MS官方的C#编译器就是用这种方法）</p>
</li>
</ul>
<h2 id="抽象语法树-AST-的理论设计"><a href="#抽象语法树-AST-的理论设计" class="headerlink" title="抽象语法树 AST 的理论设计"></a><strong>抽象语法树 AST 的理论设计</strong></h2><p>特点：</p>
<ul>
<li><code>不依赖于具体的文法</code>（语法分析方式）：无论是自上而下或自下而上的语法分析，都要求在语法分析时候，构造出相同的语法树，这样可以给编译器后端提 供了清晰，统一的接口。</li>
<li>不依赖于语言的细节：gcc可以编译多种语言，<code>前端处理不同语言，后端统一处理AST</code></li>
</ul>
<p>我定义的：（<code>左孩子右兄弟</code>），有四块内容</p>
<p>1、整体结构：</p>
<p><img src="/2020/07/06/ComplierC0/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%B4%E6%98%8E/Untitled 9.png" alt="Untitled"></p>
<p>2、语句</p>
<p><img src="/2020/07/06/ComplierC0/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%B4%E6%98%8E/Untitled 10.png" alt="Untitled"></p>
<p>3、算术表达式：（算是较为完整）</p>
<p>支持<code>加减乘除</code>、<code>括号</code>，<code>数组下标引用</code>、有返回值函数调用；</p>
<p>对象可以是<code>字面量</code>和<code>变量</code>的<code>字符</code>和<code>无符号整数</code>类型</p>
<p><img src="/2020/07/06/ComplierC0/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%B4%E6%98%8E/Untitled 11.png" alt="Untitled"></p>
<p>4、布尔表达式：</p>
<p>支持与或非、括号、条件运算符（大于、小于等的比较运算）</p>
<p><img src="/2020/07/06/ComplierC0/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%B4%E6%98%8E/Untitled 12.png" alt="Untitled"></p>
<h2 id="LL-1-文法的理论定义"><a href="#LL-1-文法的理论定义" class="headerlink" title="LL(1)文法的理论定义"></a><strong>LL(1)文法的理论定义</strong></h2><h3 id="FIRST集合"><a href="#FIRST集合" class="headerlink" title="FIRST集合"></a><strong>FIRST集合</strong></h3><p>对于推导式：First(S)就是S能推导出来的第一个终结符</p>
<p><img src="/2020/07/06/ComplierC0/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%B4%E6%98%8E/Untitled 13.png" alt="Untitled"></p>
<h3 id="FOLLOW集合"><a href="#FOLLOW集合" class="headerlink" title="FOLLOW集合"></a><strong>FOLLOW集合</strong></h3><p>可紧跟在非终结符A后的所有终结符之集</p>
<p>D背后紧跟着R，R的第一个是d</p>
<p><img src="/2020/07/06/ComplierC0/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%B4%E6%98%8E/Untitled 14.png" alt="Untitled"></p>
<h3 id="LL-1-文法"><a href="#LL-1-文法" class="headerlink" title="LL(1)文法"></a><strong>LL(1)文法</strong></h3><p>判断文法为LL(1)文法的条件：</p>
<p>（1）文法不含左递归</p>
<p>（2）根据产生式的首字符进行判断（也就是通过第一个字符就能判断使用哪个产生式）</p>
<p><img src="/2020/07/06/ComplierC0/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%B4%E6%98%8E/Untitled 15.png" alt="Untitled"></p>
<h2 id="编程：递归向下分析法（使用递归子程序法）"><a href="#编程：递归向下分析法（使用递归子程序法）" class="headerlink" title="编程：递归向下分析法（使用递归子程序法）"></a>编程：<strong>递归向下分析法（使用递归子程序法）</strong></h2><blockquote>
<p>设计好了文法，如何编程实现？</p>
<p>将文法表示成<code>EBNF范式</code>的形式更好实现！</p>
</blockquote>
<p>对于文法的<code>每个非终结符</code>,根据其各候选式的结构,为其建立一个<code>递归的子程序(函数)</code>,用于识别该非终结符所表示的语法范畴.</p>
<p><img src="/2020/07/06/ComplierC0/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%B4%E6%98%8E/Untitled 16.png" alt="Untitled"></p>
<p>match：以其实参与当前正扫描的符号进行匹配,若成功则返回1,否则返回0;</p>
<p>advance：读下一单词的函数</p>
<p>term：与非终结符T相对应的子程序.</p>
<h3 id="1、AST的程序表示"><a href="#1、AST的程序表示" class="headerlink" title="1、AST的程序表示"></a><strong>1、AST的程序表示</strong></h3><p>理解了理论定义后，代码方面会简单很多。</p>
<p>1、左孩子右兄弟，孩子可能不止一个</p>
<p>2、大致用哪些数据结构存储了哪些信息</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AST 的节点：左孩子右兄弟的树形结构；但表达式部分 又是二叉树结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">TreeNode</span>* child[MAX_TREENODE_CHILD_NUM];     <span class="comment">// 左孩子，最多三个，通常只有一个，特定语句有多个</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">TreeNode</span>* sibling;                           <span class="comment">// 右兄弟</span></span><br><span class="line">    </span><br><span class="line">		<span class="comment">// 节点类型</span></span><br><span class="line">    NodeKind nodekind;                              </span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        DecKind dec;</span><br><span class="line">        StmtKind stmt;</span><br><span class="line">        ExpKind exp;</span><br><span class="line">        BoolExpKind bexp;</span><br><span class="line">    &#125;kind;                                          <span class="comment">// 节点具体类型</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 节点属性</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        TokenType op;                                   <span class="comment">// 操作类型：通常是表达式中</span></span><br><span class="line">        <span class="type">int</span> val;                                        <span class="comment">// NUM的值：exp中 char也是存这个</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span> cval;                             <span class="comment">// Char 型 值：常量定义</span></span><br><span class="line">        <span class="type">char</span>* name;                                     <span class="comment">// Id 的值，也可以是函数名，Str的值</span></span><br><span class="line">        <span class="type">bool</span> bval;                                      <span class="comment">// bool 常量</span></span><br><span class="line">        <span class="type">char</span>* str;                                      <span class="comment">// String 类型</span></span><br><span class="line">    &#125;attr;                                          </span><br><span class="line">    <span class="type">int</span> vec;                                        <span class="comment">// 数组长度，不是数组就是-1 ； (变量定义阶段设置)</span></span><br><span class="line">    Type type;                                      <span class="comment">// 常、变量定义 ，类型说明 和 表达式类型检查</span></span><br><span class="line">                                                    <span class="comment">// 函数信息：返回类型和参数表；也可以链接到符号表中</span></span><br><span class="line">    FuncInfo* pfinfo;                               <span class="comment">// 函数定义阶段设置：函数信息； 或者是函数调用阶段的参数表</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转化成IR中用到</span></span><br><span class="line">    <span class="type">char</span>* place;</span><br><span class="line">    <span class="type">int</span> TC, FC;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 错误处理</span></span><br><span class="line">    <span class="type">int</span> lineno;                                     <span class="comment">// 错误报告行号</span></span><br><span class="line">    <span class="type">bool</span> error;</span><br><span class="line"></span><br><span class="line">&#125;TreeNode;</span><br></pre></td></tr></table></figure>
<h3 id="2、ENBF范式代码实现"><a href="#2、ENBF范式代码实现" class="headerlink" title="2、ENBF范式代码实现"></a><strong>2、ENBF范式代码实现</strong></h3><p>必须出现直接匹配；</p>
<p>可选用if判断</p>
<p>多次用循环判断</p>
<p><img src="/2020/07/06/ComplierC0/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%B4%E6%98%8E/Untitled 17.png" alt="Untitled"></p>
<h2 id="注意问题（这里涉及文法设计）"><a href="#注意问题（这里涉及文法设计）" class="headerlink" title="注意问题（这里涉及文法设计）"></a><strong>注意问题（这里涉及文法设计）</strong></h2><h3 id="1、避免回溯（提高效率）"><a href="#1、避免回溯（提高效率）" class="headerlink" title="1、避免回溯（提高效率）"></a><strong>1、避免回溯（提高效率）</strong></h3><p>解决：改造文法</p>
<p>有些无法避免，也没必要。（可以部分地方多读几个，类似LL（k））</p>
<p>如函数定义时</p>
<blockquote>
<p>我的程序：</p>
<p>1）判断变量定义还是函数，需要提前看两个token，看是不是括号</p>
<p>2）判断是不是main函数，需要提前一个token</p>
</blockquote>
<h3 id="2、二义性"><a href="#2、二义性" class="headerlink" title="2、二义性"></a>2<strong>、二义性</strong></h3><ul>
<li>if else</li>
</ul>
<blockquote>
<p>规定原则：优先匹配近的</p>
</blockquote>
<ul>
<li>布尔表达式中的算术表达式</li>
</ul>
<blockquote>
<p>因为算术表达式设计得齐全；在布尔表达式部分内部的算术表达式就不支持括号了；（这是一个缺陷）</p>
</blockquote>
<h3 id="3、消除左递归（避免死循环）（略）"><a href="#3、消除左递归（避免死循环）（略）" class="headerlink" title="3、消除左递归（避免死循环）（略）"></a>3<strong>、消除左递归（避免死循环）（略）</strong></h3><p>包含<code>直接左递归</code>和<code>间接左递归</code>两种</p>
<p>解决：改造文法或者EBNF范式</p>
<p><img src="/2020/07/06/ComplierC0/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%B4%E6%98%8E/Untitled 18.png" alt="Untitled"></p>
<p>代入消除间接左递归：</p>
<p><img src="/2020/07/06/ComplierC0/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%B4%E6%98%8E/Untitled 19.png" alt="Untitled"></p>
<h3 id="4、提取公因子（略）"><a href="#4、提取公因子（略）" class="headerlink" title="4、提取公因子（略）"></a>4<strong><strong>、提取公因子（略）</strong></strong></h3><p><img src="/2020/07/06/ComplierC0/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%B4%E6%98%8E/Untitled 20.png" alt="Untitled"></p>
<h1 id="四、语义分析"><a href="#四、语义分析" class="headerlink" title="四、语义分析"></a>四、语义分析</h1><h2 id="摘要-2"><a href="#摘要-2" class="headerlink" title="摘要"></a>摘要</h2><p>功能是语句的语义是否有明确的含义。（比如语法检查每个token类型是否匹配即可；这里需要检查标识符的类型是否正确）</p>
<p>工作分为两个部分，<code>构造符号表</code>和<code>语义检查</code>。（一次遍历）</p>
<p>1、定义符号表（多级hash链表）；符号表是语义检查的基础，所以在常量、变量、函数定义部分先构建符号表（往符号表中添加符号）</p>
<blockquote>
<p>其实符号表在背后的生成四元式（插入临时变量）和生成汇编代码都有用（在符号表中保存<code>内存的地址</code>和<code>寄存器位置</code>）</p>
</blockquote>
<p>2、语义检查是在<code>表达式</code>、和<code>各种语句</code>中<code>检查标识符</code>是否有明确的含义。（查找符号表）</p>
<p><code>类型检查</code>和<code>定义检查</code>是主要内容</p>
<blockquote>
<p>即用到标识符时类型是否正确；标识符是否定义</p>
</blockquote>
<p>难点：</p>
<ul>
<li>符号表的结构：多级hash链表</li>
<li>同名标识符就近原则</li>
</ul>
<blockquote>
<p>一般的编译器：词法分析、语法分析、语义分析是同时进行的，一遍<br>我的：生成AST之后，再遍历AST，构建符号表，进行语义分析（事实上技术上的难度没什么差别，都很简单，做的事情基本一样）</p>
</blockquote>
<h2 id="符号表"><a href="#符号表" class="headerlink" title="符号表"></a>符号表</h2><p>符号表的结构选择：<code>分级hash链表</code>（名字作为键）；分级表示<code>不同作用域</code>（全局或者函数内部）；</p>
<p>因此可以实现同名标识符（选择作用域最近）。不允许使用同名函数、标识符和函数同名。</p>
<p><img src="/2020/07/06/ComplierC0/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%B4%E6%98%8E/Untitled 21.png" alt="Untitled"></p>
<h3 id="程序实现"><a href="#程序实现" class="headerlink" title="程序实现"></a>程序实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SYMBOL_TABLE_SIZE 211</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> <span class="title class_">IDType</span> &#123;</span><br><span class="line">    Const_ID, Var_ID, Para_ID, Func_ID</span><br><span class="line">&#125;IDType;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 符号表中的每一项</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Symbol</span> &#123;</span><br><span class="line">    <span class="type">char</span>* name;					<span class="comment">// 标识符名字</span></span><br><span class="line">    IDType type;				<span class="comment">// ID类型： const，var，para，function</span></span><br><span class="line">    Type valueType;				<span class="comment">// ID的类型值：常变量的类型、参数类型、函数返回类型</span></span><br><span class="line">    <span class="type">int</span> value;					<span class="comment">// 常量定义值						只有常数定义才会传入</span></span><br><span class="line">    <span class="type">int</span> adress;					<span class="comment">// 内存地址</span></span><br><span class="line">    <span class="type">int</span> vec;					<span class="comment">// 数组大小，不是数组为-1；			只有定义数组时，才会传入</span></span><br><span class="line">    FuncInfo* pfinfo;			<span class="comment">// 函数信息，AST中已有，拷贝即可；  只有函数定义是，才会传进，否则NULL</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Symbol</span>* next;		<span class="comment">// 有相同hash值时，下一条</span></span><br><span class="line">&#125;Symbol, * SymbolList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">SymTab</span> &#123;</span><br><span class="line">    SymTab* next;				<span class="comment">// 多张表；指向下一张表</span></span><br><span class="line">    <span class="type">char</span>* fname;</span><br><span class="line">    SymbolList hashTable[SYMBOL_TABLE_SIZE];</span><br><span class="line">&#125;SymTab;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>一些字段的说明：<br>1、标识符名字；<br>2、标识符有四种：常量、变量、函数参数、函数<br>3、标识符的类型：空、整形、字符、错误<br>4、<code>内存地址</code>：这个很关键，有两个变量来维护；一个是全局地址；一个是函数局部地址（函数栈帧相对地址）<br>5、数组大小<br>6、函数定义的信息：返回值，参数个数，各个参数<br>7、作为链表节点，指向下一个节点</p>
</blockquote>
<p>以递归地方式遍历AST，构造符号表。</p>
<p>每个函数一张表：第一张表示全局表（保存全局变量和函数名）；后面的是函数表，新的函数始终保持在第二张表</p>
<p>相关操作：</p>
<ul>
<li>初始化：新增一张表，输入为表名</li>
<li>增：向对应符号表插入一个符号（符号可以是变量、常量、函数参数、函数、标识符）；还可以插入临时变量（计算表达式时使用）</li>
<li>查：先查当前函数表（在第二张），再查全局表（第一张）</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化一张 单表；每个函数一张表、全局一张表</span></span><br><span class="line"><span class="function">SymTab* <span class="title">initSimpleSymTable</span><span class="params">(<span class="type">char</span>* name)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回是否插入成功，如空间不足、重复定义 ； 后面并没有用到返回值，内部直接错误处理</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">insert_SymTab</span><span class="params">(<span class="type">bool</span> isGlobal, <span class="type">char</span>* name, IDType type, Type valuetype, <span class="type">int</span> value, <span class="type">int</span> vec = <span class="number">-1</span>, FuncInfo* p = <span class="literal">NULL</span>)</span></span>;</span><br><span class="line"><span class="comment">// value字段，只有常量定义才会赋初值</span></span><br><span class="line"><span class="comment">// adress字段由文件内部静态变量控制，一旦重新函数定义，指针变0，重新计算相对地址</span></span><br><span class="line"><span class="comment">// 数组标志默认-1；只有数组(变量定义)定义时才会是 其他值</span></span><br><span class="line"><span class="comment">// 函数信息默认为空，只有函数定义时，才会赋值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入临时变量：变量名、isreg、地址（生成四元式阶段才会使用）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertTempVar2SymTab</span><span class="params">(<span class="type">char</span>* name)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 返回符号节点指针、未定义返回空指针；</span></span></span><br><span class="line"><span class="function">Symbol* <span class="title">lookUp_SymTab</span><span class="params">(<span class="type">char</span>* name)</span></span>;</span><br><span class="line"><span class="comment">// 遵循原则：先查子表，再差全局表（作用域最近的）</span></span><br></pre></td></tr></table></figure>
<h2 id="语义检查"><a href="#语义检查" class="headerlink" title="语义检查"></a>语义检查</h2><p>主要工作是对<code>标识符</code>的<code>类型检查</code>和<code>定义检查</code>（操作类型是否匹配、前面是否定义了函数或标识符，传参的个数和类型是否对得上）</p>
<p>还是<code>递归遍历</code>AST</p>
<p>要检查的地方：</p>
<p>1、算术表达式中：</p>
<ul>
<li>常量：跳过</li>
<li>标识符：未定义使用；是数组不进行下标运算</li>
<li>函数调用：函数未定义使用，不是有返回值调用，参数个是否匹配</li>
<li>数组引用：未定义；非数组进行下标运算；</li>
</ul>
<blockquote>
<p>需考虑<code>运算符两侧操作数是否合法</code>，比如int和bool类型相加，由于只有char和int，<code>暂不考虑</code></p>
<p>表达式都看作是int型运算，只有语句中需要时根据左值类型进行转换</p>
</blockquote>
<hr>
<p>2、布尔表达式中：</p>
<ul>
<li>常量：不检查</li>
<li>算术表达式：递归调用</li>
</ul>
<hr>
<p>3、语句中：</p>
<ul>
<li>赋值语句：标识符未定义、检查是否变量（常量不能赋值）、不是数组进行下标运算、是数组不进行下标运算</li>
<li>函数调用语句：函数未定义、是否是函数、参数是否匹配（个数和类型）<code>（函数传参有可能传表达式，所以需要验证）</code></li>
<li>读语句：标识符未定义、不能是常量</li>
<li>写语句：占用符与表达式不匹配（是否有%d，%c）</li>
</ul>
<p><img src="/2020/07/06/ComplierC0/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%B4%E6%98%8E/Untitled 22.png" alt="Untitled"></p>
<h1 id="五、中间代码（四元式）生成"><a href="#五、中间代码（四元式）生成" class="headerlink" title="五、中间代码（四元式）生成"></a>五、中间代码（四元式）生成</h1><h2 id="摘要-3"><a href="#摘要-3" class="headerlink" title="摘要"></a>摘要</h2><p>功能：将AST（四种类型）转化成四元式（一个操作符，最多三个操作数）；便于代码优化</p>
<p>难点：</p>
<ul>
<li>大部分操作较为简单</li>
<li>布尔操作符比较复杂：1、if和while语句的程序块放置位置。2、有短路现象、需要拉链回填（需要提前结束，还要设置各种跳转地址、标签）</li>
</ul>
<blockquote>
<p>举例：如何理解布尔表达式的短路部分：考虑if语句里面的判断是一个或的表达式。<br>这时候根据then、else、后续代码有分三段代码块；这三段都对应一个label（跳转地址）<br>为了能够提前结束，还要拉链。将整个布尔表达式的真假和或两边的表达式的真假联系起来。<br>也就是在表达式中得要拉链的结果，在if-else语句中回填标签</p>
</blockquote>
<h2 id="设计四元式"><a href="#设计四元式" class="headerlink" title="设计四元式"></a>设计四元式</h2><p>设计四元式一定要设计成上下文无关的。包括几种类型：</p>
<ul>
<li>计算：加减乘除、下标引用</li>
<li>定义：常量、变量、函数</li>
<li>语句：函数调用、输入输出</li>
<li>布尔：跳转、标签</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>op</th>
<th>var1</th>
<th>var2</th>
<th>var3</th>
</tr>
</thead>
<tbody>
<tr>
<td>+-*/</td>
<td>id/num</td>
<td>id/num</td>
<td>result</td>
</tr>
<tr>
<td>callret</td>
<td>id（函数名）</td>
<td></td>
<td>id(ret)</td>
</tr>
<tr>
<td>getarray</td>
<td>id（数组名）</td>
<td>id/num（index）</td>
<td>id</td>
</tr>
<tr>
<td>jop</td>
<td>id</td>
<td>id</td>
<td>label</td>
</tr>
<tr>
<td>j</td>
<td></td>
<td></td>
<td>label</td>
</tr>
<tr>
<td>jnz</td>
<td>id/num</td>
<td></td>
<td>label</td>
</tr>
<tr>
<td>const</td>
<td>int/char</td>
<td>val</td>
<td>name</td>
</tr>
<tr>
<td>int/char</td>
<td></td>
<td></td>
<td>name</td>
</tr>
<tr>
<td>intarray</td>
<td>size</td>
<td></td>
<td>name</td>
</tr>
<tr>
<td>chararray</td>
<td>size</td>
<td></td>
<td>name</td>
</tr>
<tr>
<td>Func</td>
<td>int/char/void</td>
<td></td>
<td>name</td>
</tr>
<tr>
<td>para</td>
<td>int/char</td>
<td></td>
<td>name</td>
</tr>
<tr>
<td>Main</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>setarray</td>
<td>id/num</td>
<td>index</td>
<td>name</td>
</tr>
<tr>
<td>assign</td>
<td>id/num</td>
<td></td>
<td>name</td>
</tr>
<tr>
<td>lab</td>
<td></td>
<td></td>
<td>label</td>
</tr>
<tr>
<td>call</td>
<td>name</td>
<td></td>
<td></td>
</tr>
<tr>
<td>vpara</td>
<td></td>
<td></td>
<td>id/num</td>
</tr>
<tr>
<td>scanf</td>
<td></td>
<td></td>
<td>name</td>
</tr>
<tr>
<td>print</td>
<td>str_index</td>
<td></td>
<td></td>
</tr>
<tr>
<td>print</td>
<td></td>
<td>id/num</td>
<td>int/char</td>
</tr>
<tr>
<td>ret</td>
<td></td>
<td></td>
<td>id/num</td>
</tr>
<tr>
<td>ret</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>endf</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<h3 id="算术表达式的四元式生成"><a href="#算术表达式的四元式生成" class="headerlink" title="算术表达式的四元式生成"></a>算术表达式的四元式生成</h3><p>需要存储中间临时变量：加减乘除、查数组、函数调用都要将结果存到临时变量里<code>在代码中是tree-&gt;place属性，如$1</code></p>
<h3 id="布尔表达式的四元式生成"><a href="#布尔表达式的四元式生成" class="headerlink" title="布尔表达式的四元式生成"></a>布尔表达式的四元式生成</h3><p>以布尔表达式在if语句中为例：</p>
<p><img src="/2020/07/06/ComplierC0/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%B4%E6%98%8E/Untitled 23.png" alt="Untitled"></p>
<p><img src="/2020/07/06/ComplierC0/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%B4%E6%98%8E/Untitled 24.png" alt="Untitled"></p>
<p>布尔表达式E可能有提前结束，为真，执行S1代码，之后跳过S2；为假跳到执行S2代码，再继续执行。</p>
<p>代码实现是：先构造布尔表达式的代码，再生成3个代码标签，放在S1、2的前后。</p>
<p>代码顺序是：<code>BoolExp</code>-<code>label_true</code>-<code>S1</code>-<code>label-false</code>-<code>S2</code>-<code>continue_label</code></p>
<p>注意当确定了label的名字之后，需要<code>拉链和回填</code></p>
<p>拉链回传通过语法树的<code>TC、FC变量</code>实现</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">IR_BoolExp</span>(tree-&gt;child[<span class="number">0</span>]);</span><br><span class="line"><span class="type">char</span>* truelabel = <span class="built_in">newlabel</span>();</span><br><span class="line"><span class="type">char</span>* falselabel = <span class="built_in">newlabel</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">char</span>* conlabel = <span class="built_in">newlabel</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">gen</span>(<span class="string">&quot;lab&quot;</span>, <span class="built_in">newempty</span>(), <span class="built_in">newempty</span>(), truelabel);</span><br><span class="line"><span class="built_in">backPatch</span>(tree-&gt;child[<span class="number">0</span>]-&gt;TC, truelabel);</span><br><span class="line"></span><br><span class="line"><span class="built_in">IR_Analyze</span>(tree-&gt;child[<span class="number">1</span>]);</span><br><span class="line"><span class="built_in">gen</span>(<span class="string">&quot;j&quot;</span>, <span class="built_in">newempty</span>(), <span class="built_in">newempty</span>(), conlabel);</span><br><span class="line"></span><br><span class="line"><span class="built_in">gen</span>(<span class="string">&quot;lab&quot;</span>, <span class="built_in">newempty</span>(), <span class="built_in">newempty</span>(), falselabel);</span><br><span class="line"><span class="built_in">backPatch</span>(tree-&gt;child[<span class="number">0</span>]-&gt;FC, falselabel);</span><br><span class="line"><span class="built_in">IR_Analyze</span>(tree-&gt;child[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">gen</span>(<span class="string">&quot;lab&quot;</span>, <span class="built_in">newempty</span>(), <span class="built_in">newempty</span>(), conlabel);</span><br></pre></td></tr></table></figure>
<p>bool Exp 里面有 4 种节点： <code>布尔op</code>、<code>布尔常量</code>、<code>关系op</code>、<code>表达式</code></p>
<p>1、当前tree节点是算术表达式：</p>
<p>详解：先生成算术表达式的代码，生成代码<code>(jnz, tree-&gt;place, &#39;&#39;, zero)</code> ，第二条是<code>j</code>类型；再由TC和FC辅助走真假两条路；</p>
<p>也就是说jnz（序号为NXQ）里面的跳转地址应为真链（满足条件）；j（序号为NXQ）为假链，不满足条件</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (tree-&gt;nodekind == NodeKind::ExpK) &#123;</span><br><span class="line">		<span class="built_in">IR_Exp</span>(tree);</span><br><span class="line">		tree-&gt;TC = NXQ;</span><br><span class="line">		tree-&gt;FC = NXQ + <span class="number">1</span>;</span><br><span class="line">		<span class="built_in">gen</span>(<span class="string">&quot;jnz&quot;</span>, tree-&gt;place, <span class="built_in">newempty</span>(), zero);</span><br><span class="line">		<span class="built_in">gen</span>(<span class="string">&quot;j&quot;</span>, <span class="built_in">newempty</span>(), <span class="built_in">newempty</span>(), zero);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>2、布尔op（大于、等于等等）</p>
<p>要先生成两个EXp的代码；将临时变量的结果保存到两个孩子的place属性里</p>
<p>再设置两个分支<code>布尔op</code>和<code>j</code>分支，对应这一个满足条件，一个不满足条件</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (tree-&gt;kind.bexp == BoolExpKind::ConOp_BoolEK) &#123;			<span class="comment">// 表达式 ConOp 表达式</span></span><br><span class="line">			<span class="built_in">IR_Exp</span>(tree-&gt;child[<span class="number">0</span>]);</span><br><span class="line">			<span class="built_in">IR_Exp</span>(tree-&gt;child[<span class="number">1</span>]);</span><br><span class="line">			tree-&gt;TC = NXQ;</span><br><span class="line">			tree-&gt;FC = NXQ + <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">switch</span> (tree-&gt;attr.op)</span><br><span class="line">			&#123;</span><br><span class="line">			<span class="keyword">case</span> TokenType::LSS:</span><br><span class="line">				<span class="built_in">gen</span>(<span class="string">&quot;&lt;&quot;</span>, tree-&gt;child[<span class="number">0</span>]-&gt;place, tree-&gt;child[<span class="number">1</span>]-&gt;place, zero);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> TokenType::LEQ:</span><br><span class="line">				<span class="built_in">gen</span>(<span class="string">&quot;&lt;=&quot;</span>, tree-&gt;child[<span class="number">0</span>]-&gt;place, tree-&gt;child[<span class="number">1</span>]-&gt;place, zero);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> TokenType::GRE:</span><br><span class="line">				<span class="built_in">gen</span>(<span class="string">&quot;&gt;&quot;</span>, tree-&gt;child[<span class="number">0</span>]-&gt;place, tree-&gt;child[<span class="number">1</span>]-&gt;place, zero);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> TokenType::GEQ:</span><br><span class="line">				<span class="built_in">gen</span>(<span class="string">&quot;&gt;=&quot;</span>, tree-&gt;child[<span class="number">0</span>]-&gt;place, tree-&gt;child[<span class="number">1</span>]-&gt;place, zero);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> TokenType::EQL:</span><br><span class="line">				<span class="built_in">gen</span>(<span class="string">&quot;==&quot;</span>, tree-&gt;child[<span class="number">0</span>]-&gt;place, tree-&gt;child[<span class="number">1</span>]-&gt;place, zero);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> TokenType::NEQ:</span><br><span class="line">				<span class="built_in">gen</span>(<span class="string">&quot;!=&quot;</span>, tree-&gt;child[<span class="number">0</span>]-&gt;place, tree-&gt;child[<span class="number">1</span>]-&gt;place, zero);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">gen</span>(<span class="string">&quot;j&quot;</span>, <span class="built_in">newempty</span>(), <span class="built_in">newempty</span>(), zero);</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
<p>3、布尔常量</p>
<p>与单独的表达式相同</p>
<p>4、与或非</p>
<p>非就是把自己的链和孩子的链反过来即可。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (TokenType::NOT == tree-&gt;attr.op) &#123;</span><br><span class="line">				<span class="built_in">IR_BoolExp</span>(tree-&gt;child[<span class="number">0</span>]);</span><br><span class="line">				tree-&gt;FC = tree-&gt;child[<span class="number">0</span>]-&gt;TC;</span><br><span class="line">				tree-&gt;TC = tree-&gt;child[<span class="number">0</span>]-&gt;FC;</span><br><span class="line">			&#125;</span><br></pre></td></tr></table></figure>
<p>或要注意：或有两个部分（孩子）；根据常见的理解：第一个表达式为真，那么第二个就不用测试了</p>
<p>代码理解：先生成左孩子；接着立马生成一个标签放在右孩子代码的前面，用于左孩子为假时，立马跳转到这里开始判断；也就是说这里要回填为左孩子的假链；</p>
<p>接着继续拉链左孩子的真链为总体的真链；</p>
<p>再生成右孩子的表达式；这时候才得到整个或语句的假链的位置；</p>
<p>要将右孩子的真链和左孩子的真链合并才得到整个语句的真链</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">IR_BoolExp</span>(tree-&gt;child[<span class="number">0</span>]);</span><br><span class="line"><span class="type">char</span>* ll = <span class="built_in">newlabel</span>();</span><br><span class="line"><span class="built_in">gen</span>(<span class="string">&quot;lab&quot;</span>, <span class="built_in">newempty</span>(), <span class="built_in">newempty</span>(), ll);</span><br><span class="line"><span class="comment">// 分析：此处回填是没有问题的，因为：回填肯定是填前面四元式，填的序号就是NXQ，</span></span><br><span class="line"><span class="comment">// 只不过这里newlabel，代替NXQ，也就是全部转到这个label的地方，肯定是不会出现顺序上的问题</span></span><br><span class="line"><span class="built_in">backPatch</span>(tree-&gt;child[<span class="number">0</span>]-&gt;FC, ll);</span><br><span class="line">tree-&gt;TC = tree-&gt;child[<span class="number">0</span>]-&gt;TC;</span><br><span class="line"></span><br><span class="line"><span class="built_in">IR_BoolExp</span>(tree-&gt;child[<span class="number">1</span>]);</span><br><span class="line">tree-&gt;FC = tree-&gt;child[<span class="number">1</span>]-&gt;FC;</span><br><span class="line">tree-&gt;TC = <span class="built_in">merge</span>(tree-&gt;child[<span class="number">0</span>]-&gt;TC, tree-&gt;child[<span class="number">1</span>]-&gt;TC);</span><br></pre></td></tr></table></figure>
<h1 id="六、目标代码生成-MIPS"><a href="#六、目标代码生成-MIPS" class="headerlink" title="六、目标代码生成-MIPS"></a>六、<strong><strong>目标代码生成-MIPS</strong></strong></h1><h2 id="摘要-4"><a href="#摘要-4" class="headerlink" title="摘要"></a>摘要</h2><p>功能：将中间代码转换成真正能够运行的MIPS汇编代码。</p>
<p>主要解决：（剩余的工作大多是翻译的工作）</p>
<p>1、内存分配：指定数据和代码的位置</p>
<p>2、寄存器分配思路：除固定寄存器外，使用FIFO原则使用10个临时寄存器</p>
<p>3、栈帧的创建与销毁：与函数开始与结束；函数调用与返回语句四个过程有关。</p>
<p>函数开始和结束需要维护栈帧结构（保存和还原栈帧寄存器和返回地址、开辟空间保存变量）；函数调用需要保存寄存器现场；返回语句负责保存返回值到相应寄存器。</p>
<p>难点与出bug的地方：</p>
<ul>
<li>保证寄存器和内存的<code>一致性</code>，寄存器保存现场的时机：不是函数调用时，而是每一个代码块（有分支的位置）（）</li>
</ul>
<h2 id="内存分配方案"><a href="#内存分配方案" class="headerlink" title="内存分配方案"></a>内存分配方案</h2><blockquote>
<p>将IR转换成真正能够运行的汇编代码，首先要确定如何将数据和运行的代码放入内存，放在哪些区域。<br>过程为：先处理全局变量；在处理函数体（函数体首先要确认栈帧的结构，返回地址、参数等，再处理函数内容）</p>
</blockquote>
<p>用到的几个部分：</p>
<ul>
<li>.data段：存放全局变量，字符串常量</li>
<li>.text段：存放代码</li>
<li>stack：运行时使用，保存栈帧（地址从高到低）</li>
</ul>
<p><img src="/2020/07/06/ComplierC0/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%B4%E6%98%8E/Untitled 25.png" alt="Untitled"></p>
<h2 id="寄存器分配思路"><a href="#寄存器分配思路" class="headerlink" title="寄存器分配思路"></a>寄存器分配思路</h2><p>全部的寄存器：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>寄存器</th>
<th>别名</th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr>
<td>$0</td>
<td>$zero</td>
<td>常量0(constant value 0)</td>
</tr>
<tr>
<td>$1</td>
<td>$at</td>
<td>保留给汇编器(Reserved for assembler)</td>
</tr>
<tr>
<td>$2-$3</td>
<td>$v0-$v1</td>
<td>函数调用返回值(values for results and expression evaluation)</td>
</tr>
<tr>
<td>$4-$7</td>
<td>$a0-$a3</td>
<td>函数调用参数(arguments)</td>
</tr>
<tr>
<td>$8-$15</td>
<td>$t0-$t7</td>
<td>暂时的(或随便用的)</td>
</tr>
<tr>
<td>$16-$23</td>
<td>$s0-$s7</td>
<td>保存的(或如果用，需要SAVE/RESTORE的)(saved)</td>
</tr>
<tr>
<td>$24-$25</td>
<td>$t8-$t9</td>
<td>暂时的(或随便用的)</td>
</tr>
<tr>
<td>$26~$27</td>
<td>$k0~$k1</td>
<td>保留供中断/陷阱处理程序使用</td>
</tr>
<tr>
<td>$28</td>
<td>$gp</td>
<td>全局指针(Global Pointer)</td>
</tr>
<tr>
<td>$29</td>
<td>$sp</td>
<td>堆栈指针(Stack Pointer)</td>
</tr>
<tr>
<td>$30</td>
<td>$fp</td>
<td>帧指针(Frame Pointer)</td>
</tr>
<tr>
<td>$31</td>
<td>$ra</td>
<td>返回地址(return address)</td>
</tr>
</tbody>
</table>
</div>
<p>一般用的：</p>
<ul>
<li><code>$fp</code>：栈顶（高地址）</li>
<li><code>$sp</code>：栈底（低）</li>
<li><code>$ra</code>：存储的是返回地址，即函数结束时会运行<code>jr $ra</code>，即回到函数调用者的下一条指令；函数调用时，需要将下一条指令地址放入这个寄存器</li>
<li><code>$v0</code>：如果函数有返回值，会将结果放入该寄存器</li>
<li><code>$a0-$a3</code>：参数寄存器。其实本项目没有用，都放入内存了。</li>
<li><code>$t0-$t9</code>：10个寄存器是使用频率很高的</li>
</ul>
<p>下面主要讲这10个寄存器的使用思路：考虑到其实这相当于内存的cache，主要解决一致性的问题。</p>
<p>如果我们要操作一个数、变量、数组的元素；那么首先去检查是否在寄存器堆（该状态保存在符号表）；如果在则直接使用；不在需要从内存载入。这时又需要看寄存器堆是否有空余的，如果有，则直接载入；没有则根据FIFO原则将原有值放回内存再使用新寄存器。</p>
<p>主要函数：<code>getRegIndex</code>每次输入变量名就可以直接获得该变量存储的寄存器序号</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">用途：管理寄存器堆。当需要加载操作数时（立即数、变量值、数组基地址），查看是否已在寄存器，或加载到哪个寄存器。</span></span><br><span class="line"><span class="comment">输入：变量名</span></span><br><span class="line"><span class="comment">输出：该变量可以存入的寄存器index，或者是已经存在的寄存器序号, isInReg, isGlobal</span></span><br><span class="line"><span class="comment">首先查找符号表中该变量是否在寄存器中，</span></span><br><span class="line"><span class="comment">	如果在：返回序号，维护寄存器状态列表（对于全局、局部、临时变量都表示值是否在寄存器，数组表示基地址是否在）</span></span><br><span class="line"><span class="comment">	不在：查看是否有空寄存器，若无，FIFO原则维护寄存器堆</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	此外还需维护两个全局变量: 表示是否在寄存器中（用于该函数体外），是否全局变量（.data段全局变量可以通过变量名直接获取、存储）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getRegIndex</span><span class="params">(<span class="type">char</span>* varname)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// bug 开始是负号 遗漏了</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">isdigit</span>(varname[<span class="number">0</span>]) || varname[<span class="number">0</span>] == <span class="string">&#x27;-&#x27;</span>) &#123;			<span class="comment">// 立即数，不查询是否在寄存器，直接获取一个</span></span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">getAnEmptyReg</span>(varname, <span class="literal">NULL</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 变量</span></span><br><span class="line">	Symbol* sb = <span class="built_in">lookUp_SymTab</span>(varname, isGlobal);</span><br><span class="line">	<span class="keyword">if</span> (!sb) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;unexpect error: cannot find symbol\n&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (sb-&gt;isreg) &#123;						<span class="comment">// 已经在寄存器堆中</span></span><br><span class="line">		isInReg = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">checkRegInfoList</span>(varname);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;									<span class="comment">// 不在寄存器中</span></span><br><span class="line">		isInReg = <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">getAnEmptyReg</span>(varname, sb);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>两个辅助函数：1、<code>checkRegInfoList</code>检查变量在哪一个寄存器。2、<code>getAnEmptyReg</code>获得一个可以用的寄存器</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">根据变量名，返回所在的寄存器号；</span></span><br><span class="line"><span class="comment">同时需要更新此寄存器到队列末尾</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">checkRegInfoList</span><span class="params">(<span class="type">char</span>* varname)</span> </span>&#123;</span><br><span class="line">	std::list&lt;RegInfo&gt;::iterator iter = regInfoList.<span class="built_in">begin</span>();</span><br><span class="line">	<span class="keyword">for</span> (; iter != regInfoList.<span class="built_in">end</span>(); ++iter) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!<span class="built_in">strcmp</span>((*iter).varname, varname)) &#123;</span><br><span class="line">			<span class="built_in">INFO</span>(<span class="string">&quot;剩余寄存器：%d，已在寄存器：true，变量名：%s，寄存器序号：%d\n&quot;</span>, s_emptyRegNum, varname, std::<span class="built_in">distance</span>(regInfoList.<span class="built_in">begin</span>(),iter));</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (iter == regInfoList.<span class="built_in">end</span>()) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;unpected error in checkRegInfoList()\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	RegInfo nn = (*iter);</span><br><span class="line">	regInfoList.<span class="built_in">push_back</span>(nn);</span><br><span class="line"></span><br><span class="line">	regInfoList.<span class="built_in">erase</span>(iter);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> nn.regindex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">若有空寄存器，返回下一个寄存器序号；</span></span><br><span class="line"><span class="comment">若无，FIFO原则，退出一个</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getAnEmptyReg</span><span class="params">(<span class="type">char</span>* varname, Symbol* sb)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (s_emptyRegNum &gt; <span class="number">0</span>) &#123;					<span class="comment">// 有空闲的寄存器：符号表isreg标志置为true，空闲寄存器数量-1，映射队列插入新元素</span></span><br><span class="line">		<span class="keyword">if</span> (sb) &#123;</span><br><span class="line">			sb-&gt;isreg = <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="type">int</span> index = <span class="number">10</span> - s_emptyRegNum;</span><br><span class="line">		s_emptyRegNum--;</span><br><span class="line">		</span><br><span class="line">		RegInfo nn = &#123; index, varname &#125;;</span><br><span class="line">		regInfoList.<span class="built_in">push_back</span>(nn);</span><br><span class="line"></span><br><span class="line">		<span class="built_in">INFO</span>(<span class="string">&quot;剩余寄存器：%d，变量名：%s，寄存器序号：%d\n&quot;</span>, s_emptyRegNum, varname, index);</span><br><span class="line">		<span class="keyword">return</span> index;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;									<span class="comment">// 没有空闲寄存器，需要清理出一个</span></span><br><span class="line">		<span class="comment">// 将一个寄存器释放，送入内存，isreg标志位改变，映射队列pop；新元素isreg为true，映射队列pushback。</span></span><br><span class="line">		RegInfo nn = regInfoList.<span class="built_in">front</span>();</span><br><span class="line">		regInfoList.<span class="built_in">pop_front</span>();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">isdigit</span>(nn.varname[<span class="number">0</span>]) || <span class="string">&#x27;-&#x27;</span> == nn.varname[<span class="number">0</span>]) &#123;		<span class="comment">// 弹出的是立即数，不用送至内存</span></span><br><span class="line">			<span class="comment">//return nn.regindex;</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			Symbol* sb_pop = <span class="built_in">lookUp_SymTab</span>(nn.varname, p_isGlobal);</span><br><span class="line">			sb_pop-&gt;isreg = <span class="literal">false</span>;</span><br><span class="line">			<span class="keyword">if</span> (sb_pop-&gt;vec &gt;= <span class="number">0</span>) &#123;				<span class="comment">// 弹出的是数组的基地址，也不用送入内存</span></span><br><span class="line">				<span class="comment">//return nn.regindex;</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;								<span class="comment">// 弹出的是变量：分为全局和局部（临时）</span></span><br><span class="line">				<span class="keyword">if</span> (p_isGlobal) &#123;</span><br><span class="line">					<span class="built_in">fprintf</span>(ASM_FILE, <span class="string">&quot;\tsw\t\t$t%d, $%s\n&quot;</span>,</span><br><span class="line">						nn.regindex,</span><br><span class="line">						nn.varname</span><br><span class="line">					);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="built_in">fprintf</span>(ASM_FILE, <span class="string">&quot;\tsw\t\t$t%d, -%d($fp)\n&quot;</span>,</span><br><span class="line">						nn.regindex,</span><br><span class="line">						sb_pop-&gt;adress</span><br><span class="line">					);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">//return nn.regindex;</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 弹出的元素处理完毕</span></span><br><span class="line">		<span class="keyword">if</span> (sb) &#123;</span><br><span class="line">			sb-&gt;isreg = <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		RegInfo ttt = &#123; nn.regindex, varname &#125;;</span><br><span class="line">		regInfoList.<span class="built_in">push_back</span>(ttt);</span><br><span class="line"></span><br><span class="line">		<span class="built_in">INFO</span>(<span class="string">&quot;剩余寄存器：%d，old变量名：%s，变量名：%s，寄存器序号：%d\n&quot;</span>, s_emptyRegNum, nn.varname, varname, nn.regindex);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> nn.regindex;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="难点-Bug：什么时候要保存现场？"><a href="#难点-Bug：什么时候要保存现场？" class="headerlink" title="难点-Bug：什么时候要保存现场？"></a>难点-Bug：什么时候要保存现场？</h3><p>初始思路：按照函数分配的（跳转函数才会保存现场，清空寄存器）</p>
<blockquote>
<p>后来在测试到<code>快速排序</code>的时候，由于各种跳转，导致寄存器有问题；不是正确的运行结果；<br>如，之前要判断的某个循环变量分配到1号寄存器，但是循环内部变量较多，1号寄存器被移除，存储新的变量；这时跳转回去判断，寄存器里面就不是原来的变量了。</p>
</blockquote>
<p><code>正确的方法</code>：按照<code>基本块</code>来分配</p>
<p>首先是基本块划分：</p>
<ul>
<li>程序的第一个四元式</li>
<li>转向语句的目标四元式（即j,jnz,jop的目标）</li>
<li>条件跳转jop的下一条（由于四元式生成过程中下一条总是 j）</li>
</ul>
<blockquote>
<p>具体方法：j的时候清空，遇到label的时候清空。（对应的就是跳转语句的目标和条件跳转的下一句）。<br>也就<code>if-else</code>处；<code>while</code>循环结束</p>
</blockquote>
<h2 id="栈帧处理过程："><a href="#栈帧处理过程：" class="headerlink" title="栈帧处理过程："></a>栈帧处理过程：</h2><p><img src="/2020/07/06/ComplierC0/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%B4%E6%98%8E/Untitled 26.png" alt="Untitled"></p>
<h3 id="1、函数开始："><a href="#1、函数开始：" class="headerlink" title="1、函数开始："></a>1、函数开始：</h3><p>（前提：函数调用者需要压入返回地址，保存寄存器的现场）</p>
<p>1、函数开始，先设置寄存器堆状态为可用；</p>
<p>2、<code>sw $fp, ($sp)</code>保存栈基址寄存器的值到栈变址寄存器（这个位置是低地址，空）</p>
<p>3、<code>move $fp, $sp</code>栈基址变成了栈变址的值（也就是返回的时候弹出新的基址对应的内存地址的值就是原来那个栈帧的基址的值）</p>
<p>4、<code>subi $sp, $sp, 8</code>变址-=8；（要存两个元素，原来的栈基址和函数返回地址；用于函数返回时栈帧和指令计数器的还原）</p>
<p>5、<code>sw $ra, 4($sp)</code>压入返回地址（这个返回地址是函数调用者的下一条指令地址）</p>
<p>6、压入参数、局部变量和临时变量（算术表达式的中间产生的变量）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">s_emptyRegNum = <span class="number">10</span>;								<span class="comment">// 寄存器清空，但寄存器写入内存由函数调用者实现</span></span><br><span class="line">regInfoList.<span class="built_in">clear</span>();							<span class="comment">// 清空队列</span></span><br><span class="line"><span class="comment">// 符号表不处理，因为连函数表都被抛弃了</span></span><br><span class="line">												<span class="comment">// 栈的变化</span></span><br><span class="line"><span class="built_in">fprintf</span>(ASM_FILE, <span class="string">&quot;\tsw\t\t$fp, ($sp)\n&quot;</span>);		<span class="comment">// ($sp) = $fp</span></span><br><span class="line"><span class="built_in">fprintf</span>(ASM_FILE, <span class="string">&quot;\tmove\t$fp, $sp\n&quot;</span>);		<span class="comment">// $fp = $sp</span></span><br><span class="line"><span class="built_in">fprintf</span>(ASM_FILE, <span class="string">&quot;\tsubi\t$sp, $sp, 8\n&quot;</span>);		<span class="comment">// $sp -= 8</span></span><br><span class="line"><span class="built_in">fprintf</span>(ASM_FILE, <span class="string">&quot;\tsw\t\t$ra, 4($sp)\n&quot;</span>);		<span class="comment">// $ra</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 有些参数类型需要转换</span></span><br><span class="line"><span class="built_in">matchParaType</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">ignoreVarDef</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">insertTempVar</span>(cur_4var);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为函数参数、局部变量、临时变量分配空间</span></span><br><span class="line"><span class="built_in">fprintf</span>(ASM_FILE, <span class="string">&quot;\tsubi\t$sp, $sp, %d\n&quot;</span>, g_symtab-&gt;next-&gt;varsize - <span class="number">8</span>);</span><br></pre></td></tr></table></figure>
<h3 id="2、函数结束："><a href="#2、函数结束：" class="headerlink" title="2、函数结束："></a>2、函数结束：</h3><p>1、打标签：便于函数中间的返回语句直接跳转</p>
<p>2、保证内存和寄存器的一致性：由于寄存器相当于内存的cache，要将一些全局变量写会内存（函数的全局变量可以抛弃）</p>
<p>3、<code>lw $ra, -4($fp)</code>恢复返回地址寄存器</p>
<p>4、恢复函数调用者的栈帧：<code>move $sp, $fp</code> ，<code>lw $fp, ($fp)</code></p>
<p>5、函数返回，跳转到寄存器ra的地址的指令：<code>jr $ra</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数体结束，处理栈的变化等等</span></span><br><span class="line">	<span class="comment">// 这一步也很重要，寄存器的值不要忘了写回</span></span><br><span class="line">	<span class="built_in">fprintf</span>(ASM_FILE, <span class="string">&quot;ret_%s:\n&quot;</span>, s_funcName);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">saveReg</span>();										<span class="comment">// 全局变量需要保存、局部变量已经没有意义</span></span><br><span class="line">	<span class="comment">//s_emptyRegNum = 10;								// 寄存器清空</span></span><br><span class="line">	<span class="comment">//regInfoList.clear();							// 清空队列</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 恢复状态</span></span><br><span class="line">	<span class="built_in">fprintf</span>(ASM_FILE, <span class="string">&quot;\tlw\t\t$ra, -4($fp)\n&quot;</span>);	<span class="comment">// 恢复$ra</span></span><br><span class="line">	<span class="built_in">fprintf</span>(ASM_FILE, <span class="string">&quot;\tmove\t$sp, $fp\n&quot;</span>);		<span class="comment">// $sp = $fp</span></span><br><span class="line">	<span class="built_in">fprintf</span>(ASM_FILE, <span class="string">&quot;\tlw\t\t$fp, ($fp)\n&quot;</span>);		<span class="comment">// $fp = ($fp)</span></span><br><span class="line">	</span><br><span class="line">	<span class="built_in">fprintf</span>(ASM_FILE, <span class="string">&quot;\tjr\t\t$ra\n&quot;</span>);</span><br><span class="line">										</span><br><span class="line">	<span class="comment">// endf</span></span><br><span class="line">	cur_4var++;</span><br></pre></td></tr></table></figure>
<h3 id="3、函数调用语句："><a href="#3、函数调用语句：" class="headerlink" title="3、函数调用语句："></a>3、函数调用语句：</h3><p>保存寄存器的值到内存（保存现场和一致性，子函数返回后还会使用这些值）</p>
<p><code>jal function</code>跳转到某个地址的同时将下一条指令的地址保存在寄存器$ra中</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">call2asm</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">saveReg</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(ASM_FILE, <span class="string">&quot;\tjal\t\t%s\n&quot;</span>, quadvarlist[cur_4var].var1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4、return语句"><a href="#4、return语句" class="headerlink" title="4、return语句"></a>4、return语句</h3><ul>
<li>1、控制返回值：需要做类型校验和截断处理<code>move $v0, $t_</code></li>
<li>2、跳转到返回处理部分：<code>j ret_function</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ret2asm</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (quadvarlist[cur_4var].var3[<span class="number">0</span>] == <span class="string">&#x27; &#x27;</span>) &#123;		<span class="comment">// == 写成 =了 。。。。。查了几分钟把，还好找出来了</span></span><br><span class="line">		<span class="comment">/* do nothing */</span></span><br><span class="line">		<span class="keyword">if</span> (Type::T_VOID != s_funcRetType) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;return type error ,id: %s\n&quot;</span>, quadvarlist[cur_4var].var3);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// 保存返回值</span></span><br><span class="line">		<span class="type">int</span> r3 = <span class="built_in">getRegIndex</span>(quadvarlist[cur_4var].var3);</span><br><span class="line">		<span class="built_in">mem2reg</span>(quadvarlist[cur_4var].var3, r3);</span><br><span class="line">		<span class="built_in">fprintf</span>(ASM_FILE, <span class="string">&quot;\tmove\t$v0, $t%d\n&quot;</span>, r3);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 判断返回类型</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">isdigit</span>(quadvarlist[cur_4var].var3[<span class="number">0</span>])) &#123;			<span class="comment">// 返回的是数字</span></span><br><span class="line">			<span class="keyword">if</span> (Type::T_VOID == s_funcRetType) &#123;</span><br><span class="line">				<span class="comment">// void : error</span></span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;return type error ,id: %s\n&quot;</span>, quadvarlist[cur_4var].var3);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (Type::T_CHAR == s_funcRetType) &#123;</span><br><span class="line">				<span class="comment">// char: andi 0xff</span></span><br><span class="line">				<span class="built_in">fprintf</span>(ASM_FILE, <span class="string">&quot;\tandi\t$v0, $v0, 0xff\n&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">/* int: do nothing */</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;													<span class="comment">// 标识符</span></span><br><span class="line">			Type real_ret_type = <span class="built_in">lookUp_SymTab</span>(quadvarlist[cur_4var].var3)-&gt;valueType;</span><br><span class="line">			<span class="comment">// 上面一句似乎没用？</span></span><br><span class="line">			<span class="keyword">if</span> (Type::T_VOID == s_funcRetType) &#123;</span><br><span class="line">				<span class="comment">// void : error</span></span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;return type error ,id: %s\n&quot;</span>, quadvarlist[cur_4var].var3);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (Type::T_CHAR == s_funcRetType) &#123;</span><br><span class="line">				<span class="comment">// char: andi 0xff</span></span><br><span class="line">				<span class="built_in">fprintf</span>(ASM_FILE, <span class="string">&quot;\tandi\t$v0, $v0, 0xff\n&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">/* int: do nothing */</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(ASM_FILE, <span class="string">&quot;\tj\t\tret_%s\n&quot;</span>, s_funcName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="其他语句（系统调用）："><a href="#其他语句（系统调用）：" class="headerlink" title="其他语句（系统调用）："></a>其他语句（系统调用）：</h2><p>完成输入输出的功能。</p>
<h2 id="难点："><a href="#难点：" class="headerlink" title="难点："></a>难点：</h2><p>保证一致性</p>
<h1 id="七、优化"><a href="#七、优化" class="headerlink" title="七、优化"></a>七、优化</h1><h2 id="1、划分基本块"><a href="#1、划分基本块" class="headerlink" title="1、划分基本块"></a>1、划分基本块</h2><p>划分规则：</p>
<ul>
<li>程序的第一个四元式</li>
<li>转向语句的目标四元式（即j,jnz,jop的目标）</li>
<li>条件跳转jop的下一条（由于四元式生成过程中下一条总是 j）</li>
</ul>
<p>由于本人程序在生成IR过程中的特殊性，条件跳转的下一条语句总是j，跳转的目标总是label</p>
<p>所以基本块划分方法可以简化为 遇到j和label就是基本块入口</p>
<blockquote>
<p>下面所说的优化基本是在基本块内的优化，可以叫做线性窥孔优化。</p>
</blockquote>
<h2 id="2、寄存器优化"><a href="#2、寄存器优化" class="headerlink" title="2、寄存器优化"></a>2、寄存器优化</h2><blockquote>
<p>可见目标代码生成部分。原本的寄存器分配可以是用完立即保存到内存，而不是使用10个。</p>
</blockquote>
<h2 id="3、强度削弱"><a href="#3、强度削弱" class="headerlink" title="3、强度削弱"></a>3、强度削弱</h2><p>强度削弱： 乘法和除法改为移位。首先需要判断当前操作是否有立即数，如果有，进一步判断是否是2的次方，如果是，就可以转换为移位操作。</p>
<blockquote>
<p>1、求模运算改成按位与（未实现，因为文法不包括求模）<br>2、非算术运算的削弱，尽量使用寄存器（和寄存器优化有关）<br>3、</p>
</blockquote>
<h2 id="4、常量合并"><a href="#4、常量合并" class="headerlink" title="4、常量合并"></a>4、常量合并</h2><blockquote>
<p>算地慢不如算地快，算地快不如不计算</p>
</blockquote>
<p><code>常量合并</code>：常量计算改为赋值。也就是将 + - * / 转化为 赋值。</p>
<blockquote>
<p>常数传播（未实现，文法限制）：在程序运行时，某段程序中的一些变量之值保持不变。直接替换成值的引用</p>
</blockquote>
<h2 id="5、删除公共子表达式"><a href="#5、删除公共子表达式" class="headerlink" title="5、删除公共子表达式"></a>5、删除公共子表达式</h2><p>算法思路[1]：</p>
<ul>
<li>（当前四元式序号为A）从A开始扫描基本块，由上向下找出有相同的op（对应DAG图中的父节点），var1（对应DAG图中的左子节点），var2（对应DAG图中的右子节点）且var3为临时变量的四元式B</li>
<li>从B向下继续扫描四元式，寻找所有与B具有相同var的四元式C1，C2，…；</li>
<li>将Ci的var置为var3；</li>
<li>删除B，置B为 NULL</li>
</ul>
<h1 id="八、错误处理"><a href="#八、错误处理" class="headerlink" title="八、错误处理"></a>八、错误处理</h1><h3 id="8-1、错误识别"><a href="#8-1、错误识别" class="headerlink" title="8.1、错误识别"></a>8.1、错误识别</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 匹配 期待的 token；否则报错</span></span><br><span class="line"><span class="comment">// 读取下一个token</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">match</span><span class="params">(TokenType expectToken)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (expectToken == g_token.opType) &#123;	<span class="comment">// 与预期相同，跳过token， true</span></span><br><span class="line">		<span class="built_in">getNextToken</span>();</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;								<span class="comment">// 提示错误，但在这里不跳读</span></span><br><span class="line">		g_errorNum++;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;match error in line %d :\t\texpect Token %d, but %d value: %s \n&quot;</span>, g_lineNumber, expectToken, g_token.opType, g_token.value);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="8-2、跳读到可以正确分析的位置"><a href="#8-2、跳读到可以正确分析的位置" class="headerlink" title="8.2、跳读到可以正确分析的位置"></a>8.2、跳读到可以正确分析的位置</h3><p>直到识别到某些token才停止；</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;</span><br><span class="line">    LACK_SEMI_CST,              <span class="comment">// 常量定义没有分号，跳出当前，直到再次遇到常量定义、变量定义、语句</span></span><br><span class="line">    LACK_TYPE_CST,              <span class="comment">// 没有类型</span></span><br><span class="line">    LACK_ID_CST,                <span class="comment">// 没有标识符</span></span><br><span class="line">    LACK_ASSIGN_CST,            <span class="comment">// 没有赋值符号</span></span><br><span class="line"></span><br><span class="line">    LACK_XXX_VARDEF,            <span class="comment">// 变量定义出错，直接抛弃当前语句</span></span><br><span class="line"></span><br><span class="line">    LACK_TYPE_FUN,              <span class="comment">// 函数类型未说明</span></span><br><span class="line">    LACK_IDEN_FUN,              <span class="comment">// 函数名未说明   ， </span></span><br><span class="line">    LACK_KUOHAO_FUN,            <span class="comment">// 函数括号丢失   ， 跳过当前函数</span></span><br><span class="line"></span><br><span class="line">    SENTENCE_ERROR</span><br><span class="line">&#125;ErrorType;</span><br></pre></td></tr></table></figure>
<p>大致思想：</p>
<p>常量定义、变量定义、函数定义：跳过当前定义</p>
<p>语句：跳过当前语句</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (e)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">case</span> ErrorType::LACK_SEMI_CST:</span><br><span class="line">	<span class="keyword">case</span> ErrorType::LACK_TYPE_CST: </span><br><span class="line">	<span class="keyword">case</span> ErrorType::LACK_ID_CST:</span><br><span class="line">	<span class="keyword">case</span> ErrorType::LACK_ASSIGN_CST: &#123;</span><br><span class="line">		<span class="keyword">while</span> (g_token.opType != TokenType::CONST &amp;&amp; g_token.opType != TokenType::INT &amp;&amp; g_token.opType != TokenType::CHAR</span><br><span class="line">			&amp;&amp; g_token.opType != TokenType::VOID &amp;&amp; g_token.opType != TokenType::IF</span><br><span class="line">			&amp;&amp; g_token.opType != TokenType::WHILE &amp;&amp; g_token.opType != TokenType::FOR</span><br><span class="line">			&amp;&amp; g_token.opType != TokenType::IDEN &amp;&amp; g_token.opType != TokenType::RETURN</span><br><span class="line">			&amp;&amp; g_token.opType != TokenType::SCANF &amp;&amp; g_token.opType != TokenType::PRINTF</span><br><span class="line">			&amp;&amp; g_token.opType != TokenType::LBRACE &amp;&amp; g_token.opType != TokenType::RBRACE</span><br><span class="line">			)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (g_token.opType == TokenType::END) </span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">getNextToken</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 以上都是常量定义阶段的错误</span></span><br><span class="line">	<span class="comment">// 变量定义错误：</span></span><br><span class="line">	<span class="keyword">case</span> ErrorType::LACK_XXX_VARDEF: &#123;</span><br><span class="line">		<span class="keyword">while</span> (g_token.opType != TokenType::INT &amp;&amp; g_token.opType != TokenType::CHAR</span><br><span class="line">			&amp;&amp; g_token.opType != TokenType::VOID &amp;&amp; g_token.opType != TokenType::IF</span><br><span class="line">			&amp;&amp; g_token.opType != TokenType::WHILE &amp;&amp; g_token.opType != TokenType::FOR</span><br><span class="line">			&amp;&amp; g_token.opType != TokenType::IDEN &amp;&amp; g_token.opType != TokenType::RETURN</span><br><span class="line">			&amp;&amp; g_token.opType != TokenType::SCANF &amp;&amp; g_token.opType != TokenType::PRINTF</span><br><span class="line">			&amp;&amp; g_token.opType != TokenType::LBRACE &amp;&amp; g_token.opType != TokenType::RBRACE</span><br><span class="line">			)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (g_token.opType == TokenType::END)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">getNextToken</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 函数定义错误</span></span><br><span class="line">	<span class="keyword">case</span> ErrorType::LACK_TYPE_FUN:</span><br><span class="line">	<span class="keyword">case</span> ErrorType::LACK_IDEN_FUN: </span><br><span class="line">	<span class="keyword">case</span> ErrorType::LACK_KUOHAO_FUN: &#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span> (g_token.opType != TokenType::INT &amp;&amp; g_token.opType != TokenType::CHAR</span><br><span class="line">			&amp;&amp; g_token.opType != TokenType::VOID</span><br><span class="line">			)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (g_token.opType == TokenType::END)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">getNextToken</span>();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 语句错误</span></span><br><span class="line">	<span class="keyword">case</span> ErrorType::SENTENCE_ERROR: &#123;</span><br><span class="line">		<span class="keyword">while</span> (g_token.opType != TokenType::IF</span><br><span class="line">			&amp;&amp; g_token.opType != TokenType::WHILE &amp;&amp; g_token.opType != TokenType::FOR</span><br><span class="line">			&amp;&amp; g_token.opType != TokenType::IDEN &amp;&amp; g_token.opType != TokenType::RETURN</span><br><span class="line">			&amp;&amp; g_token.opType != TokenType::SCANF &amp;&amp; g_token.opType != TokenType::PRINTF</span><br><span class="line">			<span class="comment">/*&amp;&amp; g_token.opType != TokenType::LBRACE */</span>&amp;&amp; g_token.opType != TokenType::RBRACE</span><br><span class="line">			)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (g_token.opType == TokenType::END)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">getNextToken</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h3 id="8-3-语法树错误屏蔽"><a href="#8-3-语法树错误屏蔽" class="headerlink" title="8.3 语法树错误屏蔽"></a>8.3 语法树错误屏蔽</h3><p>语法树标识错误，语义分析时跳过。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误处理</span></span><br><span class="line"><span class="type">bool</span> error;</span><br></pre></td></tr></table></figure>
<h1 id="九、-bug修复"><a href="#九、-bug修复" class="headerlink" title="九、 bug修复"></a>九、 bug修复</h1><h3 id="1、asm生成阶段：scanf语句"><a href="#1、asm生成阶段：scanf语句" class="headerlink" title="1、asm生成阶段：scanf语句"></a>1、asm生成阶段：scanf语句</h3><p>bug：多次读取同名变量时，由于scanf是直接写入内存，但或许之前使用过这个变量，并且已经调入寄存器；查表的时候会显示在寄存器堆中，这样就会读取就值；<br>    发现于 Test11.c0；多次输入x，发现后面使用的x的值始终不变<br>    (old，会带来新问题，可用寄存器数目不断减少)处理：从寄存器堆中移除此变量，且不用写回内存；故只需更新符号表状态、寄存器映射队列、可用寄存器数目<br>    (new)处理：如果在寄存器，则更新寄存器数据即可，其他不变</p>
<h3 id="2、寄存器分配策略错误"><a href="#2、寄存器分配策略错误" class="headerlink" title="2、寄存器分配策略错误"></a>2、寄存器分配策略错误</h3><p>之前的寄存器分配是按照函数分配的（跳转函数才会清空寄存器）；后来在测试到快速排序的时候，由于各种跳转，导致寄存器有问题；不是正确的运行结果；如，之前要判断的某个循环变量分配到1号寄存器，但是循环内部变量较多，1号寄存器被移除，存储新的变量；这时跳转回去判断，寄存器里面就不是原来的变量了。</p>
<p>正确的方法：按照基本块来分配</p>
<p>首先是基本块划分：</p>
<ul>
<li>程序的第一个四元式</li>
<li>转向语句的目标四元式（即j,jnz,jop的目标）</li>
<li>条件跳转jop的下一条（由于四元式生成过程中下一条总是 j）</li>
</ul>
<p>划分完基本块后，在每个基本块结束时清空即可（或是下一基本块开始时，清空上一基本块；本质就是基本块开始时，全部寄存器是空的）；这样就不会出现各种跳转就不会出现寄存器出错的问题。</p>
<p>我采用的具体方法：j的时候清空，遇到label的时候清空。（对应的就是跳转语句的目标和条件跳转的下一句）。所以，该方法时正确的。程序的结果也是正确的。</p>
<h1 id="十、参考"><a href="#十、参考" class="headerlink" title="十、参考"></a>十、参考</h1><blockquote>
<p>  [1]  实现一个C++实现的拓展C0文法MIPS交叉编译器<a target="_blank" rel="noopener" href="https://www.cnblogs.com/sciencefans/articles/4235139.html">https://www.cnblogs.com/sciencefans/articles/4235139.html</a></p>
<p>  [2]  编译原理哈工大慕课与PPT<br>   <a target="_blank" rel="noopener" href="https://www.icourse163.org/learn/HIT-1002123007?tid=1206830204#/learn/content">https://www.icourse163.org/learn/HIT-1002123007?tid=1206830204#/learn/content</a></p>
<p>  [3]  编译原理 第3版 蒋立源 2005</p>
<p>  [4]  现代编译原理C语言描述<em>tif</em>虎书</p>
<p>  [5]  编译原理西工大PPT</p>
<p>  [6]  MIPS汇编入门<br>   <a target="_blank" rel="noopener" href="https://www.cnblogs.com/thoupin/p/4018455.html">https://www.cnblogs.com/thoupin/p/4018455.html</a></p>
<p>  [7]  MIPS汇编快速入门<br>   <a target="_blank" rel="noopener" href="https://blog.csdn.net/u012837895/article/details/79855896">https://blog.csdn.net/u012837895/article/details/79855896</a></p>
<p>  [8]  SYSCALL functions available in MARS<br>   <a target="_blank" rel="noopener" href="https://blog.csdn.net/sdreamq/article/details/50776393">https://blog.csdn.net/sdreamq/article/details/50776393</a></p>
<p>  [9]  Simple语言的定义(LL1文法)<br>   <a target="_blank" rel="noopener" href="https://wenku.baidu.com/view/0fc831e8998fcc22bcd10de9">https://wenku.baidu.com/view/0fc831e8998fcc22bcd10de9</a></p>
<p>  [10] 《编译原理》控制流语句 if 和 while 语句的翻译<br>   <a target="_blank" rel="noopener" href="https://www.cnblogs.com/xpwi/p/11072234.html">https://www.cnblogs.com/xpwi/p/11072234.html</a></p>
</blockquote>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://chen2511.github.io/">MomoChen</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://chen2511.github.io/">http://chen2511.github.io/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">此文章版权归 MomoChen 所有，如有转载，请注明来自原作者</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%BC%96%E8%AF%91%E5%99%A8/">编译器</a><a class="post-meta__tags" href="/tags/C0%E6%96%87%E6%B3%95/">C0文法</a><a class="post-meta__tags" href="/tags/C/">C++</a></div><div class="post_share"><div class="social-share" data-image="/img/complier.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/gh/overtrue/share.js@master/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2020/10/10/%E5%B7%A5%E5%85%B7/Ubuntu%2018.04%20%E7%BE%8E%E5%8C%96%E5%8F%8A%E9%85%8D%E7%BD%AE%E8%BF%87%E7%A8%8B/"><img class="prev-cover" src="/img/linux_all.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Ubuntu18.04 换源、美化及配置过程</div></div></a></div><div class="next-post pull-right"><a href="/2020/07/05/ComplierC0/C0%E6%96%87%E6%B3%95/"><img class="next-cover" src="/img/1575009542094.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">C0文法</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2020/07/05/ComplierC0/C0%E6%96%87%E6%B3%95/" title="C0文法"><img class="cover" src="/img/1575009542094.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-07-05</div><div class="title">C0文法</div></div></a></div><div><a href="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/" title="哈工大慕课《编译原理》笔记"><img class="cover" src="/img/001.PNG" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-07-05</div><div class="title">哈工大慕课《编译原理》笔记</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#CompilerC0"><span class="toc-text">CompilerC0</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E7%BB%9F%E8%AE%A1%E4%BF%A1%E6%81%AF"><span class="toc-text">项目统计信息</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E"><span class="toc-text">使用说明</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E6%96%87%E6%B3%95%E8%AE%BE%E8%AE%A1"><span class="toc-text">一、文法设计</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90"><span class="toc-text">二、词法分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%91%98%E8%A6%81"><span class="toc-text">摘要</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-text">正则表达式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#NFA-%E4%B8%8D%E7%A1%AE%E5%AE%9A%E6%9C%89%E9%99%90%E8%87%AA%E5%8A%A8%E6%9C%BA"><span class="toc-text">NFA 不确定有限自动机</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DFA-%E7%A1%AE%E5%AE%9A%E7%9A%84%E6%9C%89%E9%99%90%E8%87%AA%E5%8A%A8%E6%9C%BA"><span class="toc-text">DFA 确定的有限自动机</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DFA-%E6%9C%80%E5%B0%8F%E5%8C%96"><span class="toc-text">DFA 最小化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%E7%BC%96%E7%A8%8B%E5%AE%9E%E7%8E%B0"><span class="toc-text">词法分析编程实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-text">数据结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Token"><span class="toc-text">1 Token</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-TokenType"><span class="toc-text">2 TokenType</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%BF%9D%E7%95%99%E5%AD%97%E8%A1%A8"><span class="toc-text">3 保留字表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E7%8A%B6%E6%80%81"><span class="toc-text">4 状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DFA%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3"><span class="toc-text">DFA编程思想</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E9%80%9A%E8%BF%87%E4%BB%A3%E7%A0%81%E4%BD%8D%E7%BD%AE%E8%A1%A8%E7%A4%BA%E9%9A%90%E5%90%AB%E7%8A%B6%E6%80%81"><span class="toc-text">1 通过代码位置表示隐含状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%8F%8C%E9%87%8Dcase"><span class="toc-text">2 双重case</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E8%BD%AC%E6%8D%A2%E8%A1%A8"><span class="toc-text">3 转换表</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E9%97%AE%E9%A2%98%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89"><span class="toc-text">注意问题（重点）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E8%AF%BB%E5%85%A5%E7%BC%93%E5%86%B2"><span class="toc-text">1、读入缓冲</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E4%BF%9D%E7%95%99%E5%AD%97%E7%9A%84%E8%AF%86%E5%88%AB"><span class="toc-text">2、保留字的识别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E5%B8%A6%E7%AC%A6%E5%8F%B7%E6%95%B0%E5%A4%84%E7%90%86"><span class="toc-text">3、带符号数处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3%E4%B8%8E%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%EF%BC%88%E7%95%A5%EF%BC%89"><span class="toc-text">4、冲突解决与错误处理（略）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90"><span class="toc-text">三、语法分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%91%98%E8%A6%81-1"><span class="toc-text">摘要</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E8%AF%AD%E6%B3%95%E6%A0%91-AST-%E7%9A%84%E7%90%86%E8%AE%BA%E8%AE%BE%E8%AE%A1"><span class="toc-text">抽象语法树 AST 的理论设计</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LL-1-%E6%96%87%E6%B3%95%E7%9A%84%E7%90%86%E8%AE%BA%E5%AE%9A%E4%B9%89"><span class="toc-text">LL(1)文法的理论定义</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#FIRST%E9%9B%86%E5%90%88"><span class="toc-text">FIRST集合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#FOLLOW%E9%9B%86%E5%90%88"><span class="toc-text">FOLLOW集合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LL-1-%E6%96%87%E6%B3%95"><span class="toc-text">LL(1)文法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E7%A8%8B%EF%BC%9A%E9%80%92%E5%BD%92%E5%90%91%E4%B8%8B%E5%88%86%E6%9E%90%E6%B3%95%EF%BC%88%E4%BD%BF%E7%94%A8%E9%80%92%E5%BD%92%E5%AD%90%E7%A8%8B%E5%BA%8F%E6%B3%95%EF%BC%89"><span class="toc-text">编程：递归向下分析法（使用递归子程序法）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81AST%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%A1%A8%E7%A4%BA"><span class="toc-text">1、AST的程序表示</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81ENBF%E8%8C%83%E5%BC%8F%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-text">2、ENBF范式代码实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E9%97%AE%E9%A2%98%EF%BC%88%E8%BF%99%E9%87%8C%E6%B6%89%E5%8F%8A%E6%96%87%E6%B3%95%E8%AE%BE%E8%AE%A1%EF%BC%89"><span class="toc-text">注意问题（这里涉及文法设计）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E9%81%BF%E5%85%8D%E5%9B%9E%E6%BA%AF%EF%BC%88%E6%8F%90%E9%AB%98%E6%95%88%E7%8E%87%EF%BC%89"><span class="toc-text">1、避免回溯（提高效率）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E4%BA%8C%E4%B9%89%E6%80%A7"><span class="toc-text">2、二义性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E6%B6%88%E9%99%A4%E5%B7%A6%E9%80%92%E5%BD%92%EF%BC%88%E9%81%BF%E5%85%8D%E6%AD%BB%E5%BE%AA%E7%8E%AF%EF%BC%89%EF%BC%88%E7%95%A5%EF%BC%89"><span class="toc-text">3、消除左递归（避免死循环）（略）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E6%8F%90%E5%8F%96%E5%85%AC%E5%9B%A0%E5%AD%90%EF%BC%88%E7%95%A5%EF%BC%89"><span class="toc-text">4、提取公因子（略）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E8%AF%AD%E4%B9%89%E5%88%86%E6%9E%90"><span class="toc-text">四、语义分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%91%98%E8%A6%81-2"><span class="toc-text">摘要</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%A6%E5%8F%B7%E8%A1%A8"><span class="toc-text">符号表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E5%AE%9E%E7%8E%B0"><span class="toc-text">程序实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%AD%E4%B9%89%E6%A3%80%E6%9F%A5"><span class="toc-text">语义检查</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E4%B8%AD%E9%97%B4%E4%BB%A3%E7%A0%81%EF%BC%88%E5%9B%9B%E5%85%83%E5%BC%8F%EF%BC%89%E7%94%9F%E6%88%90"><span class="toc-text">五、中间代码（四元式）生成</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%91%98%E8%A6%81-3"><span class="toc-text">摘要</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E5%9B%9B%E5%85%83%E5%BC%8F"><span class="toc-text">设计四元式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%9C%AF%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E5%9B%9B%E5%85%83%E5%BC%8F%E7%94%9F%E6%88%90"><span class="toc-text">算术表达式的四元式生成</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%83%E5%B0%94%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E5%9B%9B%E5%85%83%E5%BC%8F%E7%94%9F%E6%88%90"><span class="toc-text">布尔表达式的四元式生成</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E7%9B%AE%E6%A0%87%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90-MIPS"><span class="toc-text">六、目标代码生成-MIPS</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%91%98%E8%A6%81-4"><span class="toc-text">摘要</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E6%96%B9%E6%A1%88"><span class="toc-text">内存分配方案</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8%E5%88%86%E9%85%8D%E6%80%9D%E8%B7%AF"><span class="toc-text">寄存器分配思路</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9A%BE%E7%82%B9-Bug%EF%BC%9A%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E8%A6%81%E4%BF%9D%E5%AD%98%E7%8E%B0%E5%9C%BA%EF%BC%9F"><span class="toc-text">难点-Bug：什么时候要保存现场？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%88%E5%B8%A7%E5%A4%84%E7%90%86%E8%BF%87%E7%A8%8B%EF%BC%9A"><span class="toc-text">栈帧处理过程：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E5%87%BD%E6%95%B0%E5%BC%80%E5%A7%8B%EF%BC%9A"><span class="toc-text">1、函数开始：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E5%87%BD%E6%95%B0%E7%BB%93%E6%9D%9F%EF%BC%9A"><span class="toc-text">2、函数结束：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%AF%AD%E5%8F%A5%EF%BC%9A"><span class="toc-text">3、函数调用语句：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81return%E8%AF%AD%E5%8F%A5"><span class="toc-text">4、return语句</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E8%AF%AD%E5%8F%A5%EF%BC%88%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%EF%BC%89%EF%BC%9A"><span class="toc-text">其他语句（系统调用）：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9A%BE%E7%82%B9%EF%BC%9A"><span class="toc-text">难点：</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E4%BC%98%E5%8C%96"><span class="toc-text">七、优化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E5%88%92%E5%88%86%E5%9F%BA%E6%9C%AC%E5%9D%97"><span class="toc-text">1、划分基本块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E5%AF%84%E5%AD%98%E5%99%A8%E4%BC%98%E5%8C%96"><span class="toc-text">2、寄存器优化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E5%BC%BA%E5%BA%A6%E5%89%8A%E5%BC%B1"><span class="toc-text">3、强度削弱</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81%E5%B8%B8%E9%87%8F%E5%90%88%E5%B9%B6"><span class="toc-text">4、常量合并</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81%E5%88%A0%E9%99%A4%E5%85%AC%E5%85%B1%E5%AD%90%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-text">5、删除公共子表达式</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AB%E3%80%81%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86"><span class="toc-text">八、错误处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1%E3%80%81%E9%94%99%E8%AF%AF%E8%AF%86%E5%88%AB"><span class="toc-text">8.1、错误识别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2%E3%80%81%E8%B7%B3%E8%AF%BB%E5%88%B0%E5%8F%AF%E4%BB%A5%E6%AD%A3%E7%A1%AE%E5%88%86%E6%9E%90%E7%9A%84%E4%BD%8D%E7%BD%AE"><span class="toc-text">8.2、跳读到可以正确分析的位置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-%E8%AF%AD%E6%B3%95%E6%A0%91%E9%94%99%E8%AF%AF%E5%B1%8F%E8%94%BD"><span class="toc-text">8.3 语法树错误屏蔽</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B9%9D%E3%80%81-bug%E4%BF%AE%E5%A4%8D"><span class="toc-text">九、 bug修复</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81asm%E7%94%9F%E6%88%90%E9%98%B6%E6%AE%B5%EF%BC%9Ascanf%E8%AF%AD%E5%8F%A5"><span class="toc-text">1、asm生成阶段：scanf语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E5%AF%84%E5%AD%98%E5%99%A8%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5%E9%94%99%E8%AF%AF"><span class="toc-text">2、寄存器分配策略错误</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E3%80%81%E5%8F%82%E8%80%83"><span class="toc-text">十、参考</span></a></li></ol></div></div></div></div></main><footer id="footer" style="background-image: url('/img/20150525233356_zkayE.png')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By MomoChen</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">欢迎来到漠漠的博客</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu@4/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>function addGitalkSource () {
  const ele = document.createElement('link')
  ele.rel = 'stylesheet'
  ele.href= 'https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css'
  document.getElementsByTagName('head')[0].appendChild(ele)
}

function loadGitalk () {
  function initGitalk () {
    var gitalk = new Gitalk(Object.assign({
      clientID: 'de79d51950505839a9fe',
      clientSecret: '9461941e93326020b9e565d3ef15d8b9d0513548',
      repo: 'chen2511.github.io',
      owner: 'chen2511',
      admin: ['chen2511'],
      id: '51f85238a567e2bab5197354f7d68513',
      updateCountCallback: commentCount
    },null))

    gitalk.render('gitalk-container')
  }

  if (typeof Gitalk === 'function') initGitalk()
  else {
    addGitalkSource()
    getScript('https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js').then(initGitalk)
  }
}

function commentCount(n){
  let isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
  if (isCommentCount) {
    isCommentCount.innerHTML= n
  }
}

if ('Gitalk' === 'Gitalk' || !false) {
  if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
  else loadGitalk()
} else {
  function loadOtherComment () {
    loadGitalk()
  }
}</script></div><script>window.addEventListener('load', () => {
  const changeContent = (content) => {
    if (content === '') return content

    content = content.replace(/<img.*?src="(.*?)"?[^\>]+>/ig, '[图片]') // replace image link
    content = content.replace(/<a[^>]+?href=["']?([^"']+)["']?[^>]*>([^<]+)<\/a>/gi, '[链接]') // replace url
    content = content.replace(/<pre><code>.*?<\/pre>/gi, '[代码]') // replace code
    content = content.replace(/<[^>]+>/g,"") // remove html tag

    if (content.length > 150) {
      content = content.substring(0,150) + '...'
    }
    return content
  }

  const findTrueUrl = (array) => {
    Promise.all(array.map(item =>
      fetch(item.url).then(resp => resp.json()).then(data => {
        const urlArray = data.body.match(/(https?:\/\/)?([\da-z\.-]+)\.([a-z\.]{2,6})([\/\w \.-]*)*\/?/ig)
        if (data.user.login === 'utterances-bot') {
          return urlArray.pop()
        } else {
          return urlArray.shift()
        }
      })
    )).then(res => {
        array = array.map((i,index)=> {
          return {
            ...i,
            url: res[index]
          }
        })

        saveToLocal.set('github-newest-comments', JSON.stringify(array), 10/(60*24))
        generateHtml(array)
    });
  }

  const getComment = () => {
    fetch('https://api.github.com/repos/chen2511/chen2511.github.io/issues/comments?sort=updated&direction=desc&per_page=6&page=1',{
      "headers": {
        Accept: 'application/vnd.github.v3.html+json'
      }
    })
      .then(response => response.json())
      .then(data => {
        const githubArray = data.map(item => {
          return {
            'avatar': item.user.avatar_url,
            'content': changeContent(item.body_html),
            'nick': item.user.login,
            'url': item.issue_url,
            'date': item.updated_at,
            'githubUrl': item.html_url
          }
        })
        findTrueUrl(githubArray)
      }).catch(e => {
        const $dom = document.querySelector('#card-newest-comments .aside-list')
        $dom.innerHTML= "无法获取评论，请确认相关配置是否正确"
      })
  }

  const generateHtml = array => {
    let result = ''

    if (array.length) {
      for (let i = 0; i < array.length; i++) {
        result += '<div class=\'aside-list-item\'>'

        if (true) {
          const name = 'src'
          result += `<a href='${array[i].url}' class='thumbnail'><img ${name}='${array[i].avatar}' alt='${array[i].nick}'></a>`
        }

        result += `<div class='content'>
        <a class='comment' href='${array[i].url}' title='${array[i].content}'>${array[i].content}</a>
        <div class='name'><span>${array[i].nick} / </span><time datetime="${array[i].date}">${btf.diffDate(array[i].date, true)}</time></div>
        </div></div>`
      }
    } else {
      result += '没有评论'
    }

    let $dom = document.querySelector('#card-newest-comments .aside-list')
    $dom.innerHTML= result
    window.lazyLoadInstance && window.lazyLoadInstance.update()
    window.pjax && window.pjax.refresh($dom)
  }

  const newestCommentInit = () => {
    if (document.querySelector('#card-newest-comments .aside-list')) {
      const data = saveToLocal.get('github-newest-comments')
      if (data) {
        generateHtml(JSON.parse(data))
      } else {
        getComment()
      }
    }
  }

  newestCommentInit()
  document.addEventListener('pjax:complete', newestCommentInit)
})</script><div class="aplayer no-destroy" data-id="7715079288" data-server="netease" data-type="playlist" data-fixed="true" data-autoplay="true"> </div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-nest.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer@1/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/gh/metowolf/MetingJS@1.2/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  typeof preloader === 'object' && preloader.initLoading()
  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>