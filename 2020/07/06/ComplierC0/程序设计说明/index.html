<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>ComplierC0 | MomoChen</title><meta name="keywords" content="编译器,C0文法,C++"><meta name="author" content="MomoChen"><meta name="copyright" content="MomoChen"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="来自NWPU课程《编译原理》试点班作业：编写一个C0文法的编译器。以递归下降子程序实现语法分析，输出AST，符号表，优化中间表达式，最终生成MIPS汇编代码。">
<meta property="og:type" content="article">
<meta property="og:title" content="ComplierC0">
<meta property="og:url" content="https://chen2511.github.io/2020/07/06/ComplierC0/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%B4%E6%98%8E/index.html">
<meta property="og:site_name" content="MomoChen">
<meta property="og:description" content="来自NWPU课程《编译原理》试点班作业：编写一个C0文法的编译器。以递归下降子程序实现语法分析，输出AST，符号表，优化中间表达式，最终生成MIPS汇编代码。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://chen2511.github.io/img/complier.png">
<meta property="article:published_time" content="2020-07-05T16:00:00.000Z">
<meta property="article:modified_time" content="2022-06-29T13:06:50.399Z">
<meta property="article:author" content="MomoChen">
<meta property="article:tag" content="编译器">
<meta property="article:tag" content="C0文法">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://chen2511.github.io/img/complier.png"><link rel="shortcut icon" href="/img/favicon.jpg"><link rel="canonical" href="https://chen2511.github.io/2020/07/06/ComplierC0/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%B4%E6%98%8E/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":1,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":800},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: true
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":500,"languages":{"author":"作者: MomoChen","link":"链接: ","source":"来源: MomoChen","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'mediumZoom',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'ComplierC0',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-06-29 21:06:50'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.2"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/favicon.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">34</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">24</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我的</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/complier_all.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">MomoChen</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我的</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">ComplierC0</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-07-05T16:00:00.000Z" title="发表于 2020-07-06 00:00:00">2020-07-06</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-06-29T13:06:50.399Z" title="更新于 2022-06-29 21:06:50">2022-06-29</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AF%BE%E7%A8%8B%E5%A4%A7%E4%BD%9C%E4%B8%9A/">课程大作业</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AF%BE%E7%A8%8B%E5%A4%A7%E4%BD%9C%E4%B8%9A/C0%E7%BC%96%E8%AF%91%E5%99%A8/">C0编译器</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">9.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>34分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="ComplierC0"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="CompilerC0"><a href="#CompilerC0" class="headerlink" title="CompilerC0"></a>CompilerC0</h1><p>来自NWPU课程《编译原理》试点班作业【2020年上】：编写一个C0文法的编译器。以递归下降子程序实现语法分析，输出AST，构建符号表，优化中间表达式，最终生成MIPS汇编代码。</p>
<blockquote>
<p>  本文是在编写程序过程中的记录，有些不是很完善，导致后续再回头补充的时候也忘了许多内容，还有就是因为懒吧。。。</p>
<p>  项目地址：<a target="_blank" rel="noopener" href="https://github.com/chen2511/CompilerC0">chen2511/CompilerC0: C0 文法编译器 Visual Studio2019 (github.com)</a></p>
</blockquote>
<h2 id="零、文件说明"><a href="#零、文件说明" class="headerlink" title="零、文件说明"></a>零、文件说明</h2><ul>
<li>global.h：全局数据结构、全局变量</li>
<li>scan.h：</li>
<li>scan.cpp：词法分析实现</li>
<li>parser.h：</li>
<li>parser.cpp：语法分析：递归下降分析</li>
<li>ast.h：</li>
<li>ast.cpp：AST创建不同类型节点、输出AST</li>
<li>symtab.h：</li>
<li>symtab.cpp：符号表基本操作：插入、查找、初始化</li>
<li>semantic.h：</li>
<li>semantic.cpp：遍历AST，构建符号表、语义检查</li>
<li>ir.cpp：递归遍历AST，生成ir中间表达式</li>
<li>ir.h：</li>
<li>asm.cpp：由中间表达式生成MIPS汇编代码</li>
<li>asm.h：</li>
<li>opt.cpp：对中间表达式进行优化</li>
<li>opt.h：</li>
<li>main.cpp：主程序，依次进行：词法分析，语法分析，建立AST，生成符号表，中间表达式，优化和生成汇编代码</li>
</ul>
<h3 id="0-1-统计信息"><a href="#0-1-统计信息" class="headerlink" title="0.1 统计信息"></a>0.1 统计信息</h3><div class="table-container">
<table>
<thead>
<tr>
<th>行数</th>
<th>代码行数</th>
<th>代码//注释</th>
<th>注释</th>
<th>空行</th>
</tr>
</thead>
<tbody>
<tr>
<td>5497</td>
<td>3812</td>
<td>235</td>
<td>644</td>
<td>806</td>
</tr>
</tbody>
</table>
</div>
<h2 id="一、词法分析："><a href="#一、词法分析：" class="headerlink" title="一、词法分析："></a>一、词法分析：</h2><blockquote>
<p>  理论来自louden书和哈工大慕课、ppt和曾老师的课堂</p>
<p>  文件：scan.h;scan.cpp</p>
</blockquote>
<h3 id="1-1-分析思路"><a href="#1-1-分析思路" class="headerlink" title="1.1 分析思路"></a>1.1 分析思路</h3><p>理论：</p>
<blockquote>
<p>  文法》正则表达式》NFA》DFA》DFA最小化》编程实现</p>
</blockquote>
<p>分为三种类型：保留字、特殊符号（运算符等等）、其他（数字、标识符、字符串、字符）</p>
<blockquote>
<p>  把保留字先看作标识符、再进行识别</p>
<p>  所以，识别特殊符号、无符号数字、标识符、字符串、字符即可</p>
</blockquote>
<h4 id="1-1-1-正则表达式"><a href="#1-1-1-正则表达式" class="headerlink" title="1.1.1 正则表达式"></a>1.1.1 正则表达式</h4><p>数字：<code>[1-9][0-9]*|0</code></p>
<p>标识符：<code>[_a-zA-Z][_a-zA-Z0-9]*</code></p>
<p>运算符：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+ - * / </span><br><span class="line">&amp;&amp;  &#x27;||&#x27;  !</span><br><span class="line">&lt; &lt;= &gt; &gt;= != == </span><br><span class="line">= ： , ; [ ] &#123; &#125; ( ) </span><br></pre></td></tr></table></figure>
<p>字符：<code>&#39;[&lt;加法运算符&gt;｜&lt;乘法运算符&gt;｜&lt;字母&gt;｜&lt;数字&gt;]&#39;</code></p>
<p>字符串：<code>&quot;｛十进制编码为32,33,35-126的ASCII字符｝&quot;</code></p>
<h4 id="1-1-2-NFA"><a href="#1-1-2-NFA" class="headerlink" title="1.1.2 NFA"></a>1.1.2 NFA</h4><h4 id="1-1-3-DFA"><a href="#1-1-3-DFA" class="headerlink" title="1.1.3 DFA"></a>1.1.3 DFA</h4><blockquote>
<p>  比较简单。。。。似乎不用什么操作了</p>
</blockquote>
<h3 id="1-2-数据结构"><a href="#1-2-数据结构" class="headerlink" title="1.2 数据结构"></a>1.2 数据结构</h3><h4 id="1-2-1-Token"><a href="#1-2-1-Token" class="headerlink" title="1.2.1 Token"></a>1.2.1 Token</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    TokenType opType;</span><br><span class="line">    <span class="type">char</span> * value;</span><br><span class="line">&#125;Token;</span><br></pre></td></tr></table></figure>
<h4 id="1-2-2-TokenType"><a href="#1-2-2-TokenType" class="headerlink" title="1.2.2 TokenType"></a>1.2.2 TokenType</h4><p>枚举类型</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;</span><br><span class="line">    <span class="comment">//关键字：</span></span><br><span class="line">    CHAR, CONST, ELSE, FALSE, FOR,              <span class="comment">//0-4</span></span><br><span class="line">    IF, INT, MAIN, PRINTF, RETURN,              <span class="comment">//5-9</span></span><br><span class="line">    SCANF, TRUE, VOID, WHILE,                   <span class="comment">//10-13</span></span><br><span class="line">    NUM, IDEN, LETTER, STRING,                  <span class="comment">//14-17:数字、标识符、字符、字符串</span></span><br><span class="line">    PLUS, MINU, MULT, DIV,                      <span class="comment">//18-21:+ - * /</span></span><br><span class="line">    AND, OR, NOT,                               <span class="comment">//22-24:&amp;&amp; || !</span></span><br><span class="line">    LSS, LEQ, GRE, GEQ, NEQ, EQL,               <span class="comment">//25-30关系运算符: &lt; &lt;= &gt; &gt;= != ==</span></span><br><span class="line">    ASSIGN, COLON, COMMA, SEMICOLON,            <span class="comment">//31-34: =  :  ,  ;</span></span><br><span class="line">    LBRACE, RBRACE, LBRACKET, RBRACKET,         <span class="comment">//35-38:&#123; &#125; [ ]</span></span><br><span class="line">    LPARENTHES, RPARENTHES,                     <span class="comment">//39-40:( )                                         </span></span><br><span class="line">&#125;TokenType;</span><br></pre></td></tr></table></figure>
<h4 id="1-2-3-保留字表"><a href="#1-2-3-保留字表" class="headerlink" title="1.2.3 保留字表"></a>1.2.3 保留字表</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span>* reservedWords[] = &#123;</span><br><span class="line">    <span class="string">&quot;case&quot;</span>, <span class="string">&quot;char&quot;</span>, <span class="string">&quot;const&quot;</span>, <span class="string">&quot;default&quot;</span>, <span class="string">&quot;else&quot;</span>,</span><br><span class="line">    <span class="string">&quot;false&quot;</span>, <span class="string">&quot;for&quot;</span>, <span class="string">&quot;if&quot;</span>, <span class="string">&quot;int&quot;</span>, <span class="string">&quot;main&quot;</span>,</span><br><span class="line">    <span class="string">&quot;printf&quot;</span>, <span class="string">&quot;return&quot;</span>, <span class="string">&quot;scanf&quot;</span>, <span class="string">&quot;switch&quot;</span>, <span class="string">&quot;true&quot;</span>,</span><br><span class="line">    <span class="string">&quot;void&quot;</span>, <span class="string">&quot;while&quot;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="1-2-4-状态"><a href="#1-2-4-状态" class="headerlink" title="1.2.4 状态"></a>1.2.4 状态</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;</span><br><span class="line">    STATE_START, STATE_NUM, STATE_ID, STATE_CHAR, STATE_STRING, STATE_DONE</span><br><span class="line">&#125;StateType;</span><br></pre></td></tr></table></figure>
<h3 id="1-3-DFA编程思想"><a href="#1-3-DFA编程思想" class="headerlink" title="1.3 DFA编程思想"></a>1.3 DFA编程思想</h3><blockquote>
<p>  来自louden书的思路</p>
</blockquote>
<h4 id="1-3-1、隐含状态"><a href="#1-3-1、隐含状态" class="headerlink" title="1.3.1、隐含状态"></a>1.3.1、隐含状态</h4><p>注意<code>advance the input</code>表示读入一个符号</p>
<p><img src="/2020/07/06/ComplierC0/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%B4%E6%98%8E/image-20200416115119049.png" alt="识别标识符的状态机"></p>
<p><img src="/2020/07/06/ComplierC0/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%B4%E6%98%8E/image-20200416110131830.png" alt="DFA实现"></p>
<h4 id="1-3-2、双重case"><a href="#1-3-2、双重case" class="headerlink" title="1.3.2、双重case"></a>1.3.2、双重case</h4><p><img src="/2020/07/06/ComplierC0/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%B4%E6%98%8E/image-20200416115645554.png" alt="双重case实现DFA"></p>
<h4 id="1-3-3、转换表"><a href="#1-3-3、转换表" class="headerlink" title="1.3.3、转换表"></a>1.3.3、转换表</h4><p><img src="/2020/07/06/ComplierC0/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%B4%E6%98%8E/image-20200416110233447.png" alt="转换表实现DFA"></p>
<h3 id="1-4-注意问题："><a href="#1-4-注意问题：" class="headerlink" title="1.4 注意问题："></a>1.4 注意问题：</h3><h4 id="1-4-1、读入缓冲"><a href="#1-4-1、读入缓冲" class="headerlink" title="1.4.1、读入缓冲"></a>1.4.1、读入缓冲</h4><blockquote>
<p>  缓冲的意思是，不是直接通过指针操作，而是，先读进来一个数组的数据，在数组中操作；</p>
<p>  然后有单缓冲和双缓冲的区别；而北航是多了一个backup数组；</p>
<p>  louden书中的例子，也是有一个缓冲数组lineBuf</p>
</blockquote>
<h4 id="1-4-2、保留字的识别"><a href="#1-4-2、保留字的识别" class="headerlink" title="1.4.2、保留字的识别"></a>1.4.2、保留字的识别</h4><blockquote>
<p>  先看做标识符，再识别保留字；</p>
<p>  保留字表，字典序查询</p>
</blockquote>
<p><img src="/2020/07/06/ComplierC0/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%B4%E6%98%8E/image-20200416110914211.png" alt="识别保留字1"></p>
<p><img src="/2020/07/06/ComplierC0/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%B4%E6%98%8E/image-20200416110407763.png" alt="识别保留字2"></p>
<p>保留字表；</p>
<p>如果比较大，就用二分查找</p>
<h4 id="1-4-3、带符号数处理"><a href="#1-4-3、带符号数处理" class="headerlink" title="1.4.3、带符号数处理"></a>1.4.3、带符号数处理</h4><blockquote>
<p>  +1+1</p>
<p>  第二个 +1和第一个+1是有区别的，词法分析阶段识别带符号数，最长字串原则，会有问题</p>
</blockquote>
<h5 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h5><p>带符号整数出现于变量定义时，这个地方不会存在问题，语法分析时处理；</p>
<p>另一个是位于表达式中：</p>
<blockquote>
<p>  数学上的形式：其中要么带符号数要么在开头，要么有括号；其他情况数字都是无符号的</p>
</blockquote>
<p>因为表达式开头有符号定义，可以忽略这个；</p>
<p>而对于带符号数在表达式内部，肯定实在括号内部，所以又可以递归回去，用开头的符号；</p>
<p>所以总结起来也是语法分析阶段处理</p>
<p>还有就是布尔表达式的地方，也是单独分析</p>
<h5 id="处理方法"><a href="#处理方法" class="headerlink" title="处理方法"></a>处理方法</h5><p>放到语法分析中处理带符号数</p>
<h4 id="1-3-4、冲突解决"><a href="#1-3-4、冲突解决" class="headerlink" title="1.3.4、冲突解决"></a>1.3.4、冲突解决</h4><h4 id="1-3-5、错误处理"><a href="#1-3-5、错误处理" class="headerlink" title="1.3.5、错误处理"></a>1.3.5、错误处理</h4><h2 id="二、语法分析"><a href="#二、语法分析" class="headerlink" title="二、语法分析"></a>二、语法分析</h2><h3 id="2-1-文法改造"><a href="#2-1-文法改造" class="headerlink" title="2.1 文法改造"></a>2.1 文法改造</h3><blockquote>
<p>  这一部分 花了大量时间，需要验证文法的可行性；以及编程的可行性</p>
</blockquote>
<h4 id="2-1-1-二义性"><a href="#2-1-1-二义性" class="headerlink" title="2.1.1 二义性"></a>2.1.1 二义性</h4><ul>
<li>if else</li>
<li>表达式</li>
</ul>
<blockquote>
<p>  解决办法：改造文法和EBNF</p>
<p>  未发现其他二义性的地方</p>
</blockquote>
<h4 id="2-1-2-左递归"><a href="#2-1-2-左递归" class="headerlink" title="2.1.2 左递归"></a>2.1.2 左递归</h4><p>可以较为容易地判断出：没有直接和间接左递归。</p>
<h4 id="2-1-3-回溯"><a href="#2-1-3-回溯" class="headerlink" title="2.1.3 回溯"></a>2.1.3 回溯</h4><p>通过改造文法（简单的改造，提取公共左因子；但为了直观、更方便处理，有的不改造了）或者  算法处理（if else 进一步判断，判断后回溯，感觉思想类似LL(n)了，事实上就没有消除回溯）</p>
<h4 id="2-1-4-计算FIRST和FOLLOW集"><a href="#2-1-4-计算FIRST和FOLLOW集" class="headerlink" title="2.1.4 计算FIRST和FOLLOW集"></a>2.1.4 计算FIRST和FOLLOW集</h4><blockquote>
<p>  可以用于选择、重复的case判断</p>
</blockquote>
<h4 id="2-1-5-EBNF"><a href="#2-1-5-EBNF" class="headerlink" title="2.1.5 EBNF"></a>2.1.5 EBNF</h4><p>EBNF更适合递归下降分析法</p>
<p>例如：</p>
<p><img src="/2020/07/06/ComplierC0/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%B4%E6%98%8E/image-20200420001326020.png" alt="image-20200420001326020"></p>
<h3 id="2-2-编程思想"><a href="#2-2-编程思想" class="headerlink" title="2.2 编程思想"></a>2.2 编程思想</h3><h4 id="2-2-1-基本方法"><a href="#2-2-1-基本方法" class="headerlink" title="2.2.1 基本方法"></a>2.2.1 基本方法</h4><p><img src="/2020/07/06/ComplierC0/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%B4%E6%98%8E/image-20200419225239669.png" alt="递归下降基本实现方法"></p>
<blockquote>
<p>  case选择不同的，遇到终结符，就match；非终结符就调用函数</p>
</blockquote>
<h4 id="2-2-2-重复和选择：使用EBNF"><a href="#2-2-2-重复和选择：使用EBNF" class="headerlink" title="2.2.2 重复和选择：使用EBNF"></a>2.2.2 重复和选择：使用EBNF</h4><blockquote>
<p>  这里面的判断条件是根据 first集的 或者 空语句的时候，就要follow集</p>
<p>  总之就是一个要求：根据当前token，进入一个确定的分支，没有回溯</p>
</blockquote>
<h5 id="可选结构"><a href="#可选结构" class="headerlink" title="可选结构"></a>可选结构</h5><p><img src="/2020/07/06/ComplierC0/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%B4%E6%98%8E/image-20200419161119250.png" alt="image-20200419161119250"></p>
<h5 id="重复结构"><a href="#重复结构" class="headerlink" title="重复结构"></a>重复结构</h5><p><img src="/2020/07/06/ComplierC0/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%B4%E6%98%8E/image-20200419162417555.png" alt="image-20200419162417555"></p>
<p><img src="/2020/07/06/ComplierC0/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%B4%E6%98%8E/image-20200419162522766.png" alt="image-20200419162522766"></p>
<p><img src="/2020/07/06/ComplierC0/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%B4%E6%98%8E/image-20200419162535166.png" alt="image-20200419162535166"></p>
<h3 id="2-3-数据结构"><a href="#2-3-数据结构" class="headerlink" title="2.3 数据结构"></a>2.3 数据结构</h3><h4 id="2-3-1-AST"><a href="#2-3-1-AST" class="headerlink" title="2.3.1 AST"></a>2.3.1 AST</h4><p>未打算使用抽象语法树，因为发现可以不使用抽象语法树，直接转IR（三地址码等），可能建立起来还会多此一举；而且考虑到未发现统一的语法树结构定义，而且文法不同，也要做出改变。</p>
<p>但可能不直观，不知道分析结果。所以调试代码的时候，只能写一部分代码，然后进行针对性的单元测试。</p>
<h4 id="2-3-2-回溯指针"><a href="#2-3-2-回溯指针" class="headerlink" title="2.3.2 回溯指针"></a>2.3.2 回溯指针</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> flashBackIndex;</span><br></pre></td></tr></table></figure>
<h3 id="2-4-关键函数"><a href="#2-4-关键函数" class="headerlink" title="2.4 关键函数"></a>2.4 关键函数</h3><h4 id="2-4-1-匹配终结符函数"><a href="#2-4-1-匹配终结符函数" class="headerlink" title="2.4.1 匹配终结符函数"></a>2.4.1 匹配终结符函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 匹配 期待的 token；否则报错</span></span><br><span class="line"><span class="comment">// 读取下一个token</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">match</span><span class="params">(TokenType expectToken)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="2-4-2-非终结符过程"><a href="#2-4-2-非终结符过程" class="headerlink" title="2.4.2 非终结符过程"></a>2.4.2 非终结符过程</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//为每一个非终结符创建一个函数</span></span><br><span class="line"><span class="function">TreeNode* <span class="title">program</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode* <span class="title">constDeclaration</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">TreeNode* <span class="title">constDefine</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">TreeNode* <span class="title">varDeclaration</span><span class="params">()</span></span>;</span><br><span class="line">TreeNode* __varDeclaration();</span><br><span class="line"><span class="function">TreeNode* <span class="title">varDefine</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">Type <span class="title">typeID</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">TreeNode* <span class="title">functionDefinitionWithReturn</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">TreeNode* <span class="title">DeclarationHead</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">TreeNode* <span class="title">functionDefinitionWithoutReturn</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">paraTable</span><span class="params">(FuncInfo * finfo)</span></span>;</span><br><span class="line"><span class="function">TreeNode* <span class="title">complexStatement</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">TreeNode* <span class="title">mainFunction</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode* <span class="title">signedNum</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode* <span class="title">statementSequence</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">TreeNode* <span class="title">statement</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">TreeNode* <span class="title">assignStatement</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">TreeNode* <span class="title">ifStatement</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">TreeNode* <span class="title">whileLoopStatement</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">TreeNode* <span class="title">forLoopStatement</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">TreeNode* <span class="title">callWithReturn</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">TreeNode* <span class="title">callWithoutReturn</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">TreeNode* <span class="title">valueParaTable</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">TreeNode* <span class="title">scanfStatement</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">TreeNode* <span class="title">printfStatement</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">TreeNode* <span class="title">returnStatement</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode* <span class="title">exp</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">TreeNode* <span class="title">term</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">TreeNode* <span class="title">factor</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">TreeNode* <span class="title">boolExp</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">TreeNode* <span class="title">boolTerm</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">TreeNode* <span class="title">boolFactor</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">TreeNode* <span class="title">conditionFactor</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="2-5-注意问题"><a href="#2-5-注意问题" class="headerlink" title="2.5 注意问题"></a>2.5 注意问题</h3><h4 id="2-5-1、公共因子"><a href="#2-5-1、公共因子" class="headerlink" title="2.5.1、公共因子"></a>2.5.1、公共因子</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">13.&lt;程序&gt; ::= ［&lt;常量说明&gt;］［&lt;变量说明&gt;］&#123;&lt;有返回值函数定义&gt;|&lt;无返回值函数定义&gt;&#125;&lt;主函数&gt;</span><br></pre></td></tr></table></figure>
<p>这一部分为了 文法上的简便，没有进行公共因子的提取；</p>
<p>选择类似LL(n)的方法，一次性往后看好多</p>
<p>分三段，设flag</p>
<h4 id="2-5-2、单元测试"><a href="#2-5-2、单元测试" class="headerlink" title="2.5.2、单元测试"></a>2.5.2、单元测试</h4><ul>
<li>常、变量说明</li>
</ul>
<p>类型测试、多条语句测试、是否函数定义测试</p>
<ul>
<li>函数定义（语句列为空）</li>
</ul>
<p>函数定义选择测试、结构测试、参数表、复合语句测试（实际上空语句）</p>
<ul>
<li>语句列、语句</li>
<li>表达式：算术、布尔</li>
</ul>
<h4 id="2-5-3、错误处理"><a href="#2-5-3、错误处理" class="headerlink" title="2.5.3、错误处理"></a>2.5.3、错误处理</h4><p><img src="/2020/07/06/ComplierC0/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%B4%E6%98%8E/image-20200421011557996.png" alt="image-20200421011557996"></p>
<p>发现：</p>
<p>要是少了一些token，继续往下匹配，还能成功继续；（token不动，分析继续）</p>
<p>但是有时候，比如int写成in，有时候死活下不去</p>
<h3 id="2-6-抽象语法树AST"><a href="#2-6-抽象语法树AST" class="headerlink" title="2.6 抽象语法树AST"></a>2.6 抽象语法树AST</h3><blockquote>
<p>  因为一开始没有这个打算，这是临时加的，所以放到最后了。</p>
</blockquote>
<h4 id="2-6-1-设计抽象语法树"><a href="#2-6-1-设计抽象语法树" class="headerlink" title="2.6.1 设计抽象语法树"></a>2.6.1 设计抽象语法树</h4><p>先根据 语法定义手动画出预期抽象语法树；</p>
<blockquote>
<p>  高清图可查看svg</p>
</blockquote>
<p><img src="/2020/07/06/ComplierC0/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%B4%E6%98%8E/image-20200429162352589.png" alt="image-20200429162352589"></p>
<p>语句：</p>
<p><img src="/2020/07/06/ComplierC0/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%B4%E6%98%8E/image-20200429162421569.png" alt="image-20200429162421569"></p>
<p>表达式</p>
<p><img src="/2020/07/06/ComplierC0/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%B4%E6%98%8E/image-20200429162432363.png" alt="image-20200429162432363"></p>
<p>布尔表达式</p>
<p><img src="/2020/07/06/ComplierC0/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%B4%E6%98%8E/image-20200429162443694.png" alt="image-20200429162443694"></p>
<h4 id="2-6-2-数据结构"><a href="#2-6-2-数据结构" class="headerlink" title="2.6.2 数据结构"></a>2.6.2 数据结构</h4><p>然后结合图和文法，设计数据结构；</p>
<p>大体说明：总的有四种类型：DecK, StmtK, ExpK, BoolExpK（NodeKind nodekind; 字段保存）</p>
<p>具体类型：union确定</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_TREENODE_CHILD_NUM  3                       <span class="comment">// 最大孩子节点数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_PARAMETERE_NUM      8                       <span class="comment">// 最大参数个数</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;</span><br><span class="line">    DecK, StmtK, ExpK, BoolExpK                         <span class="comment">//声明，语句，表达式，布尔表达式</span></span><br><span class="line">&#125;NodeKind;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;</span><br><span class="line">    Const_DecK, Var_DecK, Func_DecK, MainFunc_DecK,         <span class="comment">//常量说明，变量说明， 非主函数说明， 主函数说明</span></span><br><span class="line">    Const_DefK, Var_DefK                                    <span class="comment">//常量定义，变量定义</span></span><br><span class="line">&#125;DecKind;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;</span><br><span class="line">    If_StmtK, While_StmtK, For_StmtK, Assign_StmtK,         <span class="comment">//条件， 循环， 赋值 语句</span></span><br><span class="line">    Call_StmtK, Seq_StmtK, Read_StmtK, Write_StmtK,         <span class="comment">//调用， 语句列， 读，写语句</span></span><br><span class="line">    Ret_StmtK,                                              <span class="comment">//返回语句</span></span><br><span class="line">    <span class="comment">// 为了便于遍历AST， 增加节点类型：即语句每个成分都有一个类型</span></span><br><span class="line">    Write_StmtK_Str,</span><br><span class="line">    Read_StmtK_Idlist</span><br><span class="line">&#125;StmtKind;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;</span><br><span class="line">    Op_ExpK, Num_ExpK, Iden_ExpK                           <span class="comment">//操作类型 ， 数字（字母常量按数字保存）， 标识符</span></span><br><span class="line">&#125;ExpKind;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;</span><br><span class="line">    Op_BoolEK,                                              <span class="comment">//布尔表达式操作：与或非； </span></span><br><span class="line">    Const_BoolEK, ConOp_BoolEK                              <span class="comment">//布尔常量， 条件运算符</span></span><br><span class="line">    <span class="comment">//ConFac_BoolEK                                           // 条件因子， 其实就是简化了一点的表达式</span></span><br><span class="line">    <span class="comment">// 条件因子 用的是表达式节点，与表达式构造方法相同， 但是在另一个过程里实现（语法定义中不是表达式，但实际是）</span></span><br><span class="line">&#125;BoolExpKind;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型信息： 可以是定义时 保存的类型信息；也可以用于 检验表达式中类型是否匹配</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;</span><br><span class="line">    T_VOID, T_INTEGER, T_CHAR</span><br><span class="line">&#125;Type;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数信息：返回类型和参数表；也可以链接到符号表中</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    Type rettype;</span><br><span class="line">    <span class="keyword">struct</span> &#123;</span><br><span class="line">        Type ptype;</span><br><span class="line">        <span class="type">char</span>* pname;</span><br><span class="line">    &#125;paratable[MAX_PARAMETERE_NUM];</span><br><span class="line">    <span class="type">int</span> paranum;</span><br><span class="line">&#125;FuncInfo;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AST 的节点：左孩子右兄弟的树形结构；但表达式部分 又是二叉树结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">TreeNode</span>* child[MAX_TREENODE_CHILD_NUM];     <span class="comment">// 左孩子，最多三个，通常只有一个，特定语句有多个</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">TreeNode</span>* sibling;                           <span class="comment">// 右兄弟</span></span><br><span class="line">    <span class="type">int</span> lineno;                                     <span class="comment">// 错误报告行号</span></span><br><span class="line">    </span><br><span class="line">    NodeKind nodekind;                              <span class="comment">// 节点类型</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        DecKind dec;</span><br><span class="line">        StmtKind stmt;</span><br><span class="line">        ExpKind exp;</span><br><span class="line">        BoolExpKind bexp;</span><br><span class="line">    &#125;kind;                                          <span class="comment">// 节点具体类型</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        TokenType op;                                   <span class="comment">// 操作类型：通常是表达式中</span></span><br><span class="line">        <span class="type">int</span> val;                                        <span class="comment">// NUM的值</span></span><br><span class="line">        <span class="type">char</span> cval;                                      <span class="comment">// Char 型 值</span></span><br><span class="line">        <span class="type">char</span>* name;                                     <span class="comment">// Id 的值，也可以是函数名，Str的值</span></span><br><span class="line">        <span class="type">bool</span> bval;                                      <span class="comment">// bool 常量</span></span><br><span class="line">        <span class="type">char</span>* str;                                      <span class="comment">// String 类型</span></span><br><span class="line">    &#125;attr;                                          <span class="comment">// 节点属性</span></span><br><span class="line">    <span class="type">int</span> vec;                                        <span class="comment">// 变量定义阶段设置：数组长度，不是数组就是-1 ； </span></span><br><span class="line">    Type type;                                      <span class="comment">// 常、变量定义 ，类型说明 和 表达式类型检查</span></span><br><span class="line">                                                    <span class="comment">// 函数信息：返回类型和参数表；也可以链接到符号表中</span></span><br><span class="line">    FuncInfo* pfinfo;                               <span class="comment">// 函数定义阶段设置：函数信息； 或者是函数调用阶段的参数表</span></span><br><span class="line"></span><br><span class="line">&#125;TreeNode;</span><br></pre></td></tr></table></figure>
<p>之后再验证数据结构</p>
<h4 id="2-6-3-编程验证"><a href="#2-6-3-编程验证" class="headerlink" title="2.6.3 编程验证"></a>2.6.3 编程验证</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> AST_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AST_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;global.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建声明节点：包括常量、变量、函数等等说明定义，传入具体声明类型，返回节点指针</span></span><br><span class="line"><span class="function">TreeNode* <span class="title">newDecNode</span><span class="params">(DecKind kind)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建语句节点：传入具体声明类型，返回节点指针</span></span><br><span class="line"><span class="function">TreeNode* <span class="title">newStmtNode</span><span class="params">(StmtKind kind)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建表达式节点：传入具体声明类型，返回节点指针</span></span><br><span class="line"><span class="function">TreeNode* <span class="title">newExpNode</span><span class="params">(ExpKind kind)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建布尔表达式节点：传入具体声明类型，返回节点指针</span></span><br><span class="line"><span class="function">TreeNode* <span class="title">newBoolExpNode</span><span class="params">(BoolExpKind kind)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义函数时，保存函数信息：返回类型和参数表</span></span><br><span class="line"><span class="comment">// FuncInfo* newFuncInfo(Type t);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 拷贝token中的字符串到动态分配的空间</span></span><br><span class="line"><span class="function"><span class="type">char</span>* <span class="title">copyString</span><span class="params">(<span class="type">char</span>* s)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出抽象语法树到文件</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printAST</span><span class="params">(TreeNode* tree)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// !AST_H</span></span></span><br></pre></td></tr></table></figure>
<p>表达式策略：计算时只有三种节点：操作（+-*/数组、call、取负（改为0- term））、数字（字符也当作数字运算）、标识符</p>
<p>如果是赋值会进行截断处理；比较时都是整形</p>
<blockquote>
<p>  终于明白为什么参数个数一致即可；int转char截断即可；char转int扩展；所以只需要记录个数</p>
</blockquote>
<h4 id="2-6-4-输出到文件"><a href="#2-6-4-输出到文件" class="headerlink" title="2.6.4 输出到文件"></a>2.6.4 输出到文件</h4><p>主要工作是遍历AST</p>
<p>主要思想是：（深度优先思想）先遍历所有孩子节点，再遍历兄弟节点。</p>
<blockquote>
<p>  重大bug：不要用return，不然兄弟节点会被跳过；break即可</p>
</blockquote>
<p>例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> gc_a = <span class="number">22</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> gc_b = <span class="number">-22</span>, gc_c = <span class="number">0</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> gc_d = <span class="string">&#x27;z&#x27;</span>, gc_e = <span class="string">&#x27;x&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> g_a, g_b;</span><br><span class="line"><span class="type">char</span> g_c[<span class="number">0</span>], g_d[<span class="number">5</span>];</span><br><span class="line"><span class="type">int</span> g_e;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f_a</span><span class="params">()</span></span>&#123;</span><br><span class="line">	a1 = <span class="number">-5</span> * <span class="built_in">func</span>() * ( a2 + <span class="string">&#x27;5&#x27;</span>) + a3[<span class="number">3</span>] + <span class="number">599</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f_b</span><span class="params">(<span class="type">int</span> a, <span class="type">char</span> b)</span></span>&#123;</span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> a = <span class="number">1</span>, b = <span class="number">2</span>;</span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> c = <span class="number">2</span>;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> d = <span class="string">&#x27;2&#x27;</span>, e = <span class="string">&#x27;3&#x27;</span>;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> f = <span class="string">&#x27;4&#x27;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> g,h;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="type">char</span> j;</span><br><span class="line">	<span class="type">char</span> k,l;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> (a + b);	</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f_c</span><span class="params">(<span class="type">int</span> c, <span class="type">int</span> d)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> c;</span><br><span class="line"></span><br><span class="line">	;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> a = <span class="number">1</span>, b = <span class="number">2</span>;</span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> c = <span class="number">2</span>;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> d = <span class="string">&#x27;2&#x27;</span>, e = <span class="string">&#x27;3&#x27;</span>;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> f = <span class="string">&#x27;4&#x27;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> g,h;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="type">char</span> j[<span class="number">30</span>];</span><br><span class="line">	<span class="type">char</span> k,l;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	k = a_2 * <span class="number">55</span> * ( <span class="number">-1</span> + k[<span class="number">2</span>] + g_a + j - <span class="string">&#x27;g&#x27;</span> ) + <span class="built_in">f_b</span>(dddd, dddd2) + <span class="built_in">f_b</span>() * <span class="built_in">f_c</span>() * <span class="built_in">f_undefine</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">f_un</span>();</span><br><span class="line">	<span class="built_in">f_c</span>(g, h);</span><br><span class="line">	<span class="built_in">f_c</span>(g);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">scanf</span>(a);</span><br><span class="line">	<span class="built_in">scanf</span>(g, h);</span><br><span class="line">	<span class="built_in">scanf</span>(k);</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>( ( <span class="literal">true</span> || <span class="number">8</span> )&amp;&amp; ! <span class="literal">false</span> &amp;&amp; <span class="literal">true</span> || <span class="number">88</span> &lt;= <span class="string">&#x27;8&#x27;</span> &amp;&amp; <span class="built_in">f_b</span>() != <span class="number">22</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;aaaaaa&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">		;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(a=<span class="number">1</span>; a == eee; b=<span class="number">3</span>)</span><br><span class="line">		;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;aaaa11&quot;</span>,a);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;aaaa12221%c&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(acc);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(<span class="literal">false</span>)</span><br><span class="line">	<span class="keyword">if</span>(___true)&#123;</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">------------ Const Declaration ------------</span><br><span class="line"></span><br><span class="line">Type: 1	(VOID,INT,CHAR)	list: </span><br><span class="line">ID name:		gc_a		value:	22</span><br><span class="line">Type: 1	(VOID,INT,CHAR)	list: </span><br><span class="line">ID name:		gc_b		value:	-22</span><br><span class="line">ID name:		gc_c		value:	0</span><br><span class="line">Type: 2	(VOID,INT,CHAR)	list: </span><br><span class="line">ID name:		gc_d		value:	z</span><br><span class="line">ID name:		gc_e		value:	x</span><br><span class="line"></span><br><span class="line">------------ Var Declaration ------------</span><br><span class="line">Type: 1	(VOID,INT,CHAR)	list: </span><br><span class="line">ID name: g_a</span><br><span class="line">ID name: g_b</span><br><span class="line"></span><br><span class="line">Type: 2	(VOID,INT,CHAR)	list: </span><br><span class="line">ID name: g_c</span><br><span class="line">ID name: g_d</span><br><span class="line"></span><br><span class="line">Type: 1	(VOID,INT,CHAR)	list: </span><br><span class="line">ID name: g_e</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Function Declaration &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line"> Function Name: f_a </span><br><span class="line"> Function Info: Return Type(VOID,INT,CHAR):0 </span><br><span class="line">		ParaTable(VOID,INT,CHAR): </span><br><span class="line"></span><br><span class="line">Stmt Sequence&gt;&gt;&gt;   </span><br><span class="line"></span><br><span class="line">Assign to: a1</span><br><span class="line"> 0  -  5  *  func  ()  *  a2  +  53  +  a3  []  3  +  599 </span><br><span class="line">&lt;&lt;&lt;Stmt Sequence End  </span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Function Declaration &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line"> Function Name: f_b </span><br><span class="line"> Function Info: Return Type(VOID,INT,CHAR):1 </span><br><span class="line">		ParaTable(VOID,INT,CHAR): 1 a	1 a	</span><br><span class="line"></span><br><span class="line">------------ Const Declaration ------------</span><br><span class="line"></span><br><span class="line">Type: 1	(VOID,INT,CHAR)	list: </span><br><span class="line">ID name:		a		value:	1</span><br><span class="line">ID name:		b		value:	2</span><br><span class="line">Type: 1	(VOID,INT,CHAR)	list: </span><br><span class="line">ID name:		c		value:	2</span><br><span class="line">Type: 2	(VOID,INT,CHAR)	list: </span><br><span class="line">ID name:		d		value:	2</span><br><span class="line">ID name:		e		value:	3</span><br><span class="line">Type: 2	(VOID,INT,CHAR)	list: </span><br><span class="line">ID name:		f		value:	4</span><br><span class="line"></span><br><span class="line">------------ Var Declaration ------------</span><br><span class="line">Type: 1	(VOID,INT,CHAR)	list: </span><br><span class="line">ID name: g</span><br><span class="line">ID name: h</span><br><span class="line"></span><br><span class="line">Type: 1	(VOID,INT,CHAR)	list: </span><br><span class="line">ID name: i</span><br><span class="line"></span><br><span class="line">Type: 2	(VOID,INT,CHAR)	list: </span><br><span class="line">ID name: j</span><br><span class="line"></span><br><span class="line">Type: 2	(VOID,INT,CHAR)	list: </span><br><span class="line">ID name: k</span><br><span class="line">ID name: l</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Stmt Sequence&gt;&gt;&gt;   </span><br><span class="line"></span><br><span class="line">Ret Stmt:</span><br><span class="line"> a  +  b </span><br><span class="line">&lt;&lt;&lt;Stmt Sequence End  </span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Function Declaration &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line"> Function Name: f_c </span><br><span class="line"> Function Info: Return Type(VOID,INT,CHAR):0 </span><br><span class="line">		ParaTable(VOID,INT,CHAR): 1 c	1 c	</span><br><span class="line"></span><br><span class="line">------------ Var Declaration ------------</span><br><span class="line">Type: 1	(VOID,INT,CHAR)	list: </span><br><span class="line">ID name: c</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Stmt Sequence&gt;&gt;&gt;   </span><br><span class="line"></span><br><span class="line">&lt;&lt;&lt;Stmt Sequence End  </span><br><span class="line"></span><br><span class="line">***************************************************</span><br><span class="line">************ Main Function Declaration ************</span><br><span class="line">***************************************************</span><br><span class="line"></span><br><span class="line">------------ Const Declaration ------------</span><br><span class="line"></span><br><span class="line">Type: 1	(VOID,INT,CHAR)	list: </span><br><span class="line">ID name:		a		value:	1</span><br><span class="line">ID name:		b		value:	2</span><br><span class="line">Type: 1	(VOID,INT,CHAR)	list: </span><br><span class="line">ID name:		c		value:	2</span><br><span class="line">Type: 2	(VOID,INT,CHAR)	list: </span><br><span class="line">ID name:		d		value:	2</span><br><span class="line">ID name:		e		value:	3</span><br><span class="line">Type: 2	(VOID,INT,CHAR)	list: </span><br><span class="line">ID name:		f		value:	4</span><br><span class="line"></span><br><span class="line">------------ Var Declaration ------------</span><br><span class="line">Type: 1	(VOID,INT,CHAR)	list: </span><br><span class="line">ID name: g</span><br><span class="line">ID name: h</span><br><span class="line"></span><br><span class="line">Type: 1	(VOID,INT,CHAR)	list: </span><br><span class="line">ID name: i</span><br><span class="line"></span><br><span class="line">Type: 2	(VOID,INT,CHAR)	list: </span><br><span class="line">ID name: j</span><br><span class="line"></span><br><span class="line">Type: 2	(VOID,INT,CHAR)	list: </span><br><span class="line">ID name: k</span><br><span class="line">ID name: l</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Stmt Sequence&gt;&gt;&gt;   </span><br><span class="line"></span><br><span class="line">Assign to: k</span><br><span class="line"> a_2  *  55  *  0  -  1  +  k  []  2  +  g_a  +  j  -  103  +  f_b  ()  dddd  +  f_b  ()  *  f_c  ()  *  f_undefine  () </span><br><span class="line">Call Stmt:  Function: f_un </span><br><span class="line">Paras: </span><br><span class="line"></span><br><span class="line">Call Stmt:  Function: f_c </span><br><span class="line">Paras:  g  h </span><br><span class="line"></span><br><span class="line">Call Stmt:  Function: f_c </span><br><span class="line">Paras:  g </span><br><span class="line"></span><br><span class="line">Read Stmt:</span><br><span class="line">Read ID: a</span><br><span class="line"></span><br><span class="line">Read Stmt:</span><br><span class="line">Read ID: g</span><br><span class="line">Read ID: h</span><br><span class="line"></span><br><span class="line">Read Stmt:</span><br><span class="line">Read ID: k</span><br><span class="line"></span><br><span class="line">If :</span><br><span class="line"> ||  &amp;&amp;  &amp;&amp;  ||  bool(1)  8  ||  bool(0)  bool(1)  &amp;&amp;  &lt;=  88  56  !=  f_b  ()  22 </span><br><span class="line">Stmt Sequence&gt;&gt;&gt;   </span><br><span class="line"></span><br><span class="line">Write Stmt:</span><br><span class="line">Write Str: aaaaaa</span><br><span class="line"></span><br><span class="line">&lt;&lt;&lt;Stmt Sequence End  </span><br><span class="line"></span><br><span class="line">While Stmt:</span><br><span class="line"> bool(1) </span><br><span class="line">Stmt Sequence&gt;&gt;&gt;   </span><br><span class="line"></span><br><span class="line">&lt;&lt;&lt;Stmt Sequence End  </span><br><span class="line"></span><br><span class="line">For Stmt:</span><br><span class="line"></span><br><span class="line">Assign to: a</span><br><span class="line"> 1  ==  a  eee </span><br><span class="line">Assign to: b</span><br><span class="line"> 3 </span><br><span class="line">Write Stmt:</span><br><span class="line">Write Str: aaaa11</span><br><span class="line"> a </span><br><span class="line">Write Stmt:</span><br><span class="line">Write Str: aaaa12221%c</span><br><span class="line"></span><br><span class="line">Write Stmt:</span><br><span class="line"> acc </span><br><span class="line">If :</span><br><span class="line"> bool(0) </span><br><span class="line">If :</span><br><span class="line"> ___true </span><br><span class="line">Stmt Sequence&gt;&gt;&gt;   </span><br><span class="line"></span><br><span class="line">&lt;&lt;&lt;Stmt Sequence End  </span><br><span class="line"></span><br><span class="line">Stmt Sequence&gt;&gt;&gt;   </span><br><span class="line">&lt;&lt;&lt;Stmt Sequence End  </span><br><span class="line">Ret Stmt:</span><br><span class="line"></span><br><span class="line">&lt;&lt;&lt;Stmt Sequence End  </span><br></pre></td></tr></table></figure>
<h2 id="三、语义分析"><a href="#三、语义分析" class="headerlink" title="三、语义分析"></a>三、语义分析</h2><blockquote>
<p>  一遍的编译器中，词法分析、语法分析、语义分析是同时进行的</p>
<p>  我的顺序：在生成抽象语法树之后，再遍历抽象语法树，构建符号表，进行语义分析（事实上技术上的难度没什么差别，都很简单，做的事情基本一样）</p>
</blockquote>
<p>语义分析包括构造符号表、记录声明中建立的名字的含义、在表达式和语句中进行类型推断和类型检查以及在语言的类型规则作用域内判断它们的正确性。</p>
<p>语义分析阶段的一个主要工作是符号表的管理，其作用是将标识符映射到它们的类型和储存位置。</p>
<h3 id="3-1-符号表"><a href="#3-1-符号表" class="headerlink" title="3.1 符号表"></a>3.1 符号表</h3><h4 id="3-1-1-符号表结构"><a href="#3-1-1-符号表结构" class="headerlink" title="3.1.1 符号表结构"></a>3.1.1 符号表结构</h4><p>符号表的结构选择：分级hash链表；</p>
<p>分级表示不同作用域；当有同名标识符时，选择作用域最近的；以链表的方式解决冲突问题</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SYMBOL_TABLE_SIZE 211</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> <span class="title class_">IDType</span> &#123;</span><br><span class="line">    Const_ID, Var_ID, Para_ID, Func_ID</span><br><span class="line">&#125;IDType;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 符号表中的每一项</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Symbol</span> &#123;</span><br><span class="line">    <span class="type">char</span>* name;					<span class="comment">// 标识符名字</span></span><br><span class="line">    IDType type;				<span class="comment">// ID类型： const，var，para，function</span></span><br><span class="line">    Type valueType;				<span class="comment">// ID的类型值：常变量的类型、参数类型、函数返回类型</span></span><br><span class="line">    <span class="type">int</span> value;					<span class="comment">// 常量定义值						只有常数定义才会传入</span></span><br><span class="line">    <span class="type">int</span> adress;					<span class="comment">// 内存地址</span></span><br><span class="line">    <span class="type">int</span> vec;					<span class="comment">// 数组大小，不是数组为-1；			只有定义数组时，才会传入</span></span><br><span class="line">    FuncInfo* pfinfo;			<span class="comment">// 函数信息，AST中已有，拷贝即可；  只有函数定义是，才会传进，否则NULL</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Symbol</span>* next;		<span class="comment">// 有相同hash值时，下一条</span></span><br><span class="line">&#125;Symbol, * SymbolList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">SymTab</span> &#123;</span><br><span class="line">    SymTab* next;				<span class="comment">// 多张表；指向下一张表</span></span><br><span class="line">    <span class="type">char</span>* fname;</span><br><span class="line">    SymbolList hashTable[SYMBOL_TABLE_SIZE];</span><br><span class="line">&#125;SymTab;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>  此处有些设计不好，枚举类型和成员名字容易混淆</p>
</blockquote>
<p>一张全局表，每个函数对应一张符号子表</p>
<p>形式如下：</p>
<p><img src="/2020/07/06/ComplierC0/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%B4%E6%98%8E/image-20200428011237770.png" alt="符号表结构"></p>
<h4 id="3-1-2-相关操作"><a href="#3-1-2-相关操作" class="headerlink" title="3.1.2 相关操作"></a>3.1.2 相关操作</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化一张 单表；每个函数一张表、全局一张表</span></span><br><span class="line"><span class="function">SymTab* <span class="title">initSimpleSymTable</span><span class="params">(<span class="type">char</span>* name)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回是否插入成功，如空间不足、重复定义 ； 后面并没有用到返回值，内部直接错误处理</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">insert_SymTab</span><span class="params">(<span class="type">bool</span> isGlobal, <span class="type">char</span>* name, IDType type, Type valuetype, <span class="type">int</span> value, <span class="type">int</span> vec = <span class="number">-1</span>, FuncInfo* p = <span class="literal">NULL</span>)</span></span>;</span><br><span class="line"><span class="comment">// value字段，只有常量定义才会赋初值</span></span><br><span class="line"><span class="comment">// adress字段由文件内部静态变量控制，一旦重新函数定义，指针变0，重新计算相对地址</span></span><br><span class="line"><span class="comment">// 数组标志默认-1；只有数组(变量定义)定义时才会是 其他值</span></span><br><span class="line"><span class="comment">// 函数信息默认为空，只有函数定义时，才会赋值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回符号节点指针、未定义返回空指针；</span></span><br><span class="line"><span class="function">Symbol* <span class="title">lookUp_SymTab</span><span class="params">(<span class="type">char</span>* name)</span></span>;</span><br><span class="line"><span class="comment">// 遵循原则：先查子表，再差全局表（作用域最近的）</span></span><br></pre></td></tr></table></figure>
<p>全局常、变量定义，函数定义将会放到全局表中；参数、局部变量放在函数表中</p>
<p>根据 <code>isGlobal</code>标志 确定插入全局表还是 函数表</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> g_adress = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> f_adress = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>还设置了两个静态变量来保存全局表和函数表的标识符地址</p>
<p>关于同名函数：不允许</p>
<h3 id="3-2-语义分析程序"><a href="#3-2-语义分析程序" class="headerlink" title="3.2 语义分析程序"></a>3.2 语义分析程序</h3><h4 id="3-2-1-符号表建立阶段"><a href="#3-2-1-符号表建立阶段" class="headerlink" title="3.2.1 符号表建立阶段"></a>3.2.1 符号表建立阶段</h4><p>要将声明的标识符插入到符号表，包括四种类型：常量、变量、参数、函数定义</p>
<p>插入的位置分为：全局表还是函数表</p>
<blockquote>
<p>  常量变量：建立isGlobal标记，只有最开始声明时，会是true；一旦开始函数定义，变成false，只能进入函数表</p>
<p>  参数：统一false，进入函数表</p>
<p>  函数定义：进入全局表，true（main函数也进去，可以递归main函数），函数不允许同名</p>
</blockquote>
<p>可能报的错误：（输出显示）</p>
<p>内存不足</p>
<p>变量、函数重复定义</p>
<p><img src="/2020/07/06/ComplierC0/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%B4%E6%98%8E/image-20200428012623346.png" alt="测试用例"></p>
<h4 id="3-2-2-语义检查"><a href="#3-2-2-语义检查" class="headerlink" title="3.2.2 语义检查"></a>3.2.2 语义检查</h4><p>遵循原则：先查子表，再差全局表（作用域最近的）</p>
<h5 id="可能出现的问题和优化："><a href="#可能出现的问题和优化：" class="headerlink" title="可能出现的问题和优化："></a>可能出现的问题和优化：</h5><hr>
<p>表达式中：</p>
<blockquote>
<p>  表达式中有几种节点：常量、标识符（函数调用看作Op）、Op（+-*/ 、Call、[]）</p>
</blockquote>
<ul>
<li>标识符：未定义就使用，是数组不进行下标运算</li>
<li>CallOp：函数未定义使用，不是有返回值调用，参数个是否匹配</li>
<li>数组Op：不是数组，进行下标运算；</li>
</ul>
<blockquote>
<p>  运算符两侧操作数是否合法，比如int和bool类型相加，由于只有char和int，暂不考虑</p>
</blockquote>
<hr>
<p>语句中：</p>
<ul>
<li>赋值语句：检查是否变量（常量不能赋值）、不是数组进行下标运算、是数组不进行下标运算、标识符未定义就使用</li>
<li>函数调用语句：标识符未定义、是否是函数、参数是否匹配、</li>
<li>读语句：标识符未定义、不能是常量</li>
<li>写语句：占用符与表达式不匹配（是否有）</li>
</ul>
<ul>
<li><p>赋值语句左侧类型确定（优化AST：保存在语句节点Type字段）</p>
</li>
<li><p>函数调用语句：参数类型优化（保存在参数表达式节点Type字段）</p>
</li>
<li><p>Write语句中：占用符类型检查（优化AST：保存在语句节点Type字段）</p>
</li>
</ul>
<blockquote>
<p>  表达式都看作是int型运算，只有语句中需要时根据左值类型进行转换</p>
</blockquote>
<hr>
<p><img src="/2020/07/06/ComplierC0/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%B4%E6%98%8E/image-20200429013114572.png" alt="测试结果"></p>
<blockquote>
<p>  以上全部测试完成</p>
</blockquote>
<h2 id="四、中间代码生成"><a href="#四、中间代码生成" class="headerlink" title="四、中间代码生成"></a>四、中间代码生成</h2><blockquote>
<p>  一些想法：对于生成AST：</p>
<p>  麻烦：增加了工作量。原本可以在语法分析的同一位置进行语义分析（建立符号表、进行语义检查），然后可以在同位置生成中间代码；生成AST的话：需要先设计、建立AST，然后验证，还有输出验证；之后是语义分析，这个方面没什么差别，就是原本是一遍分析了，现在是需要两遍；最后再遍历AST生成中间代码。并且由于考虑不周（事先对知识缺失、不了解，下一阶段的输出不确定），以及AST结构不相对统一；导致后面遍历的时候（输出AST、语义分析、生成中间代码）都需要写遍历的方法（但后面差别不大；主要是，要是早知道，就可以统一写一个方法了）。</p>
<p>  好处：利于优化（DAG什么的，未验证），结构性强，不会把代码全都堆在语法分析内部了。</p>
</blockquote>
<p>分为三个层次：声明、语句、表达式</p>
<p>声明：较为简单，不多说；</p>
<p>语句：主要是个别语句、单独处理即可；没有大问题</p>
<p>表达式：布尔表达式要考虑较多，还没有细致想法。算术表达式基本思想：运算全都是整形，只有赋值、函数调用、写、返回语句用到它的值的时候进行处理</p>
<p>这样会导致两个问题：有int和char，就需要有扩展和截断两个操作。表达式中统一扩展，包括标识符和常量；语句中才有截断。这样就要确定左值类型；（语义分析时优化）</p>
<h3 id="4-1-表达式的翻译："><a href="#4-1-表达式的翻译：" class="headerlink" title="4.1 表达式的翻译："></a>4.1 表达式的翻译：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_QUADVAR_NUM 1000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="type">char</span> op[<span class="number">15</span>];</span><br><span class="line">    <span class="type">char</span>* var1;</span><br><span class="line">    <span class="type">char</span>* var2;</span><br><span class="line">    <span class="type">char</span>* var3;</span><br><span class="line">&#125;Quadvar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> Quadvar quadvarlist[MAX_QUADVAR_NUM];</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> NXQ;</span><br></pre></td></tr></table></figure>
<h3 id="4-2-四元式"><a href="#4-2-四元式" class="headerlink" title="4.2 四元式"></a>4.2 四元式</h3><div class="table-container">
<table>
<thead>
<tr>
<th>op</th>
<th>var1</th>
<th style="text-align:left">var2</th>
<th>var3</th>
</tr>
</thead>
<tbody>
<tr>
<td>+-*/</td>
<td>id/num</td>
<td style="text-align:left">id/num</td>
<td>result</td>
</tr>
<tr>
<td>callret</td>
<td>id（函数名）</td>
<td style="text-align:left"></td>
<td>id(ret)</td>
</tr>
<tr>
<td>getarray</td>
<td>id（数组名）</td>
<td style="text-align:left">id/num（index）</td>
<td>id</td>
</tr>
<tr>
<td>jop</td>
<td>id</td>
<td style="text-align:left">id</td>
<td>label</td>
</tr>
<tr>
<td>j</td>
<td></td>
<td style="text-align:left"></td>
<td>label</td>
</tr>
<tr>
<td>jnz</td>
<td>id/num</td>
<td style="text-align:left"></td>
<td>label</td>
</tr>
<tr>
<td>const</td>
<td>int/char</td>
<td style="text-align:left">val</td>
<td>name</td>
</tr>
<tr>
<td>int/char</td>
<td></td>
<td style="text-align:left"></td>
<td>name</td>
</tr>
<tr>
<td>intarray</td>
<td>size</td>
<td style="text-align:left"></td>
<td>name</td>
</tr>
<tr>
<td>chararray</td>
<td>size</td>
<td style="text-align:left"></td>
<td>name</td>
</tr>
<tr>
<td>Func</td>
<td>int/char/void</td>
<td style="text-align:left"></td>
<td>name</td>
</tr>
<tr>
<td>para</td>
<td>int/char</td>
<td style="text-align:left"></td>
<td>name</td>
</tr>
<tr>
<td>Main</td>
<td></td>
<td style="text-align:left"></td>
<td></td>
</tr>
<tr>
<td>setarray</td>
<td>id/num</td>
<td style="text-align:left">index</td>
<td>name</td>
</tr>
<tr>
<td>assign</td>
<td>id/num</td>
<td style="text-align:left"></td>
<td>name</td>
</tr>
<tr>
<td>lab</td>
<td></td>
<td style="text-align:left"></td>
<td>label</td>
</tr>
<tr>
<td>call</td>
<td>name</td>
<td style="text-align:left"></td>
<td></td>
</tr>
<tr>
<td>vpara</td>
<td></td>
<td style="text-align:left"></td>
<td>id/num</td>
</tr>
<tr>
<td>scanf</td>
<td></td>
<td style="text-align:left"></td>
<td>name</td>
</tr>
<tr>
<td>print</td>
<td>str_index</td>
<td style="text-align:left"></td>
<td></td>
</tr>
<tr>
<td>print</td>
<td></td>
<td style="text-align:left">id/num</td>
<td>int/char</td>
</tr>
<tr>
<td>ret</td>
<td></td>
<td style="text-align:left"></td>
<td>id/num</td>
</tr>
<tr>
<td>ret</td>
<td></td>
<td style="text-align:left"></td>
<td></td>
</tr>
<tr>
<td>endf</td>
<td></td>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
</div>
<h2 id="五、目标代码生成"><a href="#五、目标代码生成" class="headerlink" title="五、目标代码生成"></a>五、目标代码生成</h2><h3 id="5-0-理论基础"><a href="#5-0-理论基础" class="headerlink" title="5.0 理论基础"></a>5.0 理论基础</h3><blockquote>
<p>  <a target="_blank" rel="noopener" href="https://firmianay.gitbooks.io/ctf-all-in-one/doc/1.5.2_assembly.html#36-mips%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80">https://firmianay.gitbooks.io/ctf-all-in-one/doc/1.5.2_assembly.html#36-mips%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80</a></p>
<p>  <a target="_blank" rel="noopener" href="https://www.cnblogs.com/thoupin/p/4018455.html">https://www.cnblogs.com/thoupin/p/4018455.html</a></p>
</blockquote>
<p>两种格式用于寻址：</p>
<ul>
<li>使用寄存器号码，例如 <code>$ 0</code> 到 <code>$ 31</code></li>
<li><p>使用别名，例如 <code>$ t1</code>，<code>$ sp</code></p>
</li>
<li><p>特殊寄存器 Lo 和 Hi 用于存储乘法和除法的结果</p>
</li>
<li><p>不能直接寻址; 使用特殊指令 <code>mfhi</code>（ “ 从 Hi 移动 ” ）和 <code>mflo</code>（ “ 从 Lo 移动 ” ）访问的内容</p>
</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>寄存器</th>
<th>别名</th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>$0</code></td>
<td><code>$zero</code></td>
<td>常量0(constant value 0)</td>
</tr>
<tr>
<td><code>$1</code></td>
<td><code>$at</code></td>
<td>保留给汇编器(Reserved for assembler)</td>
</tr>
<tr>
<td><code>$2-$3</code></td>
<td><code>$v0-$v1</code></td>
<td>函数调用返回值(values for results and expression evaluation)</td>
</tr>
<tr>
<td><code>$4-$7</code></td>
<td><code>$a0-$a3</code></td>
<td>函数调用参数(arguments)</td>
</tr>
<tr>
<td><code>$8-$15</code></td>
<td><code>$t0-$t7</code></td>
<td>暂时的(或随便用的)</td>
</tr>
<tr>
<td><code>$16-$23</code></td>
<td><code>$s0-$s7</code></td>
<td>保存的(或如果用，需要SAVE/RESTORE的)(saved)</td>
</tr>
<tr>
<td><code>$24-$25</code></td>
<td><code>$t8-$t9</code></td>
<td>暂时的(或随便用的)</td>
</tr>
<tr>
<td><code>$26~$27</code></td>
<td><code>$k0~$k1</code></td>
<td>保留供中断/陷阱处理程序使用</td>
</tr>
<tr>
<td><code>$28</code></td>
<td><code>$gp</code></td>
<td>全局指针(Global Pointer)</td>
</tr>
<tr>
<td><code>$29</code></td>
<td><code>$sp</code></td>
<td>堆栈指针(Stack Pointer)</td>
</tr>
<tr>
<td><code>$30</code></td>
<td><code>$fp</code></td>
<td>帧指针(Frame Pointer)</td>
</tr>
<tr>
<td><code>$31</code></td>
<td><code>$ra</code></td>
<td>返回地址(return address)</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>  MIPS编程入门（妈妈说标题要高大上，才会有人看&gt;_&lt;！）<a target="_blank" rel="noopener" href="https://www.cnblogs.com/thoupin/p/4018455.html">https://www.cnblogs.com/thoupin/p/4018455.html</a></p>
</blockquote>
<p><img src="/2020/07/06/ComplierC0/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%B4%E6%98%8E/image-20200514184733334.png" alt="数据分配参考"></p>
<h3 id="5-1-寄存器分配思路"><a href="#5-1-寄存器分配思路" class="headerlink" title="5.1 寄存器分配思路"></a>5.1 寄存器分配思路</h3><h4 id="1、一种较为简单的思路：（无寄存器分配）"><a href="#1、一种较为简单的思路：（无寄存器分配）" class="headerlink" title="1、一种较为简单的思路：（无寄存器分配）"></a>1、一种较为简单的思路：（无寄存器分配）</h4><p>首先处理全局变量：.data段</p>
<p>之后就是处理函数：.text段，处理<code>$fp,$sp,$ra</code>,局部变量的分配，临时变量分配（全分配，出现位置var3）；之后开始函数体，主要是一些语句：流程控制（选择、循环），赋值，函数调用（无返回值），读写（syscall）；</p>
<p>返回阶段：寄存器还原、返回值</p>
<blockquote>
<p>  事实上，这里用到的寄存器，除特殊指针外，只有t1，t0；计算出中间变量，立即送入内存（事实上这里并不高效，因为接下来可能会使用，又需要取出，完全是多余的；而且临时变量全部分配空间，内存会浪费）；但这有一个好处，就是处理简单，寄存器中的数据是不需要保存的。（下一步，优化阶段，计划采用一定的寄存器分配策略，优化时空）</p>
</blockquote>
<p>再一步细化就是表达式的问题，针对算术表达式：+-*/，数组下标，较为简单，取操作数即可，计算完将结果送给内存。函数调用（有返回值）处理完参数之后，直接调用即可，无需考虑寄存器的问题。（但，若后续使用一定的寄存器分配策略就需要保存寄存器状态）。</p>
<h4 id="2、寄存器分配（FIFO）"><a href="#2、寄存器分配（FIFO）" class="headerlink" title="2、寄存器分配（FIFO）"></a>2、寄存器分配（FIFO）</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="type">int</span> regindex;</span><br><span class="line">    <span class="type">char</span>* varname;</span><br><span class="line">&#125;RegInfo;</span><br><span class="line"><span class="comment">// 寄存器与变量的映射队列</span></span><br><span class="line">std::list&lt;RegInfo&gt; regInfoList;</span><br><span class="line"><span class="comment">// 剩余可用reg数量:t0-t9，每次函数调用前，应保存寄存器数据，此时重新赋值10</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> emptyRegNum = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<p>用到三种数据结构：剩余可用reg数量、映射队列、符号表</p>
<p>每次需要用到寄存器时，都调用以下过程；会返回可用的寄存器序号。外界不在乎内部如何实现</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">getRegIndex</span><span class="params">(<span class="type">char</span>* varname)</span></span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>  由于符号表结构（数组只是一项，不能反映每一个元素状态）决定：</p>
<p>  针对全局、局部、临时变量，寄存器中存储的是值</p>
<p>  对于数组：寄存器中存储的是基地址（取值和赋值有临时变量，不影响）</p>
</blockquote>
<p>具体实现思路：</p>
<p>有三种情况：</p>
<p>1、变量已经在寄存器中：只需要查找映射队列，返回所在的寄存器序号，再更新映射队列即可（放到末尾）</p>
<p>2、变量不在寄存器，有空闲的寄存器：符号表isreg标志置为true，空闲寄存器数量-1，映射队列插入新元素</p>
<p>3、变量不在寄存器，无空闲的寄存器：首先（FIFO）将一个寄存器释放，送入内存，isreg标志位改变，映射队列pop；新元素isreg为true，映射队列pushback。</p>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>1、类型转换：</p>
<p>赋值语句：赋值前类型转换</p>
<p>函数调用：在函数体内转换</p>
<p>输入语句：查符号表确定类型，系统调用控制</p>
<p>返回语句：返回前类型转换</p>
<p>2、返回值问题</p>
<p>return语句：只是赋值给$v0，j（这里要检查，是否有返回值和返回数据类型转换）</p>
<p>之后的函数返回的栈的处理都是放在末尾处理；</p>
<p>（这里允许函数定义时有返回值，但没写return语句，这样返回值不确定）</p>
<h3 id="5-3-过程"><a href="#5-3-过程" class="headerlink" title="5.3 过程"></a>5.3 过程</h3><h4 id="1、genasm"><a href="#1、genasm" class="headerlink" title="1、genasm:"></a>1、genasm:</h4><p>updateST:</p>
<p>.data:</p>
<p>.text:</p>
<h4 id="2、Func"><a href="#2、Func" class="headerlink" title="2、Func"></a>2、Func</h4><p>保存返回类型</p>
<p>函数体：栈帧变化、参数类型转换、变量定义（分配空间）</p>
<h4 id="3、逐个分析"><a href="#3、逐个分析" class="headerlink" title="3、逐个分析"></a>3、逐个分析</h4><p>先处理表达式：+-*/， vpara， callret， getarray</p>
<p>函数及调用：包括函数栈帧变化，变量分配空间，参数处理</p>
<p>语句：赋值， 读， 写， 返回语句</p>
<p>最后是布尔表达式：jop, j, jnz, lab</p>
<h3 id="bug"><a href="#bug" class="headerlink" title="bug"></a>bug</h3><p>1、语法树中char的类型改为unsigned char</p>
<h3 id="5-4-测试"><a href="#5-4-测试" class="headerlink" title="5.4 测试"></a>5.4 测试</h3><blockquote>
<p>  按照几大类测试：算术表达式、函数调用、语句、布尔表达式</p>
</blockquote>
<h4 id="Text03：输入输出"><a href="#Text03：输入输出" class="headerlink" title="Text03：输入输出"></a>Text03：输入输出</h4><blockquote>
<p>  输出的地方检查出bug，四元式生成不对，类型不匹配</p>
<p>  .data：分配方式错误</p>
</blockquote>
<h4 id="Text04：赋值语句：整形、字符，语句右边不考虑（由固定函数加载，单独测试）"><a href="#Text04：赋值语句：整形、字符，语句右边不考虑（由固定函数加载，单独测试）" class="headerlink" title="Text04：赋值语句：整形、字符，语句右边不考虑（由固定函数加载，单独测试）"></a>Text04：赋值语句：整形、字符，语句右边不考虑（由固定函数加载，单独测试）</h4><blockquote>
<p>  全局变量：pass</p>
<p>  局部变量：pass</p>
<p>  全局数组：pass</p>
<p>  局部数组：pass</p>
<p>  下标运算：有立即数，变量（这里的变量包含表达式，因为运算结果就是临时变量）</p>
<p>  pass</p>
</blockquote>
<h4 id="Text05：函数调用、返回语句"><a href="#Text05：函数调用、返回语句" class="headerlink" title="Text05：函数调用、返回语句"></a>Text05：函数调用、返回语句</h4><blockquote>
<p>  call：bug：若函数内没有变量只有临时变量，初始地址错误</p>
<p>  callret：pass</p>
<p>  ret：有返回值时要检查类型：有bug，函数类型判断错误</p>
<p>  实参类型检查：pass， 由被调用函数实现</p>
</blockquote>
<p>返回语句这里会有最后一次查错：返回类型检查，有无返回值。（有返回值未写return，返回值不确定）</p>
<blockquote>
<p>  只有void才能写return;</p>
<p>  char会对之后的表达式进行类型转换</p>
<p>  然后跳转</p>
</blockquote>
<h4 id="Text06：算术表达式"><a href="#Text06：算术表达式" class="headerlink" title="Text06：算术表达式"></a>Text06：算术表达式</h4><p>六种操作。pleace字段保存立即数或者变量名（全局、临时、局部）</p>
<blockquote>
<p>  bug：前面没发现，函数类型错误</p>
</blockquote>
<h4 id="Text07：布尔表达式、条件循环"><a href="#Text07：布尔表达式、条件循环" class="headerlink" title="Text07：布尔表达式、条件循环"></a>Text07：布尔表达式、条件循环</h4><p>没什么bug</p>
<h2 id="六、优化"><a href="#六、优化" class="headerlink" title="六、优化"></a>六、优化</h2><h3 id="6-0-基本块划分"><a href="#6-0-基本块划分" class="headerlink" title="6.0 基本块划分"></a>6.0 基本块划分</h3><ul>
<li>程序的第一个四元式</li>
<li>转向语句的目标四元式（即j,jnz,jop的目标）</li>
<li>条件跳转jop的下一条（由于四元式生成过程中下一条总是 j）</li>
</ul>
<p>由于本人程序在生成IR过程中的特殊性，条件跳转的下一条语句总是j，跳转的目标总是label</p>
<p>所以基本块划分方法可以简化为 遇到j和label就是基本块入口</p>
<h3 id="6-1-常量合并"><a href="#6-1-常量合并" class="headerlink" title="6.1 常量合并"></a>6.1 常量合并</h3><p>常量计算改为赋值</p>
<h3 id="6-2-强度削弱"><a href="#6-2-强度削弱" class="headerlink" title="6.2 强度削弱"></a>6.2 强度削弱</h3><p>乘法和除法改为移位</p>
<h3 id="6-3-删除公共子表达式"><a href="#6-3-删除公共子表达式" class="headerlink" title="6.3 删除公共子表达式"></a>6.3 删除公共子表达式</h3><p>检查当前基本块中（+-*/， assign），是否有相同操作，操作数；若相同，则删除重复计算、替换中间变量；</p>
<p>注意检查操作数是否被改变</p>
<h3 id="6-4-寄存器分配"><a href="#6-4-寄存器分配" class="headerlink" title="6.4 寄存器分配"></a>6.4 寄存器分配</h3><h4 id="6-4-1-基本思想："><a href="#6-4-1-基本思想：" class="headerlink" title="6.4.1 基本思想："></a>6.4.1 基本思想：</h4><p>FIFO原则</p>
<h4 id="6-4-2-实现"><a href="#6-4-2-实现" class="headerlink" title="6.4.2 实现"></a>6.4.2 实现</h4><p>寄存器分配器，返回一个可用的寄存器</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">用途：管理寄存器堆。当需要加载操作数时（立即数、变量值、数组基地址），查看是否已在寄存器，或加载到哪个寄存器。</span></span><br><span class="line"><span class="comment">输入：变量名</span></span><br><span class="line"><span class="comment">输出：该变量可以存入的寄存器index，或者是已经存在的寄存器序号, isInReg, isGlobal</span></span><br><span class="line"><span class="comment">首先查找符号表中该变量是否在寄存器中，</span></span><br><span class="line"><span class="comment">	如果在：返回序号，维护寄存器状态列表（对于全局、局部、临时变量都表示值是否在寄存器，数组表示基地址是否在）</span></span><br><span class="line"><span class="comment">	不在：查看是否有空寄存器，若无，FIFO原则维护寄存器堆</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	此外还需维护两个全局变量: 表示是否在寄存器中（用于该函数体外），是否全局变量（.data段全局变量可以通过变量名直接获取、存储）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getRegIndex</span><span class="params">(<span class="type">char</span>* varname)</span></span></span><br></pre></td></tr></table></figure>
<p>之后再调入寄存器</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从内存读入寄存器</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mem2reg</span><span class="params">(<span class="type">char</span>* varname, <span class="type">int</span> reg)</span></span></span><br></pre></td></tr></table></figure>
<h2 id="七、错误处理"><a href="#七、错误处理" class="headerlink" title="七、错误处理"></a>七、错误处理</h2><h3 id="7-1、错误识别"><a href="#7-1、错误识别" class="headerlink" title="7.1、错误识别"></a>7.1、错误识别</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 匹配 期待的 token；否则报错</span></span><br><span class="line"><span class="comment">// 读取下一个token</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">match</span><span class="params">(TokenType expectToken)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (expectToken == g_token.opType) &#123;	<span class="comment">// 与预期相同，跳过token， true</span></span><br><span class="line">		<span class="built_in">getNextToken</span>();</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;								<span class="comment">// 提示错误，但在这里不跳读</span></span><br><span class="line">		g_errorNum++;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;match error in line %d :\t\texpect Token %d, but %d value: %s \n&quot;</span>, g_lineNumber, expectToken, g_token.opType, g_token.value);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="7-2、跳读到可以正确分析的位置"><a href="#7-2、跳读到可以正确分析的位置" class="headerlink" title="7.2、跳读到可以正确分析的位置"></a>7.2、跳读到可以正确分析的位置</h3><p>直到识别到某些token才停止；</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;</span><br><span class="line">    LACK_SEMI_CST,              <span class="comment">// 常量定义没有分号，跳出当前，直到再次遇到常量定义、变量定义、语句</span></span><br><span class="line">    LACK_TYPE_CST,              <span class="comment">// 没有类型</span></span><br><span class="line">    LACK_ID_CST,                <span class="comment">// 没有标识符</span></span><br><span class="line">    LACK_ASSIGN_CST,            <span class="comment">// 没有赋值符号</span></span><br><span class="line"></span><br><span class="line">    LACK_XXX_VARDEF,            <span class="comment">// 变量定义出错，直接抛弃当前语句</span></span><br><span class="line"></span><br><span class="line">    LACK_TYPE_FUN,              <span class="comment">// 函数类型未说明</span></span><br><span class="line">    LACK_IDEN_FUN,              <span class="comment">// 函数名未说明   ， </span></span><br><span class="line">    LACK_KUOHAO_FUN,            <span class="comment">// 函数括号丢失   ， 跳过当前函数</span></span><br><span class="line"></span><br><span class="line">    SENTENCE_ERROR</span><br><span class="line">&#125;ErrorType;</span><br></pre></td></tr></table></figure>
<p>大致思想：</p>
<p>常量定义、变量定义、函数定义：跳过当前定义</p>
<p>语句：跳过当前语句</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (e)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">case</span> ErrorType::LACK_SEMI_CST:</span><br><span class="line">	<span class="keyword">case</span> ErrorType::LACK_TYPE_CST: </span><br><span class="line">	<span class="keyword">case</span> ErrorType::LACK_ID_CST:</span><br><span class="line">	<span class="keyword">case</span> ErrorType::LACK_ASSIGN_CST: &#123;</span><br><span class="line">		<span class="keyword">while</span> (g_token.opType != TokenType::CONST &amp;&amp; g_token.opType != TokenType::INT &amp;&amp; g_token.opType != TokenType::CHAR</span><br><span class="line">			&amp;&amp; g_token.opType != TokenType::VOID &amp;&amp; g_token.opType != TokenType::IF</span><br><span class="line">			&amp;&amp; g_token.opType != TokenType::WHILE &amp;&amp; g_token.opType != TokenType::FOR</span><br><span class="line">			&amp;&amp; g_token.opType != TokenType::IDEN &amp;&amp; g_token.opType != TokenType::RETURN</span><br><span class="line">			&amp;&amp; g_token.opType != TokenType::SCANF &amp;&amp; g_token.opType != TokenType::PRINTF</span><br><span class="line">			&amp;&amp; g_token.opType != TokenType::LBRACE &amp;&amp; g_token.opType != TokenType::RBRACE</span><br><span class="line">			)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (g_token.opType == TokenType::END) </span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">getNextToken</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 以上都是常量定义阶段的错误</span></span><br><span class="line">	<span class="comment">// 变量定义错误：</span></span><br><span class="line">	<span class="keyword">case</span> ErrorType::LACK_XXX_VARDEF: &#123;</span><br><span class="line">		<span class="keyword">while</span> (g_token.opType != TokenType::INT &amp;&amp; g_token.opType != TokenType::CHAR</span><br><span class="line">			&amp;&amp; g_token.opType != TokenType::VOID &amp;&amp; g_token.opType != TokenType::IF</span><br><span class="line">			&amp;&amp; g_token.opType != TokenType::WHILE &amp;&amp; g_token.opType != TokenType::FOR</span><br><span class="line">			&amp;&amp; g_token.opType != TokenType::IDEN &amp;&amp; g_token.opType != TokenType::RETURN</span><br><span class="line">			&amp;&amp; g_token.opType != TokenType::SCANF &amp;&amp; g_token.opType != TokenType::PRINTF</span><br><span class="line">			&amp;&amp; g_token.opType != TokenType::LBRACE &amp;&amp; g_token.opType != TokenType::RBRACE</span><br><span class="line">			)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (g_token.opType == TokenType::END)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">getNextToken</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 函数定义错误</span></span><br><span class="line">	<span class="keyword">case</span> ErrorType::LACK_TYPE_FUN:</span><br><span class="line">	<span class="keyword">case</span> ErrorType::LACK_IDEN_FUN: </span><br><span class="line">	<span class="keyword">case</span> ErrorType::LACK_KUOHAO_FUN: &#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span> (g_token.opType != TokenType::INT &amp;&amp; g_token.opType != TokenType::CHAR</span><br><span class="line">			&amp;&amp; g_token.opType != TokenType::VOID</span><br><span class="line">			)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (g_token.opType == TokenType::END)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">getNextToken</span>();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 语句错误</span></span><br><span class="line">	<span class="keyword">case</span> ErrorType::SENTENCE_ERROR: &#123;</span><br><span class="line">		<span class="keyword">while</span> (g_token.opType != TokenType::IF</span><br><span class="line">			&amp;&amp; g_token.opType != TokenType::WHILE &amp;&amp; g_token.opType != TokenType::FOR</span><br><span class="line">			&amp;&amp; g_token.opType != TokenType::IDEN &amp;&amp; g_token.opType != TokenType::RETURN</span><br><span class="line">			&amp;&amp; g_token.opType != TokenType::SCANF &amp;&amp; g_token.opType != TokenType::PRINTF</span><br><span class="line">			<span class="comment">/*&amp;&amp; g_token.opType != TokenType::LBRACE */</span>&amp;&amp; g_token.opType != TokenType::RBRACE</span><br><span class="line">			)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (g_token.opType == TokenType::END)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">getNextToken</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h3 id="7-3-语法树错误屏蔽"><a href="#7-3-语法树错误屏蔽" class="headerlink" title="7.3 语法树错误屏蔽"></a>7.3 语法树错误屏蔽</h3><p>语法树标识错误，语义分析时跳过。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误处理</span></span><br><span class="line"><span class="type">bool</span> error;</span><br></pre></td></tr></table></figure>
<h2 id="八、-bug修复"><a href="#八、-bug修复" class="headerlink" title="八、 bug修复"></a>八、 bug修复</h2><h3 id="1、asm生成阶段：scanf语句"><a href="#1、asm生成阶段：scanf语句" class="headerlink" title="1、asm生成阶段：scanf语句"></a>1、asm生成阶段：scanf语句</h3><p>bug：多次读取同名变量时，由于scanf是直接写入内存，但或许之前使用过这个变量，并且已经调入寄存器；查表的时候会显示在寄存器堆中，这样就会读取就值；<br>    发现于 Test11.c0；多次输入x，发现后面使用的x的值始终不变<br>    (old，会带来新问题，可用寄存器数目不断减少)处理：从寄存器堆中移除此变量，且不用写回内存；故只需更新符号表状态、寄存器映射队列、可用寄存器数目<br>    (new)处理：如果在寄存器，则更新寄存器数据即可，其他不变</p>
<h3 id="2、寄存器分配策略错误"><a href="#2、寄存器分配策略错误" class="headerlink" title="2、寄存器分配策略错误"></a>2、寄存器分配策略错误</h3><p>之前的寄存器分配是按照函数分配的（跳转函数才会清空寄存器）；后来在测试到快速排序的时候，由于各种跳转，导致寄存器有问题；不是正确的运行结果；如，之前要判断的某个循环变量分配到1号寄存器，但是循环内部变量较多，1号寄存器被移除，存储新的变量；这时跳转回去判断，寄存器里面就不是原来的变量了。</p>
<p>正确的方法：按照基本块来分配</p>
<p>首先是基本块划分：</p>
<ul>
<li>程序的第一个四元式</li>
<li>转向语句的目标四元式（即j,jnz,jop的目标）</li>
<li>条件跳转jop的下一条（由于四元式生成过程中下一条总是 j）</li>
</ul>
<p>划分完基本块后，在每个基本块结束时清空即可（或是下一基本块开始时，清空上一基本块；本质就是基本块开始时，全部寄存器是空的）；这样就不会出现各种跳转就不会出现寄存器出错的问题。</p>
<p>我采用的具体方法：j的时候清空，遇到label的时候清空。（对应的就是跳转语句的目标和条件跳转的下一句）。所以，该方法时正确的。程序的结果也是正确的。</p>
<h2 id="九、参考"><a href="#九、参考" class="headerlink" title="九、参考"></a>九、参考</h2><blockquote>
<p>  [1]  实现一个C++实现的拓展C0文法MIPS交叉编译器<a target="_blank" rel="noopener" href="https://www.cnblogs.com/sciencefans/articles/4235139.html">https://www.cnblogs.com/sciencefans/articles/4235139.html</a></p>
<p>  [2]  编译原理哈工大慕课与PPT<br>   <a target="_blank" rel="noopener" href="https://www.icourse163.org/learn/HIT-1002123007?tid=1206830204#/learn/content">https://www.icourse163.org/learn/HIT-1002123007?tid=1206830204#/learn/content</a></p>
<p>  [3]  编译原理 第3版 蒋立源 2005</p>
<p>  [4]  现代编译原理C语言描述<em>tif</em>虎书</p>
<p>  [5]  编译原理西工大PPT</p>
<p>  [6]  MIPS汇编入门<br>   <a target="_blank" rel="noopener" href="https://www.cnblogs.com/thoupin/p/4018455.html">https://www.cnblogs.com/thoupin/p/4018455.html</a></p>
<p>  [7]  MIPS汇编快速入门<br>   <a target="_blank" rel="noopener" href="https://blog.csdn.net/u012837895/article/details/79855896">https://blog.csdn.net/u012837895/article/details/79855896</a></p>
<p>  [8]  SYSCALL functions available in MARS<br>   <a target="_blank" rel="noopener" href="https://blog.csdn.net/sdreamq/article/details/50776393">https://blog.csdn.net/sdreamq/article/details/50776393</a></p>
<p>  [9]  Simple语言的定义(LL1文法)<br>   <a target="_blank" rel="noopener" href="https://wenku.baidu.com/view/0fc831e8998fcc22bcd10de9">https://wenku.baidu.com/view/0fc831e8998fcc22bcd10de9</a></p>
<p>  [10] 《编译原理》控制流语句 if 和 while 语句的翻译<br>   <a target="_blank" rel="noopener" href="https://www.cnblogs.com/xpwi/p/11072234.html">https://www.cnblogs.com/xpwi/p/11072234.html</a></p>
</blockquote>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://chen2511.github.io/">MomoChen</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://chen2511.github.io/">http://chen2511.github.io/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">此文章版权归 MomoChen 所有，如有转载，请注明来自原作者</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%BC%96%E8%AF%91%E5%99%A8/">编译器</a><a class="post-meta__tags" href="/tags/C0%E6%96%87%E6%B3%95/">C0文法</a><a class="post-meta__tags" href="/tags/C/">C++</a></div><div class="post_share"><div class="social-share" data-image="/img/complier.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/gh/overtrue/share.js@master/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2020/10/10/%E5%B7%A5%E5%85%B7/Ubuntu%2018.04%20%E7%BE%8E%E5%8C%96%E5%8F%8A%E9%85%8D%E7%BD%AE%E8%BF%87%E7%A8%8B/"><img class="prev-cover" src="/img/linux_all.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Ubuntu18.04 换源、美化及配置过程</div></div></a></div><div class="next-post pull-right"><a href="/2020/07/05/ComplierC0/C0%E6%96%87%E6%B3%95/"><img class="next-cover" src="/img/004-%E7%99%BD%E7%86%8A.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">C0文法</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2020/07/05/ComplierC0/C0%E6%96%87%E6%B3%95/" title="C0文法"><img class="cover" src="/img/004-%E7%99%BD%E7%86%8A.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-07-05</div><div class="title">C0文法</div></div></a></div><div><a href="/2020/07/05/ComplierC0/%E5%93%88%E5%B7%A5%E5%A4%A7%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/" title="哈工大慕课《编译原理》笔记"><img class="cover" src="/img/003-%E6%B5%B7%E6%B5%AA.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-07-05</div><div class="title">哈工大慕课《编译原理》笔记</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#CompilerC0"><span class="toc-text">CompilerC0</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%B6%E3%80%81%E6%96%87%E4%BB%B6%E8%AF%B4%E6%98%8E"><span class="toc-text">零、文件说明</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#0-1-%E7%BB%9F%E8%AE%A1%E4%BF%A1%E6%81%AF"><span class="toc-text">0.1 统计信息</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%EF%BC%9A"><span class="toc-text">一、词法分析：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E5%88%86%E6%9E%90%E6%80%9D%E8%B7%AF"><span class="toc-text">1.1 分析思路</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-1-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-text">1.1.1 正则表达式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-2-NFA"><span class="toc-text">1.1.2 NFA</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-3-DFA"><span class="toc-text">1.1.3 DFA</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-text">1.2 数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-1-Token"><span class="toc-text">1.2.1 Token</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-2-TokenType"><span class="toc-text">1.2.2 TokenType</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-3-%E4%BF%9D%E7%95%99%E5%AD%97%E8%A1%A8"><span class="toc-text">1.2.3 保留字表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-4-%E7%8A%B6%E6%80%81"><span class="toc-text">1.2.4 状态</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-DFA%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3"><span class="toc-text">1.3 DFA编程思想</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-1%E3%80%81%E9%9A%90%E5%90%AB%E7%8A%B6%E6%80%81"><span class="toc-text">1.3.1、隐含状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-2%E3%80%81%E5%8F%8C%E9%87%8Dcase"><span class="toc-text">1.3.2、双重case</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-3%E3%80%81%E8%BD%AC%E6%8D%A2%E8%A1%A8"><span class="toc-text">1.3.3、转换表</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-%E6%B3%A8%E6%84%8F%E9%97%AE%E9%A2%98%EF%BC%9A"><span class="toc-text">1.4 注意问题：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-1%E3%80%81%E8%AF%BB%E5%85%A5%E7%BC%93%E5%86%B2"><span class="toc-text">1.4.1、读入缓冲</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-2%E3%80%81%E4%BF%9D%E7%95%99%E5%AD%97%E7%9A%84%E8%AF%86%E5%88%AB"><span class="toc-text">1.4.2、保留字的识别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-3%E3%80%81%E5%B8%A6%E7%AC%A6%E5%8F%B7%E6%95%B0%E5%A4%84%E7%90%86"><span class="toc-text">1.4.3、带符号数处理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%86%E6%9E%90%EF%BC%9A"><span class="toc-text">分析：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95"><span class="toc-text">处理方法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-4%E3%80%81%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3"><span class="toc-text">1.3.4、冲突解决</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-5%E3%80%81%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86"><span class="toc-text">1.3.5、错误处理</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90"><span class="toc-text">二、语法分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E6%96%87%E6%B3%95%E6%94%B9%E9%80%A0"><span class="toc-text">2.1 文法改造</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-1-%E4%BA%8C%E4%B9%89%E6%80%A7"><span class="toc-text">2.1.1 二义性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-2-%E5%B7%A6%E9%80%92%E5%BD%92"><span class="toc-text">2.1.2 左递归</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-3-%E5%9B%9E%E6%BA%AF"><span class="toc-text">2.1.3 回溯</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-4-%E8%AE%A1%E7%AE%97FIRST%E5%92%8CFOLLOW%E9%9B%86"><span class="toc-text">2.1.4 计算FIRST和FOLLOW集</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-5-EBNF"><span class="toc-text">2.1.5 EBNF</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3"><span class="toc-text">2.2 编程思想</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-1-%E5%9F%BA%E6%9C%AC%E6%96%B9%E6%B3%95"><span class="toc-text">2.2.1 基本方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-2-%E9%87%8D%E5%A4%8D%E5%92%8C%E9%80%89%E6%8B%A9%EF%BC%9A%E4%BD%BF%E7%94%A8EBNF"><span class="toc-text">2.2.2 重复和选择：使用EBNF</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%AF%E9%80%89%E7%BB%93%E6%9E%84"><span class="toc-text">可选结构</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%87%8D%E5%A4%8D%E7%BB%93%E6%9E%84"><span class="toc-text">重复结构</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-text">2.3 数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-1-AST"><span class="toc-text">2.3.1 AST</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-2-%E5%9B%9E%E6%BA%AF%E6%8C%87%E9%92%88"><span class="toc-text">2.3.2 回溯指针</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E5%85%B3%E9%94%AE%E5%87%BD%E6%95%B0"><span class="toc-text">2.4 关键函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-1-%E5%8C%B9%E9%85%8D%E7%BB%88%E7%BB%93%E7%AC%A6%E5%87%BD%E6%95%B0"><span class="toc-text">2.4.1 匹配终结符函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-2-%E9%9D%9E%E7%BB%88%E7%BB%93%E7%AC%A6%E8%BF%87%E7%A8%8B"><span class="toc-text">2.4.2 非终结符过程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-%E6%B3%A8%E6%84%8F%E9%97%AE%E9%A2%98"><span class="toc-text">2.5 注意问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-1%E3%80%81%E5%85%AC%E5%85%B1%E5%9B%A0%E5%AD%90"><span class="toc-text">2.5.1、公共因子</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-2%E3%80%81%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95"><span class="toc-text">2.5.2、单元测试</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-3%E3%80%81%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86"><span class="toc-text">2.5.3、错误处理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-%E6%8A%BD%E8%B1%A1%E8%AF%AD%E6%B3%95%E6%A0%91AST"><span class="toc-text">2.6 抽象语法树AST</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6-1-%E8%AE%BE%E8%AE%A1%E6%8A%BD%E8%B1%A1%E8%AF%AD%E6%B3%95%E6%A0%91"><span class="toc-text">2.6.1 设计抽象语法树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6-2-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-text">2.6.2 数据结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6-3-%E7%BC%96%E7%A8%8B%E9%AA%8C%E8%AF%81"><span class="toc-text">2.6.3 编程验证</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6-4-%E8%BE%93%E5%87%BA%E5%88%B0%E6%96%87%E4%BB%B6"><span class="toc-text">2.6.4 输出到文件</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E8%AF%AD%E4%B9%89%E5%88%86%E6%9E%90"><span class="toc-text">三、语义分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E7%AC%A6%E5%8F%B7%E8%A1%A8"><span class="toc-text">3.1 符号表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-1-%E7%AC%A6%E5%8F%B7%E8%A1%A8%E7%BB%93%E6%9E%84"><span class="toc-text">3.1.1 符号表结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-2-%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C"><span class="toc-text">3.1.2 相关操作</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E8%AF%AD%E4%B9%89%E5%88%86%E6%9E%90%E7%A8%8B%E5%BA%8F"><span class="toc-text">3.2 语义分析程序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-1-%E7%AC%A6%E5%8F%B7%E8%A1%A8%E5%BB%BA%E7%AB%8B%E9%98%B6%E6%AE%B5"><span class="toc-text">3.2.1 符号表建立阶段</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-2-%E8%AF%AD%E4%B9%89%E6%A3%80%E6%9F%A5"><span class="toc-text">3.2.2 语义检查</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%AF%E8%83%BD%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98%E5%92%8C%E4%BC%98%E5%8C%96%EF%BC%9A"><span class="toc-text">可能出现的问题和优化：</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E4%B8%AD%E9%97%B4%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90"><span class="toc-text">四、中间代码生成</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E7%BF%BB%E8%AF%91%EF%BC%9A"><span class="toc-text">4.1 表达式的翻译：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E5%9B%9B%E5%85%83%E5%BC%8F"><span class="toc-text">4.2 四元式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E7%9B%AE%E6%A0%87%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90"><span class="toc-text">五、目标代码生成</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-0-%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80"><span class="toc-text">5.0 理论基础</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-%E5%AF%84%E5%AD%98%E5%99%A8%E5%88%86%E9%85%8D%E6%80%9D%E8%B7%AF"><span class="toc-text">5.1 寄存器分配思路</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E4%B8%80%E7%A7%8D%E8%BE%83%E4%B8%BA%E7%AE%80%E5%8D%95%E7%9A%84%E6%80%9D%E8%B7%AF%EF%BC%9A%EF%BC%88%E6%97%A0%E5%AF%84%E5%AD%98%E5%99%A8%E5%88%86%E9%85%8D%EF%BC%89"><span class="toc-text">1、一种较为简单的思路：（无寄存器分配）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E5%AF%84%E5%AD%98%E5%99%A8%E5%88%86%E9%85%8D%EF%BC%88FIFO%EF%BC%89"><span class="toc-text">2、寄存器分配（FIFO）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F"><span class="toc-text">注意</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-%E8%BF%87%E7%A8%8B"><span class="toc-text">5.3 过程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81genasm"><span class="toc-text">1、genasm:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81Func"><span class="toc-text">2、Func</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81%E9%80%90%E4%B8%AA%E5%88%86%E6%9E%90"><span class="toc-text">3、逐个分析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#bug"><span class="toc-text">bug</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-%E6%B5%8B%E8%AF%95"><span class="toc-text">5.4 测试</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Text03%EF%BC%9A%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA"><span class="toc-text">Text03：输入输出</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Text04%EF%BC%9A%E8%B5%8B%E5%80%BC%E8%AF%AD%E5%8F%A5%EF%BC%9A%E6%95%B4%E5%BD%A2%E3%80%81%E5%AD%97%E7%AC%A6%EF%BC%8C%E8%AF%AD%E5%8F%A5%E5%8F%B3%E8%BE%B9%E4%B8%8D%E8%80%83%E8%99%91%EF%BC%88%E7%94%B1%E5%9B%BA%E5%AE%9A%E5%87%BD%E6%95%B0%E5%8A%A0%E8%BD%BD%EF%BC%8C%E5%8D%95%E7%8B%AC%E6%B5%8B%E8%AF%95%EF%BC%89"><span class="toc-text">Text04：赋值语句：整形、字符，语句右边不考虑（由固定函数加载，单独测试）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Text05%EF%BC%9A%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E3%80%81%E8%BF%94%E5%9B%9E%E8%AF%AD%E5%8F%A5"><span class="toc-text">Text05：函数调用、返回语句</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Text06%EF%BC%9A%E7%AE%97%E6%9C%AF%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-text">Text06：算术表达式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Text07%EF%BC%9A%E5%B8%83%E5%B0%94%E8%A1%A8%E8%BE%BE%E5%BC%8F%E3%80%81%E6%9D%A1%E4%BB%B6%E5%BE%AA%E7%8E%AF"><span class="toc-text">Text07：布尔表达式、条件循环</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E4%BC%98%E5%8C%96"><span class="toc-text">六、优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-0-%E5%9F%BA%E6%9C%AC%E5%9D%97%E5%88%92%E5%88%86"><span class="toc-text">6.0 基本块划分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-%E5%B8%B8%E9%87%8F%E5%90%88%E5%B9%B6"><span class="toc-text">6.1 常量合并</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-%E5%BC%BA%E5%BA%A6%E5%89%8A%E5%BC%B1"><span class="toc-text">6.2 强度削弱</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-%E5%88%A0%E9%99%A4%E5%85%AC%E5%85%B1%E5%AD%90%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-text">6.3 删除公共子表达式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-%E5%AF%84%E5%AD%98%E5%99%A8%E5%88%86%E9%85%8D"><span class="toc-text">6.4 寄存器分配</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-4-1-%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3%EF%BC%9A"><span class="toc-text">6.4.1 基本思想：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-4-2-%E5%AE%9E%E7%8E%B0"><span class="toc-text">6.4.2 实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86"><span class="toc-text">七、错误处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1%E3%80%81%E9%94%99%E8%AF%AF%E8%AF%86%E5%88%AB"><span class="toc-text">7.1、错误识别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2%E3%80%81%E8%B7%B3%E8%AF%BB%E5%88%B0%E5%8F%AF%E4%BB%A5%E6%AD%A3%E7%A1%AE%E5%88%86%E6%9E%90%E7%9A%84%E4%BD%8D%E7%BD%AE"><span class="toc-text">7.2、跳读到可以正确分析的位置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-%E8%AF%AD%E6%B3%95%E6%A0%91%E9%94%99%E8%AF%AF%E5%B1%8F%E8%94%BD"><span class="toc-text">7.3 语法树错误屏蔽</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AB%E3%80%81-bug%E4%BF%AE%E5%A4%8D"><span class="toc-text">八、 bug修复</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81asm%E7%94%9F%E6%88%90%E9%98%B6%E6%AE%B5%EF%BC%9Ascanf%E8%AF%AD%E5%8F%A5"><span class="toc-text">1、asm生成阶段：scanf语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E5%AF%84%E5%AD%98%E5%99%A8%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5%E9%94%99%E8%AF%AF"><span class="toc-text">2、寄存器分配策略错误</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%9D%E3%80%81%E5%8F%82%E8%80%83"><span class="toc-text">九、参考</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background-image: url('/img/20150525233356_zkayE.png')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By MomoChen</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">欢迎来到漠漠的博客</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu@4/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>function addGitalkSource () {
  const ele = document.createElement('link')
  ele.rel = 'stylesheet'
  ele.href= 'https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css'
  document.getElementsByTagName('head')[0].appendChild(ele)
}

function loadGitalk () {
  function initGitalk () {
    var gitalk = new Gitalk(Object.assign({
      clientID: 'de79d51950505839a9fe',
      clientSecret: '9461941e93326020b9e565d3ef15d8b9d0513548',
      repo: 'chen2511.github.io',
      owner: 'chen2511',
      admin: ['chen2511'],
      id: '51f85238a567e2bab5197354f7d68513',
      updateCountCallback: commentCount
    },null))

    gitalk.render('gitalk-container')
  }

  if (typeof Gitalk === 'function') initGitalk()
  else {
    addGitalkSource()
    getScript('https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js').then(initGitalk)
  }
}

function commentCount(n){
  let isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
  if (isCommentCount) {
    isCommentCount.innerHTML= n
  }
}

if ('Gitalk' === 'Gitalk' || !false) {
  if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
  else loadGitalk()
} else {
  function loadOtherComment () {
    loadGitalk()
  }
}</script></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-nest.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>